---
title: Linux内核0.11完全注释 第二章
date: 2016-11-07 20:19:43
categories:
- study
tags:
- C/C++
- Linux kernel
- Asm
- LDD
---

> 微型计算机组成结构

-------
# 传统IBM PC及其兼容计算机的组成框图
可以看出唯有地址总线是单向的,从CPU发出,指向各种控制器和接口.而数据总线和控制总线需要是双向的是由于数据需要读写和控制信号的发出和捕获.
![Linux_0.11_arch_IBM_Intel](/images/Linux_0.11_arch_IBM_Intel.png)
# 现代PC机芯片集框图
![Linux_0.11_modern_PC.png](/images/Linux_0.11_modern_PC.png)

# I/O端口寻址和访问控制方式
## 端口编址
1 统一编址:把I/O控制器的端口地址归入存储器寻址地址空间范围内.CPU访问一个端口的操作与访问内存的操作一样,不需要特别的指令.硬件工程师或芯片工程师需确定采用何种编址.
2 独立编址:把I/O控制器和控制卡的寻址空间单独作为一个独立的地址空间对待,称为I/O地址空间.必须使用特殊指令来操作,例如Intel中的IN和OUT指令.此时引脚接线也不一样.  


IBM PC采用了两种方案,独立编址部分采用ISA总线结构分配I/O空间为0x000-0x3ff共1024个端口.统一编址部分例如CGA显卡占据存储器空间0xB8000-0xBC000范围,即CPU地址总线发出此范围的地址并向数据总线上按约定写入ascll值及属性即可显示字符了.  
### 查看I/O地址范围
```bash
rutk1t0r@Rutk1t0r:~$ cat /proc/ioports 
0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0062-0062 : PNP0C09:00
    0062-0062 : EC data
  0064-0064 : keyboard
  0066-0066 : PNP0C09:00
    0066-0066 : EC cmd
  0070-0077 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
    00f0-00f0 : PNP0C04:00
  03c0-03df : vesafb
  0400-0403 : ACPI PM1a_EVT_BLK
  0404-0405 : ACPI PM1a_CNT_BLK
  0408-040b : ACPI PM_TMR
  0410-0415 : ACPI CPU throttle
  0420-042f : ACPI GPE0_BLK
  0430-0433 : iTCO_wdt.2.auto
  0450-0450 : ACPI PM2_CNT_BLK
  0454-0457 : pnp 00:02
  0458-047f : pnp 00:00
    0460-047f : iTCO_wdt.2.auto
  0500-057f : pnp 00:00
  0680-069f : pnp 00:00
0cf8-0cff : PCI conf1
0d00-ffff : PCI Bus 0000:00
  1000-100f : pnp 00:00
  164e-164f : pnp 00:00
  2000-2fff : PCI Bus 0000:01
    2000-20ff : 0000:01:00.0
      2000-20ff : r8169
  3000-303f : 0000:00:02.0
  3040-305f : 0000:00:1f.3
  3060-307f : 0000:00:1f.2
    3060-307f : ahci
  3080-3087 : 0000:00:1f.2
    3080-3087 : ahci
  3088-308f : 0000:00:1f.2
    3088-308f : ahci
  3090-3093 : 0000:00:1f.2
    3090-3093 : ahci
  3094-3097 : 0000:00:1f.2
    3094-3097 : ahci
  4000-4fff : PCI Bus 0000:02
  fd60-fd63 : pnp 00:00
  ffff-ffff : pnp 00:00
    ffff-ffff : pnp 00:00
```
## 接口访问控制
### 轮询
CPU通过在程序中循环查询制定设备控制器中的状态来判断是否与设备进行数据交换.简单耗费CPU时间,适合任务等待时间极短或必须的情况.
### 中断
需要中断控制器的支持,顾名思义,当事件发生后,CPU暂停当前程序转而执行I/O中断处理服务过程,之后视情况才恢复被中断的程序.需要早就填充好中断向量表.效率较高.
### DMA
用于I/O设备与系统内存之间进行大批量数据传送,整个过程需要使用专门的DMA控制器来进行而CPU在传输过程中无需插手.结合中断配合效率很高的.

# 存储器
## 主存储器映射
![Linux_0.11_Main_Memory.png](/images/Linux_0.11_Main_Memory.png)
## BIOS
顾名思义,基本的输入/输出系统,存放在ROM中的系统BIOS主要用于计算机开机执行系统各个部分自检,并建立起操作系统要使用的各种配置表,把处理器和系统其余部分初始化到一个已知的状态,且为DOS等系统提供硬件设备接口服务.除此之外Linux操作系统在运行的时候并不适用BIOS中的功能.当计算机系统上电开机或者按下了机箱上的复位按钮时,CPU捕获到信号后把CS寄存器设置为0xF000,段基址被设置为0xFFFF0000,段长度为64K.而EIP寄存器(32位体系)被设置为0xFFF0,因此线性地址计算得到0xFFFFFFF0,这个是写死的.4G空间最后一个64K(以前的8086分段特性)的最后16字节处,一般安排一条JMP跳转指令跳到BIOS代码中64KB范围内的某一条指令开始执行.由于目前PC/AT微机中的BIOS容量大多有1MB-2MB,并存储在FLASH中,因此为了能够执行或者访问BIOS超过64KB范围并且又远远不在0-1M地址空间中的其他BIOS代码或者数据,BIOS程序首先使用一个成为32位大模式技术把数据段寄存器的访问范围设置为4G.此后,BIOS在执行了一系列硬件检测和初始化操作之后,把与原来PC机兼容的64KB BIOS代码和数据复制到内存低端1M末端的64K处,然后跳转到这个地方并且让CPU进入真正的实地址模式工作.如下图,最后BIOS会从硬盘或者其他块启动设备把操作系统引导程序加载在内存0x7c00处(Intel约定),并跳转到这个地方继续执行引导程序.
![Linux_0.11_ROM_BIOS.png](/images/Linux_0.11_ROM_BIOS.png)
## CMOS存储器
主要用来存放计算机实时时钟信息和系统硬件配置信息,这部分内存通常和实时时钟芯片做在一块集成块中,CMOS内存的地址空间在基本内存地址空间之外,需要用I/O指令来访问.

# 控制器和控制卡
## 中断控制器
IBM PC/AT 80X86兼容微机采两片级联的8259A可编程中断控制芯片组成一个中断控制器,Linux在内核初始化会继续重新对8259A进行编程来使得其符合自身的控制.
![Linux_0.11_interrupt_8259A.png](/images/Linux_0.11_interrupt_8259A.png)

## DMA控制器
采用两块Intel 8237芯片具有8个独立通道,对页面寄存器端口,(偏移)地址寄存器端口和数据寄存器端口进行设置来启用数据传送.由于DMA寄存器是8位的,而地址和计数值是16位值,因此各自需要发送两次.

## 定时/计数器
采用Intel 8253/8254来产生精确的计时中断信号,动态内存DRAM刷新电路和主机扬声器音调合成.Linux 0.11对通道0进行设置,使其工作在方式3下,并且每隔10ms发出IRQ0,即内核的工作脉搏,用于定时切换任务及统计系统资源量.
## 键盘控制器
采用类Intel 8042芯片对键盘的接通码和断开嘛进行扫描并计算.通过IRQ1引脚向CPU发出中断请求.根据三套扫描码集确定具体键盘字符.(早期的键盘控制器P21引脚控制CPU A21信号线开启大范围寻址)
## 串行控制卡
PC常用符合RS-232C标准的串行接口,并使用通用异步收发器控制芯片UART组成的串行控制器来处理串行数据的手法工作.
## 显示控制
IBM最早推出的PC机视频系统标准有单色MDA标准和彩色CGA标准以及EGA和VGA标准.以后推出的所有高级显卡(包括现在的AGP显卡)虽然都具有极高的图形处理速度和智能加速处理,但是它们都支持这几种标准.Linux 0.1x操作系统仅仅使用了这几种标准都支持的文本显示方式.
### MDA显示标准
仅支持黑白两色,并且只支持独有的文本字符显示方式(BIOS显示方式7).屏幕规格80\*25(列号x=0..79;行号y=0..24),共可以显示2000字符(难怪在Linux中打开shell默认都是80\*25).每个字符还带有1个属性字节,因此显示一屏(一帧)内容需要占据4KB字节.其中偶地址字节存放字符代码(ascll),奇地址存放显示属性.MDA卡配置有8KB显存.在PC机内存寻址范围中占用0xb0000开始的8K空间(0xb0000-0xb2000).如果显示屏行数是video\_num\_lines=25;列数是video\_num\_colums=80,那么位于屏幕列行值x,y处的字符和属性在内存中的位置是:  
字符字节位置 = 0xb0000 + video\_num\_colums\*2\*y + x\*2;
属性字节位置 = 字符字节位置+1;
> **注意此处坐标系为从屏幕左上角开始往右为x增大,往下为y增大,均不为负值.**  


![Linux_0.11_MDA_Color.png](/images/Linux_0.11_MDA_Color.png)



### CGA显示标准
CGA支持7种彩色和图形显示方式(BIOS显示方式0-6).在80列\*25行的文本字符显示方式下,有单色和16色彩色两种显示方式(BIOS显示方式2-3).CGA卡标配有16K显示内存(占用内存地址范围0xb8000-0xbc000),因此可存放4帧信息,同样,在每一帧4K显存中,偶数地址存字符代码,奇数字节存放显示属性.但是在console.c程序中只使用了其中8K显存(0xb8000-0xba000).字符显示属性定义如下:
![Linux_0.11_CGA_Color.png](/images/Linux_0.11_CGA_Color.png)

### EGA/VGA显示标准
![Linux_0.11_EGA_VGA.png](/images/Linux_0.11_EGA_VGA.png)

## 软盘和硬盘控制器
由于软盘片比较容易遭到损坏(发霉或划伤),因此目前计算机中已经逐渐开始不配置软盘驱动器,取而代之的是用U盘.而硬盘作为相对于比较大容量和每比特信息廉价的外存设备,在PC中仍然大量存在.下面是硬盘的一些工作原理:
![Linux_0.11_hard_disk1.png](/images/Linux_0.11_hard_disk1.png)
![Linux_0.11_hard_disk2.png](/images/Linux_0.11_hard_disk2.png)

# 总结
本章介绍了基于Intel 80X86芯片组的计算机组成结构及各个工作部件的工作原理.便于理解操作系统内核的实现,毕竟软件要根据硬件的框架在铺设的.
