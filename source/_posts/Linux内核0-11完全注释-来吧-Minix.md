---
title: Linux内核0.11完全注释 来吧,Minix!
date: 2016-12-22 22:44:04
categories:
- study
tags:
- C/C++
- Linux kernel
- Asm
- LDD
---

> 认真学习Minix文件系统!通过一个实例手动分析Minix。具体源码实现由于考虑其他情况将很复杂。

-------------------------

# mkfs a minix
如下图所示,先不考虑什么是i节点等等，我们只需要知道目前手动创建了一个文件系统，大小为360KB,并且拷贝了一个hello.c文件到其根目录下。
![Linux_0.11_Minix_mkfs_dev_fd1_360.png](/images/Linux_0.11_Minix_mkfs_dev_fd1_360.png)
![Linux_0.11_Minix_mkfs_dev_fd1_360_do.png](/images/Linux_0.11_Minix_mkfs_dev_fd1_360_do.png)

# 再来简介Minux文件系统格式  
## 引导块
根据Minux文件系统的设计，我们上面创建的360KB的软盘总共分为6个部分，图中的块是以1KB为单位的，这是设计需求，注意区别于硬盘中的扇区。其中约定第一个块为引导块，虽然引导区约定为512字节但是在这里最小单位为1K,浪费也就不在乎了。即使不引导也得有引导标志以符合标准。
![Linux_0.11_Minix_360K_fd_layout.png](/images/Linux_0.11_Minix_360K_fd_layout.png)
- 注意0x200偏移前面的0xaa55。
![Linux_0.11_Minix_360K_Boot.png](/images/Linux_0.11_Minix_360K_Boot.png)
## 超级块
仅仅知道这是一块可用的软盘还是不够的，必须还得知道到底我们需要的数据存在什么地方。因此Minix文件系统在设计的时候用一个数据结构来描述整个可用设备的具体情况。
![Linux_0.11_Minix_360K_super_block.png](/images/Linux_0.11_Minix_360K_super_block.png)
为什么要分内存中字段和磁盘中字段呢?本应该磁盘中存储这些数据结构是够了，但是操作系统为了更快更好地管理文件系统便用"以空间来换时间"的思想来操作数据。下面继续分析我们自己创建的360KB的软盘。在bochs终端键入`hexdump /dev/fd1 | more`。加more是由于终端不支持拉屏只能一帧帧看了。我们按空格键快速定位到偏移0x400。刚好是1KB后的块，即第1个块(引导区约定为0块)。对照着上面的数据结构照葫芦画瓢来解析各个字段(注意intel小端格式的显示)。
- 0x0078 short 16位 对应文件系统中i节点总数目 十进制为120 刚好对应创建文件系统的时候显示的结果。
- 0x0168 short 16位 逻辑块的数目　十进制为360 实质上在Minix 1.0设计的时候逻辑块大小等于磁盘块大小
- 0x0001 short 16位 i节点位图占块数目　1表示仅仅用一个块就可以描述所有i就节点映射情况
- 0x0001 short 16位 逻辑块位图占块数目 同上
- 0x0008　short 16位 表示数据区第一个块号 真正保存文件内容的块区
- 0x0000 short 16位 在Minux 1.0中恒等于0，为后期改版做准备。
- 0x10081c00 long 32位 最大文件长度，书中注释到"显然有误",此字段应该是mkfs程序填充的，但是后面学习了i节点后进过计算个人认为没有那么"显然",mkfs程序仅仅是用双重间接块号来计算的，即512\*512\*1KB = 256MB=268966912=0x10081c00字节。但是实际情况是可以再存多一点的。加上前面的直接块号和一次间接块号。但是从内存字段的定义来看答案又不一样...(不触碰原则就没事儿,灵活点儿)
- 0x137f short 16位 Magic Number　约定值，类似于本版本文件系统的标志。
![Linux_0.11_Minix_360K_super_block_data.png](/images/Linux_0.11_Minix_360K_super_block_data.png)
- 关于内存中的字段含义参见原书或者Minix文件系统原理，对照着功能实现源码分析更好。
- 超级块在内核初始化的时候会被加载并分析，主要是为了加载根文件系统，或者mount其他文件系统和设备。

## i节点位图和逻辑块位图
图中偏移量0x800和0xc00分别表示，均为0x0007,表示有三个块被占用，当然约定第0比特不能用，直接被设置为1。所以文件系统中有两个块被使用。
## i节点
文件系统中最重要的数据结构!!!和超级块类似，磁盘中仅仅保存最精简的字段，内存中其他字段将经常被使用。
![Linux_0.11_Minix_1.0_inode_struct.png](/images/Linux_0.11_Minix_1.0_inode_struct.png)
看下图我们开始时候创建的360KB的软盘。
![Linux_0.11_Minix_1.0_inode_struct_do.png](/images/Linux_0.11_Minix_1.0_inode_struct_do.png)
继续照葫芦画瓢~由上述定义可以知道,inode在磁盘空间大小为32字节，所以一个块(1024字节)能够存1024/32=32个数据结构，因此4个块就刚好是128个i节点。其中的4是块4、5、6、7。块0引导,块1为super_block。块2、3分别是位图。块8就是真正的数据部分了。找到偏移为0x1000(第4块)。
- 0x41ed 表示目录文件权限为755。
- 0x0000 表示uid为0，即root用户
- 0x00000030 表示文件长度为0x30
- 0x585d223b 时间戳
- 0x00 gid为0,表示root用户组
- 0x02 链接数
- 0x08　数据区域的第一个块位置，后续均为0表示没有更多数据块了。 
![Linux_0.11_Minix_1.0_inode_struct_imode.png](/images/Linux_0.11_Minix_1.0_inode_struct_imode.png)
我们根据目录项的数据结构定义跳到第8块逻辑块继续追踪。即偏移量为0x2000处。
- 第一项
 - 0x0001 为i节点号(刚刚才跳过来的地方)
 - 0x2e 即为'.'，表示当前目录
- 第二项
 - 0x0001 为i节点号
 - 0x2e2e 即为".."，表示上层目录，因为这是根目录，因此".."="."
- 第三项
 - 0x0002 为i节点号(待会儿分析）
 - 一波ascii码，表示"hello.c"


关于如何根据文件名称定位一个具体文件算法可以参见源码，原理参见书。
![Linux_0.11_Minix_1.0_dir_entry_struct.png](/images/Linux_0.11_Minix_1.0_dir_entry_struct.png)

然后接着上面把hello.c文件也分析一下,如果已经定位了到刚刚的第三项，根据inode为2定位到其inode数据结构。
- 0x8180 表示普通文件权限为600,注意文件类型定义为8进制数
- 0x0000 root
- 0x0000004a 表示文件大小为74字节
- 0x585d223b 时间戳
- 0x01 链接数
- 0x00 root
- 0x09 数据部分第一个块区，内容不多因此一个块足够。


定位到偏移量为0x2400处，将这一大串ascii码翻译过来就是hello.c文件的具体内容。

# 定位文件基本原理
![Linux_0.11_Minix_1.0_find_file_by_name.png](/images/Linux_0.11_Minix_1.0_find_file_by_name.png)
![Linux_0.11_Minix_1.0_find_file_by_name_words.png](/images/Linux_0.11_Minix_1.0_find_file_by_name_words.png)

# 总结
当然不可能每次都需要人来手动计算，计算机内部实现了更多算法来存取数据，大概的基本原理就这些，当然内存里面关于缓存和文件表等后期会稍微提一下。
