---
title: C语言宏定义小试
date: 2016-09-06 20:51:30
tags:
- C/C++
- Linux
categories:
- study
---

> 今天方小白童鞋笔试了CVTE，遇到了很多Linux开发的问题，其实不乏有关于内核配置，boot启动分析相关试题等等，在这里主要分析一下C语言中宏定义的问题.主要侧重于实战了，具体的还是要根据标准来。我用的实验平台是ubuntu 16.04 i386。

---

# gcc编译过程分析
![gcc_program](/images/gcc_program.png)

如上图所示，上图是在**《程序员自我修养》**这本书里面看到的，首先头文件和源文件在预处理阶段会融合在一起，生成.i文件。然后经过编译会生成.s文件，内容是汇编语言形式，之后经过汇编过程后变成.o的目标文件，这个文件其实已经成为了机器码了，但是缺乏加载地址以及函数符号问题未解决等，最后经过和库文件等进行链接生成可执行的二进制文件。在Linux下为elf格式，Windows下为PE格式。执行的时候将由各自的加载器对可执行文件中的代码和数据等进行解析并加载至内存中相应的属性页。当然如果直接一步`gcc sources -o target`是看不到这些过程的，gcc会一次性完成这些操作。下面我们就来实战一下吧。测试的源代码如下，有兴趣的还可以改用`++a`看看结果。
```C
#include <stdio.h>

#define F(x) ((x)*(x))
void main(void)
{
	int a = 4;
	//printf("%d\n", F(++a));
	printf("%d\n", F(a++));
}
```

# 预处理
首先我们看下图的源文件，其中就是涉及到了主要矛盾，**宏定义**。这个在C语言中用得相当多的一个技巧。在C++中会推荐使用**const**。具体缘由请自行搜索。像这种运算会产生问题的地方就是将变量填充为单目运算符的时候会发生问题。
![compile](/images/compile.png)
接下来我们键入
```C
gcc -E mocro_define.c -o mocro_define.i
```
![define_E](/images/define_E.png)
我们可以看到在生在.i文件之后，最后的几行代码被改变了，其中就是define被展开了。而且gcc在.i文件中插入了大量的外部引用和声明。总计有800多行。接下来我们看怎么编译。

# 编译
我们键入以下命令，其中的`-masm=intel`选项是让生成的汇编代码为intel格式的而非AT&T格式的，个人还是习惯看intel格式的。
```C
gcc -S mocro_define.i -o mocro_define.s -masm=intel
```
![define_S](/images/define_S.png)
主要的部分如下图所示，其中很多.开头的都是一些符号，不必在意。程序段在开辟新的空间之后直接将4赋值给了`[ebp-12]`,即a。然后再将它的值送到`edx`寄存器，之后编译器利用`lea`指令优化使得`a++`执行，而后立即回送至内存中的a。之后又使得`a++`执行并回送至内存中。但是注意到，`imul`指令执行的时候仍然用的是`edx`和`eax`的值，即4\*5,而`ecx`值虽然为6(最后的a)但是并不参与运算。最后直接将`eax`压栈`call printf`即可打印出来结果。在这里可以看出两个`a++`仅仅只有一个值是参与了乘法运算，详情可以参考优先级策略，可以深刻地理解编译器是如何处理这个类似`a++`运算符的。
![define_S_main](/images/define_S_main.png)

# 汇编
之后我们键入以下命令继续这个过程：
```C
gcc -c mocro_define.s -o mocro_define.o
```
![define_c](/images/define_c.png)
我们用readelf工具可以知道已经生成了与平台相关的目标代码了，这一步gcc内部封装的是as工具，当然我们也可以单独用as命令来执行汇编过程。特别是开发asm程序的时候可能会用到。接下来进行最后的链接过程。
# 链接
键入以下命令并执行可执行程序：
```C
gcc mocro_define.o -o mocro_define
./mocro_define
```
![define_o](/images/define_o.png)
最后的结果就是汇编当中的代码分析过程。当然这一步也是gcc内部封装的ld工具，我们也可以手动执行，但是太麻烦，还要解决引入的库文件等问题。

# 总结
这篇文章主要还是从C程序的编译过程来逐步拆解分析。**宏定义**本身还是不严格的直接替换式地插入,对于类型检查不严格，对于表达式不计算，才会导致问题的发生。我们稍微调试一下明白了。建议还是从C语言的运算符优先级入手，分析这个过程可能容易很多，因为编译器也是遵照标准来实现的。
